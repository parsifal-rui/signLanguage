{
  "version": 3,
  "sources": ["../../@pixiv/three-vrm-core/src/expressions/VRMExpression.ts", "../../@pixiv/three-vrm-core/src/expressions/VRMExpressionLoaderPlugin.ts", "../../@pixiv/three-vrm-core/src/utils/gltfExtractPrimitivesFromNode.ts", "../../@pixiv/three-vrm-core/src/expressions/VRMExpressionPresetName.ts", "../../@pixiv/three-vrm-core/src/utils/saturate.ts", "../../@pixiv/three-vrm-core/src/expressions/VRMExpressionManager.ts", "../../@pixiv/three-vrm-core/src/expressions/VRMExpressionMaterialColorType.ts", "../../@pixiv/three-vrm-core/src/expressions/VRMExpressionMaterialColorBind.ts", "../../@pixiv/three-vrm-core/src/expressions/VRMExpressionMorphTargetBind.ts", "../../@pixiv/three-vrm-core/src/expressions/VRMExpressionTextureTransformBind.ts", "../../@pixiv/three-vrm-core/src/expressions/VRMExpressionOverrideType.ts", "../../@pixiv/three-vrm-core/src/firstPerson/VRMFirstPerson.ts", "../../@pixiv/three-vrm-core/src/firstPerson/VRMFirstPersonLoaderPlugin.ts", "../../@pixiv/three-vrm-core/src/firstPerson/VRMFirstPersonMeshAnnotationType.ts", "../../@pixiv/three-vrm-core/src/humanoid/helpers/VRMHumanoidHelper.ts", "../../@pixiv/three-vrm-core/src/humanoid/VRMHumanBoneList.ts", "../../@pixiv/three-vrm-core/src/humanoid/VRMHumanBoneName.ts", "../../@pixiv/three-vrm-core/src/humanoid/VRMHumanBoneParentMap.ts", "../../@pixiv/three-vrm-core/src/humanoid/VRMRig.ts", "../../@pixiv/three-vrm-core/src/utils/quatInvertCompat.ts", "../../@pixiv/three-vrm-core/src/humanoid/VRMHumanoidRig.ts", "../../@pixiv/three-vrm-core/src/humanoid/VRMHumanoid.ts", "../../@pixiv/three-vrm-core/src/humanoid/VRMRequiredHumanBoneName.ts", "../../@pixiv/three-vrm-core/src/humanoid/VRMHumanoidLoaderPlugin.ts", "../../@pixiv/three-vrm-core/src/lookAt/helpers/VRMLookAtHelper.ts", "../../@pixiv/three-vrm-core/src/lookAt/helpers/utils/FanBufferGeometry.ts", "../../@pixiv/three-vrm-core/src/lookAt/helpers/utils/LineAndSphereBufferGeometry.ts", "../../@pixiv/three-vrm-core/src/lookAt/VRMLookAt.ts", "../../@pixiv/three-vrm-core/src/utils/getWorldQuaternionLite.ts", "../../@pixiv/three-vrm-core/src/lookAt/utils/calcAzimuthAltitude.ts", "../../@pixiv/three-vrm-core/src/lookAt/utils/sanitizeAngle.ts", "../../@pixiv/three-vrm-core/src/lookAt/VRMLookAtBoneApplier.ts", "../../@pixiv/three-vrm-core/src/lookAt/VRMLookAtExpressionApplier.ts", "../../@pixiv/three-vrm-core/src/lookAt/VRMLookAtRangeMap.ts", "../../@pixiv/three-vrm-core/src/lookAt/VRMLookAtLoaderPlugin.ts", "../../@pixiv/three-vrm-core/src/lookAt/VRMLookAtTypeName.ts", "../../@pixiv/three-vrm-core/src/meta/VRMMetaLoaderPlugin.ts", "../../@pixiv/three-vrm-core/src/utils/resolveURL.ts", "../../@pixiv/three-vrm-core/src/VRMCore.ts", "../../@pixiv/three-vrm-core/src/VRMCoreLoaderPlugin.ts", "../../@pixiv/three-vrm/src/VRM.ts", "../../@pixiv/three-vrm-materials-mtoon/src/MToonMaterialLoaderPlugin.ts", "../../@pixiv/three-vrm-materials-mtoon/src/GLTFMToonMaterialParamsAssignHelper.ts", "../../@pixiv/three-vrm-materials-mtoon/src/utils/setTextureColorSpace.ts", "../../@pixiv/three-vrm-materials-mtoon/src/MToonMaterial.ts", "../../@pixiv/three-vrm-materials-mtoon/src/shaders/mtoon.vert", "../../@pixiv/three-vrm-materials-mtoon/src/shaders/mtoon.frag", "../../@pixiv/three-vrm-materials-mtoon/src/MToonMaterialDebugMode.ts", "../../@pixiv/three-vrm-materials-mtoon/src/MToonMaterialOutlineWidthMode.ts", "../../@pixiv/three-vrm-materials-mtoon/src/utils/getTextureColorSpace.ts", "../../@pixiv/three-vrm-materials-hdr-emissive-multiplier/src/VRMMaterialsHDREmissiveMultiplierLoaderPlugin.ts", "../../@pixiv/three-vrm-materials-v0compat/src/VRMMaterialsV0CompatPlugin.ts", "../../@pixiv/three-vrm-materials-v0compat/src/utils/gammaEOTF.ts", "../../@pixiv/three-vrm-node-constraint/src/helpers/VRMNodeConstraintHelper.ts", "../../@pixiv/three-vrm-node-constraint/src/VRMAimConstraint.ts", "../../@pixiv/three-vrm-node-constraint/src/utils/decomposePosition.ts", "../../@pixiv/three-vrm-node-constraint/src/utils/decomposeRotation.ts", "../../@pixiv/three-vrm-node-constraint/src/utils/quatInvertCompat.ts", "../../@pixiv/three-vrm-node-constraint/src/VRMNodeConstraint.ts", "../../@pixiv/three-vrm-node-constraint/src/utils/traverseAncestorsFromRoot.ts", "../../@pixiv/three-vrm-node-constraint/src/VRMNodeConstraintManager.ts", "../../@pixiv/three-vrm-node-constraint/src/VRMRotationConstraint.ts", "../../@pixiv/three-vrm-node-constraint/src/VRMRollConstraint.ts", "../../@pixiv/three-vrm-node-constraint/src/VRMNodeConstraintLoaderPlugin.ts", "../../@pixiv/three-vrm-springbone/src/helpers/VRMSpringBoneColliderHelper.ts", "../../@pixiv/three-vrm-springbone/src/VRMSpringBoneColliderShapeCapsule.ts", "../../@pixiv/three-vrm-springbone/src/VRMSpringBoneColliderShape.ts", "../../@pixiv/three-vrm-springbone/src/VRMSpringBoneColliderShapePlane.ts", "../../@pixiv/three-vrm-springbone/src/VRMSpringBoneColliderShapeSphere.ts", "../../@pixiv/three-vrm-springbone/src/helpers/utils/ColliderShapeCapsuleBufferGeometry.ts", "../../@pixiv/three-vrm-springbone/src/helpers/utils/ColliderShapePlaneBufferGeometry.ts", "../../@pixiv/three-vrm-springbone/src/helpers/utils/ColliderShapeSphereBufferGeometry.ts", "../../@pixiv/three-vrm-springbone/src/helpers/VRMSpringBoneJointHelper.ts", "../../@pixiv/three-vrm-springbone/src/helpers/utils/SpringBoneBufferGeometry.ts", "../../@pixiv/three-vrm-springbone/src/VRMSpringBoneCollider.ts", "../../@pixiv/three-vrm-springbone/src/VRMSpringBoneJoint.ts", "../../@pixiv/three-vrm-springbone/src/utils/Matrix4InverseCache.ts", "../../@pixiv/three-vrm-springbone/src/utils/mat4InvertCompat.ts", "../../@pixiv/three-vrm-springbone/src/VRMSpringBoneLoaderPlugin.ts", "../../@pixiv/three-vrm-springbone/src/utils/traverseAncestorsFromRoot.ts", "../../@pixiv/three-vrm-springbone/src/utils/traverseChildrenUntilConditionMet.ts", "../../@pixiv/three-vrm-springbone/src/utils/lowestCommonAncestor.ts", "../../@pixiv/three-vrm-springbone/src/VRMSpringBoneManager.ts", "../../@pixiv/three-vrm/src/VRMLoaderPlugin.ts", "../../@pixiv/three-vrm/src/VRMUtils/combineMorphs.ts", "../../@pixiv/three-vrm/src/VRMUtils/combineSkeletons.ts", "../../@pixiv/three-vrm/src/utils/attributeGetComponentCompat.ts", "../../@pixiv/three-vrm/src/utils/attributeSetComponentCompat.ts", "../../@pixiv/three-vrm/src/VRMUtils/deepDispose.ts", "../../@pixiv/three-vrm/src/VRMUtils/removeUnnecessaryJoints.ts", "../../@pixiv/three-vrm/src/VRMUtils/removeUnnecessaryVertices.ts", "../../@pixiv/three-vrm/src/VRMUtils/rotateVRM0.ts", "../../@pixiv/three-vrm/src/VRMUtils/index.ts"],
  "sourcesContent": ["import * as THREE from 'three';\nimport { VRMExpressionBind } from './VRMExpressionBind';\nimport type { VRMExpressionOverrideType } from './VRMExpressionOverrideType';\nimport type { VRMExpressionManager } from './VRMExpressionManager';\n\n// animationMixer \u306E\u76E3\u8996\u5BFE\u8C61\u306F\u3001Scene \u306E\u4E2D\u306B\u5165\u3063\u3066\u3044\u308B\u5FC5\u8981\u304C\u3042\u308B\u3002\n// \u305D\u306E\u305F\u3081\u3001\u8868\u793A\u30AA\u30D6\u30B8\u30A7\u30AF\u30C8\u3067\u306F\u306A\u3044\u3051\u308C\u3069\u3001Object3D \u3092\u7D99\u627F\u3057\u3066 Scene \u306B\u6295\u5165\u3067\u304D\u308B\u3088\u3046\u306B\u3059\u308B\u3002\nexport class VRMExpression extends THREE.Object3D {\n  /**\n   * Name of this expression.\n   * Distinguished with `name` since `name` will be conflicted with Object3D.\n   */\n  public expressionName: string;\n\n  /**\n   * The current weight of the expression.\n   *\n   * You usually want to set the weight via {@link VRMExpressionManager.setValue}.\n   *\n   * It might also be controlled by the Three.js animation system.\n   */\n  public weight = 0.0;\n\n  /**\n   * Interpret values greater than 0.5 as 1.0, ortherwise 0.0.\n   */\n  public isBinary = false;\n\n  /**\n   * Specify how the expression overrides blink expressions.\n   */\n  public overrideBlink: VRMExpressionOverrideType = 'none';\n\n  /**\n   * Specify how the expression overrides lookAt expressions.\n   */\n  public overrideLookAt: VRMExpressionOverrideType = 'none';\n\n  /**\n   * Specify how the expression overrides mouth expressions.\n   */\n  public overrideMouth: VRMExpressionOverrideType = 'none';\n\n  /**\n   * Binds that this expression influences.\n   */\n  private _binds: VRMExpressionBind[] = [];\n\n  /**\n   * Binds that this expression influences.\n   */\n  public get binds(): readonly VRMExpressionBind[] {\n    return this._binds;\n  }\n\n  override readonly type: string | 'VRMExpression';\n\n  /**\n   * A value represents how much it should override blink expressions.\n   * `0.0` == no override at all, `1.0` == completely block the expressions.\n   */\n  public get overrideBlinkAmount(): number {\n    if (this.overrideBlink === 'block') {\n      return 0.0 < this.outputWeight ? 1.0 : 0.0;\n    } else if (this.overrideBlink === 'blend') {\n      return this.outputWeight;\n    } else {\n      return 0.0;\n    }\n  }\n\n  /**\n   * A value represents how much it should override lookAt expressions.\n   * `0.0` == no override at all, `1.0` == completely block the expressions.\n   */\n  public get overrideLookAtAmount(): number {\n    if (this.overrideLookAt === 'block') {\n      return 0.0 < this.outputWeight ? 1.0 : 0.0;\n    } else if (this.overrideLookAt === 'blend') {\n      return this.outputWeight;\n    } else {\n      return 0.0;\n    }\n  }\n\n  /**\n   * A value represents how much it should override mouth expressions.\n   * `0.0` == no override at all, `1.0` == completely block the expressions.\n   */\n  public get overrideMouthAmount(): number {\n    if (this.overrideMouth === 'block') {\n      return 0.0 < this.outputWeight ? 1.0 : 0.0;\n    } else if (this.overrideMouth === 'blend') {\n      return this.outputWeight;\n    } else {\n      return 0.0;\n    }\n  }\n\n  /**\n   * An output weight of this expression, considering the {@link isBinary}.\n   */\n  public get outputWeight(): number {\n    if (this.isBinary) {\n      return this.weight > 0.5 ? 1.0 : 0.0;\n    }\n\n    return this.weight;\n  }\n\n  constructor(expressionName: string) {\n    super();\n\n    this.name = `VRMExpression_${expressionName}`;\n    this.expressionName = expressionName;\n\n    // traverse \u6642\u306E\u6551\u6E08\u624B\u6BB5\u3068\u3057\u3066 Object3D \u3067\u306F\u306A\u3044\u3053\u3068\u3092\u660E\u793A\u3057\u3066\u304A\u304F\n    this.type = 'VRMExpression';\n\n    // \u8868\u793A\u76EE\u7684\u306E\u30AA\u30D6\u30B8\u30A7\u30AF\u30C8\u3067\u306F\u306A\u3044\u306E\u3067\u3001\u8CA0\u8377\u8EFD\u6E1B\u306E\u305F\u3081\u306B visible \u3092 false \u306B\u3057\u3066\u304A\u304F\u3002\n    // \u3053\u308C\u306B\u3088\u308A\u3001\u3053\u306E\u30A4\u30F3\u30B9\u30BF\u30F3\u30B9\u306B\u5BFE\u3059\u308B\u6BCE\u30D5\u30EC\u30FC\u30E0\u306E matrix \u81EA\u52D5\u8A08\u7B97\u3092\u7701\u7565\u3067\u304D\u308B\u3002\n    this.visible = false;\n  }\n\n  /**\n   * Add an expression bind to the expression.\n   *\n   * @param bind A bind to add\n   */\n  public addBind(bind: VRMExpressionBind): void {\n    this._binds.push(bind);\n  }\n\n  /**\n   * Delete an expression bind from the expression.\n   *\n   * @param bind A bind to delete\n   */\n  public deleteBind(bind: VRMExpressionBind): void {\n    const index = this._binds.indexOf(bind);\n    if (index >= 0) {\n      this._binds.splice(index, 1);\n    }\n  }\n\n  /**\n   * Apply weight to every assigned blend shapes.\n   * Should be called every frame.\n   */\n  public applyWeight(options?: {\n    /**\n     * Multiplies a value to its weight to apply.\n     * Intended to be used for overriding an expression weight by another expression.\n     * See also: {@link overrideBlink}, {@link overrideLookAt}, {@link overrideMouth}\n     */\n    multiplier?: number;\n  }): void {\n    let actualWeight = this.outputWeight;\n    actualWeight *= options?.multiplier ?? 1.0;\n\n    // if the expression is binary, the override value must be also treated as binary\n    if (this.isBinary && actualWeight < 1.0) {\n      actualWeight = 0.0;\n    }\n\n    this._binds.forEach((bind) => bind.applyWeight(actualWeight));\n  }\n\n  /**\n   * Clear previously assigned blend shapes.\n   */\n  public clearAppliedWeight(): void {\n    this._binds.forEach((bind) => bind.clearAppliedWeight());\n  }\n}\n", "import type * as V0VRM from '@pixiv/types-vrm-0.0';\nimport type * as V1VRMSchema from '@pixiv/types-vrmc-vrm-1.0';\nimport * as THREE from 'three';\nimport { GLTF, GLTFLoaderPlugin, GLTFParser } from 'three/examples/jsm/loaders/GLTFLoader.js';\nimport { gltfExtractPrimitivesFromNode } from '../utils/gltfExtractPrimitivesFromNode';\nimport { VRMExpression } from './VRMExpression';\nimport { VRMExpressionManager } from './VRMExpressionManager';\nimport { v0ExpressionMaterialColorMap } from './VRMExpressionMaterialColorType';\nimport { VRMExpressionMaterialColorBind } from './VRMExpressionMaterialColorBind';\nimport { VRMExpressionMorphTargetBind } from './VRMExpressionMorphTargetBind';\nimport { VRMExpressionPresetName } from './VRMExpressionPresetName';\nimport { VRMExpressionTextureTransformBind } from './VRMExpressionTextureTransformBind';\nimport { GLTF as GLTFSchema } from '@gltf-transform/core';\n\n/**\n * Possible spec versions it recognizes.\n */\nconst POSSIBLE_SPEC_VERSIONS = new Set(['1.0', '1.0-beta']);\n\n/**\n * A plugin of GLTFLoader that imports a {@link VRMExpressionManager} from a VRM extension of a GLTF.\n */\nexport class VRMExpressionLoaderPlugin implements GLTFLoaderPlugin {\n  public static readonly v0v1PresetNameMap: { [v0Name in V0VRM.BlendShapePresetName]?: VRMExpressionPresetName } = {\n    a: 'aa',\n    e: 'ee',\n    i: 'ih',\n    o: 'oh',\n    u: 'ou',\n    blink: 'blink',\n    joy: 'happy',\n    angry: 'angry',\n    sorrow: 'sad',\n    fun: 'relaxed',\n    lookup: 'lookUp',\n    lookdown: 'lookDown',\n    lookleft: 'lookLeft',\n    lookright: 'lookRight',\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    blink_l: 'blinkLeft',\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    blink_r: 'blinkRight',\n    neutral: 'neutral',\n  };\n\n  public readonly parser: GLTFParser;\n\n  public get name(): string {\n    // We should use the extension name instead but we have multiple plugins for an extension...\n    return 'VRMExpressionLoaderPlugin';\n  }\n\n  public constructor(parser: GLTFParser) {\n    this.parser = parser;\n  }\n\n  public async afterRoot(gltf: GLTF): Promise<void> {\n    gltf.userData.vrmExpressionManager = await this._import(gltf);\n  }\n\n  /**\n   * Import a {@link VRMExpressionManager} from a VRM.\n   *\n   * @param gltf A parsed result of GLTF taken from GLTFLoader\n   */\n  private async _import(gltf: GLTF): Promise<VRMExpressionManager | null> {\n    const v1Result = await this._v1Import(gltf);\n    if (v1Result) {\n      return v1Result;\n    }\n\n    const v0Result = await this._v0Import(gltf);\n    if (v0Result) {\n      return v0Result;\n    }\n\n    return null;\n  }\n\n  private async _v1Import(gltf: GLTF): Promise<VRMExpressionManager | null> {\n    const json = this.parser.json as GLTFSchema.IGLTF;\n\n    // early abort if it doesn't use vrm\n    const isVRMUsed = json.extensionsUsed?.indexOf('VRMC_vrm') !== -1;\n    if (!isVRMUsed) {\n      return null;\n    }\n\n    const extension = json.extensions?.['VRMC_vrm'] as V1VRMSchema.VRMCVRM | undefined;\n    if (!extension) {\n      return null;\n    }\n\n    const specVersion = extension.specVersion;\n    if (!POSSIBLE_SPEC_VERSIONS.has(specVersion)) {\n      console.warn(`VRMExpressionLoaderPlugin: Unknown VRMC_vrm specVersion \"${specVersion}\"`);\n      return null;\n    }\n\n    const schemaExpressions = extension.expressions;\n    if (!schemaExpressions) {\n      return null;\n    }\n\n    // list expressions\n    const presetNameSet = new Set<string>(Object.values(VRMExpressionPresetName));\n    const nameSchemaExpressionMap = new Map<string, V1VRMSchema.Expression>();\n\n    if (schemaExpressions.preset != null) {\n      Object.entries(schemaExpressions.preset).forEach(([name, schemaExpression]) => {\n        if (schemaExpression == null) {\n          return;\n        } // typescript\n\n        if (!presetNameSet.has(name)) {\n          console.warn(`VRMExpressionLoaderPlugin: Unknown preset name \"${name}\" detected. Ignoring the expression`);\n          return;\n        }\n\n        nameSchemaExpressionMap.set(name, schemaExpression);\n      });\n    }\n\n    if (schemaExpressions.custom != null) {\n      Object.entries(schemaExpressions.custom).forEach(([name, schemaExpression]) => {\n        if (presetNameSet.has(name)) {\n          console.warn(\n            `VRMExpressionLoaderPlugin: Custom expression cannot have preset name \"${name}\". Ignoring the expression`,\n          );\n          return;\n        }\n\n        nameSchemaExpressionMap.set(name, schemaExpression);\n      });\n    }\n\n    // prepare manager\n    const manager = new VRMExpressionManager();\n\n    // load expressions\n    await Promise.all(\n      Array.from(nameSchemaExpressionMap.entries()).map(async ([name, schemaExpression]) => {\n        const expression = new VRMExpression(name);\n        gltf.scene.add(expression);\n\n        expression.isBinary = schemaExpression.isBinary ?? false;\n        expression.overrideBlink = schemaExpression.overrideBlink ?? 'none';\n        expression.overrideLookAt = schemaExpression.overrideLookAt ?? 'none';\n        expression.overrideMouth = schemaExpression.overrideMouth ?? 'none';\n\n        schemaExpression.morphTargetBinds?.forEach(async (bind) => {\n          if (bind.node === undefined || bind.index === undefined) {\n            return;\n          }\n\n          const primitives = (await gltfExtractPrimitivesFromNode(gltf, bind.node))!;\n          const morphTargetIndex = bind.index;\n\n          // check if the mesh has the target morph target\n          if (\n            !primitives.every(\n              (primitive) =>\n                Array.isArray(primitive.morphTargetInfluences) &&\n                morphTargetIndex < primitive.morphTargetInfluences.length,\n            )\n          ) {\n            console.warn(\n              `VRMExpressionLoaderPlugin: ${schemaExpression.name} attempts to index morph #${morphTargetIndex} but not found.`,\n            );\n            return;\n          }\n\n          expression.addBind(\n            new VRMExpressionMorphTargetBind({\n              primitives,\n              index: morphTargetIndex,\n              weight: bind.weight ?? 1.0,\n            }),\n          );\n        });\n\n        if (schemaExpression.materialColorBinds || schemaExpression.textureTransformBinds) {\n          // list up every material in `gltf.scene`\n          const gltfMaterials: THREE.Material[] = [];\n          gltf.scene.traverse((object) => {\n            const material = (object as any).material as THREE.Material | THREE.Material[] | undefined;\n            if (material) {\n              if (Array.isArray(material)) {\n                gltfMaterials.push(...material);\n              } else {\n                gltfMaterials.push(material);\n              }\n            }\n          });\n\n          schemaExpression.materialColorBinds?.forEach(async (bind) => {\n            const materials = gltfMaterials.filter((material) => {\n              const materialIndex = this.parser.associations.get(material)?.materials;\n              return bind.material === materialIndex;\n            });\n\n            materials.forEach((material) => {\n              expression.addBind(\n                new VRMExpressionMaterialColorBind({\n                  material,\n                  type: bind.type,\n                  targetValue: new THREE.Color().fromArray(bind.targetValue),\n                  targetAlpha: bind.targetValue[3],\n                }),\n              );\n            });\n          });\n\n          schemaExpression.textureTransformBinds?.forEach(async (bind) => {\n            const materials = gltfMaterials.filter((material) => {\n              const materialIndex = this.parser.associations.get(material)?.materials;\n              return bind.material === materialIndex;\n            });\n\n            materials.forEach((material) => {\n              expression.addBind(\n                new VRMExpressionTextureTransformBind({\n                  material,\n                  offset: new THREE.Vector2().fromArray(bind.offset ?? [0.0, 0.0]),\n                  scale: new THREE.Vector2().fromArray(bind.scale ?? [1.0, 1.0]),\n                }),\n              );\n            });\n          });\n        }\n\n        manager.registerExpression(expression);\n      }),\n    );\n\n    return manager;\n  }\n\n  private async _v0Import(gltf: GLTF): Promise<VRMExpressionManager | null> {\n    const json = this.parser.json as GLTFSchema.IGLTF;\n\n    // early abort if it doesn't use vrm\n    const vrmExt = json.extensions?.VRM as V0VRM.VRM | undefined;\n    if (!vrmExt) {\n      return null;\n    }\n\n    const schemaBlendShape = vrmExt.blendShapeMaster;\n    if (!schemaBlendShape) {\n      return null;\n    }\n\n    const manager = new VRMExpressionManager();\n\n    const schemaBlendShapeGroups = schemaBlendShape.blendShapeGroups;\n    if (!schemaBlendShapeGroups) {\n      return manager;\n    }\n\n    const blendShapeNameSet = new Set<string>();\n\n    await Promise.all(\n      schemaBlendShapeGroups.map(async (schemaGroup) => {\n        const v0PresetName = schemaGroup.presetName;\n        const v1PresetName =\n          (v0PresetName != null && VRMExpressionLoaderPlugin.v0v1PresetNameMap[v0PresetName]) || null;\n        const name = v1PresetName ?? schemaGroup.name;\n\n        if (name == null) {\n          console.warn('VRMExpressionLoaderPlugin: One of custom expressions has no name. Ignoring the expression');\n          return;\n        }\n\n        // duplication check\n        if (blendShapeNameSet.has(name)) {\n          console.warn(\n            `VRMExpressionLoaderPlugin: An expression preset ${v0PresetName} has duplicated entries. Ignoring the expression`,\n          );\n          return;\n        }\n\n        blendShapeNameSet.add(name);\n\n        const expression = new VRMExpression(name);\n        gltf.scene.add(expression);\n\n        expression.isBinary = schemaGroup.isBinary ?? false;\n        // v0 doesn't have ignore properties\n\n        // Bind morphTarget\n        if (schemaGroup.binds) {\n          schemaGroup.binds.forEach(async (bind) => {\n            if (bind.mesh === undefined || bind.index === undefined) {\n              return;\n            }\n\n            const nodesUsingMesh: number[] = [];\n            json.nodes?.forEach((node, i) => {\n              if (node.mesh === bind.mesh) {\n                nodesUsingMesh.push(i);\n              }\n            });\n\n            const morphTargetIndex = bind.index;\n\n            await Promise.all(\n              nodesUsingMesh.map(async (nodeIndex) => {\n                const primitives = (await gltfExtractPrimitivesFromNode(gltf, nodeIndex))!;\n\n                // check if the mesh has the target morph target\n                if (\n                  !primitives.every(\n                    (primitive) =>\n                      Array.isArray(primitive.morphTargetInfluences) &&\n                      morphTargetIndex < primitive.morphTargetInfluences.length,\n                  )\n                ) {\n                  console.warn(\n                    `VRMExpressionLoaderPlugin: ${schemaGroup.name} attempts to index ${morphTargetIndex}th morph but not found.`,\n                  );\n                  return;\n                }\n\n                expression.addBind(\n                  new VRMExpressionMorphTargetBind({\n                    primitives,\n                    index: morphTargetIndex,\n                    weight: 0.01 * (bind.weight ?? 100), // narrowing the range from [ 0.0 - 100.0 ] to [ 0.0 - 1.0 ]\n                  }),\n                );\n              }),\n            );\n          });\n        }\n\n        // Bind MaterialColor and TextureTransform\n        const materialValues = schemaGroup.materialValues;\n        if (materialValues && materialValues.length !== 0) {\n          materialValues.forEach((materialValue) => {\n            if (\n              materialValue.materialName === undefined ||\n              materialValue.propertyName === undefined ||\n              materialValue.targetValue === undefined\n            ) {\n              return;\n            }\n\n            /**\n             * \u30A2\u30D0\u30BF\u30FC\u306E\u30AA\u30D6\u30B8\u30A7\u30AF\u30C8\u306B\u8A2D\u5B9A\u3055\u308C\u3066\u3044\u308B\u30DE\u30C6\u30EA\u30A2\u30EB\u306E\u5185\u304B\u3089\n             * materialValue\u3067\u6307\u5B9A\u3055\u308C\u3066\u3044\u308B\u30DE\u30C6\u30EA\u30A2\u30EB\u3092\u96C6\u3081\u308B\u3002\n             *\n             * \u7279\u5B9A\u306B\u306F\u540D\u524D\u3092\u4F7F\u7528\u3059\u308B\u3002\n             * \u30A2\u30A6\u30C8\u30E9\u30A4\u30F3\u63CF\u753B\u7528\u306E\u30DE\u30C6\u30EA\u30A2\u30EB\u3082\u540C\u6642\u306B\u96C6\u3081\u308B\u3002\n             */\n            const materials: THREE.Material[] = [];\n            gltf.scene.traverse((object) => {\n              if ((object as any).material) {\n                const material: THREE.Material[] | THREE.Material = (object as any).material;\n                if (Array.isArray(material)) {\n                  materials.push(\n                    ...material.filter(\n                      (mtl) =>\n                        (mtl.name === materialValue.materialName! ||\n                          mtl.name === materialValue.materialName! + ' (Outline)') &&\n                        materials.indexOf(mtl) === -1,\n                    ),\n                  );\n                } else if (material.name === materialValue.materialName && materials.indexOf(material) === -1) {\n                  materials.push(material);\n                }\n              }\n            });\n\n            const materialPropertyName = materialValue.propertyName;\n            materials.forEach((material) => {\n              // TextureTransformBind\n              if (materialPropertyName === '_MainTex_ST') {\n                const scale = new THREE.Vector2(materialValue.targetValue![0], materialValue.targetValue![1]);\n                const offset = new THREE.Vector2(materialValue.targetValue![2], materialValue.targetValue![3]);\n\n                offset.y = 1.0 - offset.y - scale.y;\n\n                expression.addBind(\n                  new VRMExpressionTextureTransformBind({\n                    material,\n                    scale,\n                    offset,\n                  }),\n                );\n\n                return;\n              }\n\n              // MaterialColorBind\n              const materialColorType = v0ExpressionMaterialColorMap[materialPropertyName];\n              if (materialColorType) {\n                expression.addBind(\n                  new VRMExpressionMaterialColorBind({\n                    material,\n                    type: materialColorType,\n                    targetValue: new THREE.Color().fromArray(materialValue.targetValue!),\n                    targetAlpha: materialValue.targetValue![3],\n                  }),\n                );\n\n                return;\n              }\n\n              console.warn(materialPropertyName + ' is not supported');\n            });\n          });\n        }\n\n        manager.registerExpression(expression);\n      }),\n    );\n\n    return manager;\n  }\n}\n", "import type * as THREE from 'three';\nimport type { GLTF } from 'three/examples/jsm/loaders/GLTFLoader.js';\nimport { GLTF as GLTFSchema } from '@gltf-transform/core';\n\nfunction extractPrimitivesInternal(gltf: GLTF, nodeIndex: number, node: THREE.Object3D): THREE.Mesh[] | null {\n  const json = gltf.parser.json as GLTFSchema.IGLTF;\n\n  /**\n   * Let's list up every possible patterns that parsed gltf nodes with a mesh can have,,,\n   *\n   * \"*\" indicates that those meshes should be listed up using this function\n   *\n   * ### A node with a (mesh, a signle primitive)\n   *\n   * - `THREE.Mesh`: The only primitive of the mesh *\n   *\n   * ### A node with a (mesh, multiple primitives)\n   *\n   * - `THREE.Group`: The root of the mesh\n   *   - `THREE.Mesh`: A primitive of the mesh *\n   *   - `THREE.Mesh`: A primitive of the mesh (2) *\n   *\n   * ### A node with a (mesh, multiple primitives) AND (a child with a mesh, a single primitive)\n   *\n   * - `THREE.Group`: The root of the mesh\n   *   - `THREE.Mesh`: A primitive of the mesh *\n   *   - `THREE.Mesh`: A primitive of the mesh (2) *\n   *   - `THREE.Mesh`: A primitive of a MESH OF THE CHILD\n   *\n   * ### A node with a (mesh, multiple primitives) AND (a child with a mesh, multiple primitives)\n   *\n   * - `THREE.Group`: The root of the mesh\n   *   - `THREE.Mesh`: A primitive of the mesh *\n   *   - `THREE.Mesh`: A primitive of the mesh (2) *\n   *   - `THREE.Group`: The root of a MESH OF THE CHILD\n   *     - `THREE.Mesh`: A primitive of the mesh of the child\n   *     - `THREE.Mesh`: A primitive of the mesh of the child (2)\n   *\n   * ### A node with a (mesh, multiple primitives) BUT the node is a bone\n   *\n   * - `THREE.Bone`: The root of the node, as a bone\n   *   - `THREE.Group`: The root of the mesh\n   *     - `THREE.Mesh`: A primitive of the mesh *\n   *     - `THREE.Mesh`: A primitive of the mesh (2) *\n   *\n   * ### A node with a (mesh, multiple primitives) AND (a child with a mesh, multiple primitives) BUT the node is a bone\n   *\n   * - `THREE.Bone`: The root of the node, as a bone\n   *   - `THREE.Group`: The root of the mesh\n   *     - `THREE.Mesh`: A primitive of the mesh *\n   *     - `THREE.Mesh`: A primitive of the mesh (2) *\n   *   - `THREE.Group`: The root of a MESH OF THE CHILD\n   *     - `THREE.Mesh`: A primitive of the mesh of the child\n   *     - `THREE.Mesh`: A primitive of the mesh of the child (2)\n   *\n   * ...I will take a strategy that traverses the root of the node and take first (primitiveCount) meshes.\n   */\n\n  // Make sure that the node has a mesh\n  const schemaNode = json.nodes?.[nodeIndex];\n  if (schemaNode == null) {\n    console.warn(`extractPrimitivesInternal: Attempt to use nodes[${nodeIndex}] of glTF but the node doesn't exist`);\n    return null;\n  }\n\n  const meshIndex = schemaNode.mesh;\n  if (meshIndex == null) {\n    return null;\n  }\n\n  // How many primitives the mesh has?\n  const schemaMesh = json.meshes?.[meshIndex];\n  if (schemaMesh == null) {\n    console.warn(`extractPrimitivesInternal: Attempt to use meshes[${meshIndex}] of glTF but the mesh doesn't exist`);\n    return null;\n  }\n\n  const primitiveCount = schemaMesh.primitives.length;\n\n  // Traverse the node and take first (primitiveCount) meshes\n  const primitives: THREE.Mesh[] = [];\n  node.traverse((object) => {\n    if (primitives.length < primitiveCount) {\n      if ((object as any).isMesh) {\n        primitives.push(object as THREE.Mesh);\n      }\n    }\n  });\n\n  return primitives;\n}\n\n/**\n * Extract primitives ( `THREE.Mesh[]` ) of a node from a loaded GLTF.\n * The main purpose of this function is to distinguish primitives and children from a node that has both meshes and children.\n *\n * It utilizes the behavior that GLTFLoader adds mesh primitives to the node object ( `THREE.Group` ) first then adds its children.\n *\n * @param gltf A GLTF object taken from GLTFLoader\n * @param nodeIndex The index of the node\n */\nexport async function gltfExtractPrimitivesFromNode(gltf: GLTF, nodeIndex: number): Promise<THREE.Mesh[] | null> {\n  const node: THREE.Object3D = await gltf.parser.getDependency('node', nodeIndex);\n  return extractPrimitivesInternal(gltf, nodeIndex, node);\n}\n\n/**\n * Extract primitives ( `THREE.Mesh[]` ) of nodes from a loaded GLTF.\n * See {@link gltfExtractPrimitivesFromNode} for more details.\n *\n * It returns a map from node index to extraction result.\n * If a node does not have a mesh, the entry for the node will not be put in the returning map.\n *\n * @param gltf A GLTF object taken from GLTFLoader\n */\nexport async function gltfExtractPrimitivesFromNodes(gltf: GLTF): Promise<Map<number, THREE.Mesh[]>> {\n  const nodes: THREE.Object3D[] = await gltf.parser.getDependencies('node');\n  const map = new Map<number, THREE.Mesh[]>();\n\n  nodes.forEach((node, index) => {\n    const result = extractPrimitivesInternal(gltf, index, node);\n    if (result != null) {\n      map.set(index, result);\n    }\n  });\n\n  return map;\n}\n", "/* eslint-disable @typescript-eslint/naming-convention */\n\nexport const VRMExpressionPresetName = {\n  Aa: 'aa',\n  Ih: 'ih',\n  Ou: 'ou',\n  Ee: 'ee',\n  Oh: 'oh',\n  Blink: 'blink',\n  Happy: 'happy',\n  Angry: 'angry',\n  Sad: 'sad',\n  Relaxed: 'relaxed',\n  LookUp: 'lookUp',\n  Surprised: 'surprised',\n  LookDown: 'lookDown',\n  LookLeft: 'lookLeft',\n  LookRight: 'lookRight',\n  BlinkLeft: 'blinkLeft',\n  BlinkRight: 'blinkRight',\n  Neutral: 'neutral',\n} as const;\n\nexport type VRMExpressionPresetName = (typeof VRMExpressionPresetName)[keyof typeof VRMExpressionPresetName];\n", "/**\n * Clamp the input value within [0.0 - 1.0].\n *\n * @param value The input value\n */\nexport function saturate(value: number): number {\n  return Math.max(Math.min(value, 1.0), 0.0);\n}\n", "import { VRMExpressionPresetName } from './VRMExpressionPresetName';\nimport { saturate } from '../utils/saturate';\nimport type { VRMExpression } from './VRMExpression';\n\nexport class VRMExpressionManager {\n  /**\n   * A set of name or preset name of expressions that will be overridden by {@link VRMExpression.overrideBlink}.\n   */\n  public blinkExpressionNames = ['blink', 'blinkLeft', 'blinkRight'];\n\n  /**\n   * A set of name or preset name of expressions that will be overridden by {@link VRMExpression.overrideLookAt}.\n   */\n  public lookAtExpressionNames = ['lookLeft', 'lookRight', 'lookUp', 'lookDown'];\n\n  /**\n   * A set of name or preset name of expressions that will be overridden by {@link VRMExpression.overrideMouth}.\n   */\n  public mouthExpressionNames = ['aa', 'ee', 'ih', 'oh', 'ou'];\n\n  /**\n   * A set of {@link VRMExpression}.\n   * When you want to register expressions, use {@link registerExpression}\n   */\n  private _expressions: VRMExpression[] = [];\n  public get expressions(): VRMExpression[] {\n    return this._expressions.concat();\n  }\n\n  /**\n   * A map from name to expression.\n   */\n  private _expressionMap: { [name: string]: VRMExpression } = {};\n  public get expressionMap(): { [name: string]: VRMExpression } {\n    return Object.assign({}, this._expressionMap);\n  }\n\n  /**\n   * A map from name to expression, but excluding custom expressions.\n   */\n  public get presetExpressionMap(): { [name in VRMExpressionPresetName]?: VRMExpression } {\n    const result: { [name in VRMExpressionPresetName]?: VRMExpression } = {};\n\n    const presetNameSet = new Set<string>(Object.values(VRMExpressionPresetName));\n\n    Object.entries(this._expressionMap).forEach(([name, expression]) => {\n      if (presetNameSet.has(name)) {\n        result[name as VRMExpressionPresetName] = expression;\n      }\n    });\n\n    return result;\n  }\n\n  /**\n   * A map from name to expression, but excluding preset expressions.\n   */\n  public get customExpressionMap(): { [name: string]: VRMExpression } {\n    const result: { [name: string]: VRMExpression } = {};\n\n    const presetNameSet = new Set<string>(Object.values(VRMExpressionPresetName));\n\n    Object.entries(this._expressionMap).forEach(([name, expression]) => {\n      if (!presetNameSet.has(name)) {\n        result[name] = expression;\n      }\n    });\n\n    return result;\n  }\n\n  /**\n   * Create a new {@link VRMExpressionManager}.\n   */\n  public constructor() {\n    // do nothing\n  }\n\n  /**\n   * Copy the given {@link VRMExpressionManager} into this one.\n   * @param source The {@link VRMExpressionManager} you want to copy\n   * @returns this\n   */\n  public copy(source: VRMExpressionManager): this {\n    // first unregister all the expression it has\n    const expressions = this._expressions.concat();\n    expressions.forEach((expression) => {\n      this.unregisterExpression(expression);\n    });\n\n    // then register all the expression of the source\n    source._expressions.forEach((expression) => {\n      this.registerExpression(expression);\n    });\n\n    // copy remaining members\n    this.blinkExpressionNames = source.blinkExpressionNames.concat();\n    this.lookAtExpressionNames = source.lookAtExpressionNames.concat();\n    this.mouthExpressionNames = source.mouthExpressionNames.concat();\n\n    return this;\n  }\n\n  /**\n   * Returns a clone of this {@link VRMExpressionManager}.\n   * @returns Copied {@link VRMExpressionManager}\n   */\n  public clone(): VRMExpressionManager {\n    return new VRMExpressionManager().copy(this);\n  }\n\n  /**\n   * Return a registered expression.\n   * If it cannot find an expression, it will return `null` instead.\n   *\n   * @param name Name or preset name of the expression\n   */\n  public getExpression(name: VRMExpressionPresetName | string): VRMExpression | null {\n    return this._expressionMap[name] ?? null;\n  }\n\n  /**\n   * Register an expression.\n   *\n   * @param expression {@link VRMExpression} that describes the expression\n   */\n  public registerExpression(expression: VRMExpression): void {\n    this._expressions.push(expression);\n    this._expressionMap[expression.expressionName] = expression;\n  }\n\n  /**\n   * Unregister an expression.\n   *\n   * @param expression The expression you want to unregister\n   */\n  public unregisterExpression(expression: VRMExpression): void {\n    const index = this._expressions.indexOf(expression);\n    if (index === -1) {\n      console.warn('VRMExpressionManager: The specified expressions is not registered');\n    }\n\n    this._expressions.splice(index, 1);\n    delete this._expressionMap[expression.expressionName];\n  }\n\n  /**\n   * Get the current weight of the specified expression.\n   * If it doesn't have an expression of given name, it will return `null` instead.\n   *\n   * @param name Name of the expression\n   */\n  public getValue(name: VRMExpressionPresetName | string): number | null {\n    const expression = this.getExpression(name);\n    return expression?.weight ?? null;\n  }\n\n  /**\n   * Set a weight to the specified expression.\n   *\n   * @param name Name of the expression\n   * @param weight Weight\n   */\n  public setValue(name: VRMExpressionPresetName | string, weight: number): void {\n    const expression = this.getExpression(name);\n    if (expression) {\n      expression.weight = saturate(weight);\n    }\n  }\n\n  /**\n   * Reset weights of all expressions to `0.0`.\n   */\n  public resetValues(): void {\n    this._expressions.forEach((expression) => {\n      expression.weight = 0.0;\n    });\n  }\n\n  /**\n   * Get a track name of specified expression.\n   * This track name is needed to manipulate its expression via keyframe animations.\n   *\n   * @example Manipulate an expression using keyframe animation\n   * ```js\n   * const trackName = vrm.expressionManager.getExpressionTrackName( 'blink' );\n   * const track = new THREE.NumberKeyframeTrack(\n   *   name,\n   *   [ 0.0, 0.5, 1.0 ], // times\n   *   [ 0.0, 1.0, 0.0 ] // values\n   * );\n   *\n   * const clip = new THREE.AnimationClip(\n   *   'blink', // name\n   *   1.0, // duration\n   *   [ track ] // tracks\n   * );\n   *\n   * const mixer = new THREE.AnimationMixer( vrm.scene );\n   * const action = mixer.clipAction( clip );\n   * action.play();\n   * ```\n   *\n   * @param name Name of the expression\n   */\n  public getExpressionTrackName(name: VRMExpressionPresetName | string): string | null {\n    const expression = this.getExpression(name);\n    return expression ? `${expression.name}.weight` : null;\n  }\n\n  /**\n   * Update every expressions.\n   */\n  public update(): void {\n    // see how much we should override certain expressions\n    const weightMultipliers = this._calculateWeightMultipliers();\n\n    // reset expression binds first\n    this._expressions.forEach((expression) => {\n      expression.clearAppliedWeight();\n    });\n\n    // then apply binds\n    this._expressions.forEach((expression) => {\n      let multiplier = 1.0;\n      const name = expression.expressionName;\n\n      if (this.blinkExpressionNames.indexOf(name) !== -1) {\n        multiplier *= weightMultipliers.blink;\n      }\n\n      if (this.lookAtExpressionNames.indexOf(name) !== -1) {\n        multiplier *= weightMultipliers.lookAt;\n      }\n\n      if (this.mouthExpressionNames.indexOf(name) !== -1) {\n        multiplier *= weightMultipliers.mouth;\n      }\n\n      expression.applyWeight({ multiplier });\n    });\n  }\n\n  /**\n   * Calculate sum of override amounts to see how much we should multiply weights of certain expressions.\n   */\n  private _calculateWeightMultipliers(): {\n    blink: number;\n    lookAt: number;\n    mouth: number;\n  } {\n    let blink = 1.0;\n    let lookAt = 1.0;\n    let mouth = 1.0;\n\n    this._expressions.forEach((expression) => {\n      blink -= expression.overrideBlinkAmount;\n      lookAt -= expression.overrideLookAtAmount;\n      mouth -= expression.overrideMouthAmount;\n    });\n\n    blink = Math.max(0.0, blink);\n    lookAt = Math.max(0.0, lookAt);\n    mouth = Math.max(0.0, mouth);\n\n    return { blink, lookAt, mouth };\n  }\n}\n", "/* eslint-disable @typescript-eslint/naming-convention */\n\nexport const VRMExpressionMaterialColorType = {\n  Color: 'color',\n  EmissionColor: 'emissionColor',\n  ShadeColor: 'shadeColor',\n  MatcapColor: 'matcapColor',\n  RimColor: 'rimColor',\n  OutlineColor: 'outlineColor',\n} as const;\n\nexport type VRMExpressionMaterialColorType =\n  (typeof VRMExpressionMaterialColorType)[keyof typeof VRMExpressionMaterialColorType];\n\nexport const v0ExpressionMaterialColorMap: { [key: string]: VRMExpressionMaterialColorType | undefined } = {\n  _Color: VRMExpressionMaterialColorType.Color,\n  _EmissionColor: VRMExpressionMaterialColorType.EmissionColor,\n  _ShadeColor: VRMExpressionMaterialColorType.ShadeColor,\n  _RimColor: VRMExpressionMaterialColorType.RimColor,\n  _OutlineColor: VRMExpressionMaterialColorType.OutlineColor,\n};\n", "import * as THREE from 'three';\nimport type { VRMExpressionBind } from './VRMExpressionBind';\nimport type { VRMExpressionMaterialColorType } from './VRMExpressionMaterialColorType';\n\nconst _color = new THREE.Color();\n\ninterface ColorBindState {\n  propertyName: string;\n  initialValue: THREE.Color;\n  deltaValue: THREE.Color;\n}\n\ninterface AlphaBindState {\n  propertyName: string;\n  initialValue: number;\n  deltaValue: number;\n}\n\ninterface BindState {\n  color: ColorBindState | null;\n  alpha: AlphaBindState | null;\n}\n\n/**\n * A bind of expression influences to a material color.\n */\nexport class VRMExpressionMaterialColorBind implements VRMExpressionBind {\n  /**\n   * Mapping of property names from VRMC/materialColorBinds.type to three.js/Material.\n   * The first element stands for color channels, the second element stands for the alpha channel.\n   * The second element can be null if the target property doesn't exist.\n   */\n  // TODO: We might want to use the `satisfies` operator once we bump TS to 4.9 or higher\n  // See: https://github.com/pixiv/three-vrm/pull/1323#discussion_r1374020035\n  private static _propertyNameMapMap: {\n    [distinguisher: string]: { [type in VRMExpressionMaterialColorType]?: readonly [string, string | null] };\n  } = {\n    isMeshStandardMaterial: {\n      color: ['color', 'opacity'],\n      emissionColor: ['emissive', null],\n    },\n    isMeshBasicMaterial: {\n      color: ['color', 'opacity'],\n    },\n    isMToonMaterial: {\n      color: ['color', 'opacity'],\n      emissionColor: ['emissive', null],\n      outlineColor: ['outlineColorFactor', null],\n      matcapColor: ['matcapFactor', null],\n      rimColor: ['parametricRimColorFactor', null],\n      shadeColor: ['shadeColorFactor', null],\n    },\n  };\n\n  /**\n   * The target material.\n   */\n  public readonly material: THREE.Material;\n\n  /**\n   * The type of the target property of the material.\n   */\n  public readonly type: VRMExpressionMaterialColorType;\n\n  /**\n   * The target color.\n   */\n  public readonly targetValue: THREE.Color;\n\n  /**\n   * The target alpha.\n   */\n  public readonly targetAlpha: number;\n\n  /**\n   * Its binding state.\n   * If it cannot find the target property in the constructor, each property will be null instead.\n   */\n  private _state: BindState;\n\n  public constructor({\n    material,\n    type,\n    targetValue,\n    targetAlpha,\n  }: {\n    /**\n     * The target material.\n     */\n    material: THREE.Material;\n\n    /**\n     * The type of the target property of the material.\n     */\n    type: VRMExpressionMaterialColorType;\n\n    /**\n     * The target color.\n     */\n    targetValue: THREE.Color;\n\n    /**\n     * The target alpha.\n     */\n    targetAlpha?: number;\n  }) {\n    this.material = material;\n    this.type = type;\n    this.targetValue = targetValue;\n    this.targetAlpha = targetAlpha ?? 1.0;\n\n    // init bind state\n    const color = this._initColorBindState();\n    const alpha = this._initAlphaBindState();\n    this._state = { color, alpha };\n  }\n\n  public applyWeight(weight: number): void {\n    const { color, alpha } = this._state;\n\n    if (color != null) {\n      const { propertyName, deltaValue } = color;\n\n      const target = (this.material as any)[propertyName] as THREE.Color;\n      if (target != undefined) {\n        target.add(_color.copy(deltaValue).multiplyScalar(weight));\n      }\n    }\n\n    if (alpha != null) {\n      const { propertyName, deltaValue } = alpha;\n\n      const target = (this.material as any)[propertyName] as number;\n      if (target != undefined) {\n        ((this.material as any)[propertyName] as number) += deltaValue * weight;\n      }\n    }\n  }\n\n  public clearAppliedWeight(): void {\n    const { color, alpha } = this._state;\n\n    if (color != null) {\n      const { propertyName, initialValue } = color;\n\n      const target = (this.material as any)[propertyName] as THREE.Color;\n      if (target != undefined) {\n        target.copy(initialValue);\n      }\n    }\n\n    if (alpha != null) {\n      const { propertyName, initialValue } = alpha;\n\n      const target = (this.material as any)[propertyName] as number;\n      if (target != undefined) {\n        ((this.material as any)[propertyName] as number) = initialValue;\n      }\n    }\n  }\n\n  private _initColorBindState(): ColorBindState | null {\n    const { material, type, targetValue } = this;\n\n    const propertyNameMap = this._getPropertyNameMap();\n    const propertyName = propertyNameMap?.[type]?.[0] ?? null;\n\n    if (propertyName == null) {\n      console.warn(\n        `Tried to add a material color bind to the material ${\n          material.name ?? '(no name)'\n        }, the type ${type} but the material or the type is not supported.`,\n      );\n\n      return null;\n    }\n\n    const target = (material as any)[propertyName] as THREE.Color;\n\n    const initialValue = target.clone();\n\n    // \u8CA0\u306E\u5024\u3092\u4FDD\u6301\u3059\u308B\u305F\u3081\u306BColor.sub\u3092\u4F7F\u308F\u305A\u306B\u5DEE\u5206\u3092\u8A08\u7B97\u3059\u308B\n    const deltaValue = new THREE.Color(\n      targetValue.r - initialValue.r,\n      targetValue.g - initialValue.g,\n      targetValue.b - initialValue.b,\n    );\n\n    return { propertyName, initialValue, deltaValue };\n  }\n\n  private _initAlphaBindState(): AlphaBindState | null {\n    const { material, type, targetAlpha } = this;\n\n    const propertyNameMap = this._getPropertyNameMap();\n    const propertyName = propertyNameMap?.[type]?.[1] ?? null;\n\n    if (propertyName == null && targetAlpha !== 1.0) {\n      console.warn(\n        `Tried to add a material alpha bind to the material ${\n          material.name ?? '(no name)'\n        }, the type ${type} but the material or the type does not support alpha.`,\n      );\n\n      return null;\n    }\n\n    if (propertyName == null) {\n      return null;\n    }\n\n    const initialValue = (material as any)[propertyName] as number;\n\n    const deltaValue = targetAlpha - initialValue;\n\n    return { propertyName, initialValue, deltaValue };\n  }\n\n  private _getPropertyNameMap():\n    | { [type in VRMExpressionMaterialColorType]?: readonly [string, string | null] }\n    | null {\n    return (\n      Object.entries(VRMExpressionMaterialColorBind._propertyNameMapMap).find(([distinguisher]) => {\n        return (this.material as any)[distinguisher] === true;\n      })?.[1] ?? null\n    );\n  }\n}\n", "import type * as THREE from 'three';\nimport type { VRMExpressionBind } from './VRMExpressionBind';\n\n/**\n * A bind of {@link VRMExpression} influences to morph targets.\n */\nexport class VRMExpressionMorphTargetBind implements VRMExpressionBind {\n  /**\n   * The mesh primitives that attached to target mesh.\n   */\n  public readonly primitives: THREE.Mesh[];\n\n  /**\n   * The index of the morph target in the mesh.\n   */\n  public readonly index: number;\n\n  /**\n   * The weight value of target morph target. Ranging in [0.0 - 1.0].\n   */\n  public readonly weight: number;\n\n  public constructor({\n    primitives,\n    index,\n    weight,\n  }: {\n    /**\n     * The mesh primitives that attached to target mesh.\n     */\n    primitives: THREE.Mesh[];\n\n    /**\n     * The index of the morph target in the mesh.\n     */\n    index: number;\n\n    /**\n     * The weight value of target morph target. Ranging in [0.0 - 1.0].\n     */\n    weight: number;\n  }) {\n    this.primitives = primitives;\n    this.index = index;\n    this.weight = weight;\n  }\n\n  public applyWeight(weight: number): void {\n    this.primitives.forEach((mesh) => {\n      if (mesh.morphTargetInfluences?.[this.index] != null) {\n        mesh.morphTargetInfluences[this.index] += this.weight * weight;\n      }\n    });\n  }\n\n  public clearAppliedWeight(): void {\n    this.primitives.forEach((mesh) => {\n      if (mesh.morphTargetInfluences?.[this.index] != null) {\n        mesh.morphTargetInfluences[this.index] = 0.0;\n      }\n    });\n  }\n}\n", "import * as THREE from 'three';\nimport type { VRMExpressionBind } from './VRMExpressionBind';\n\nconst _v2 = new THREE.Vector2();\n\n/**\n * A bind of expression influences to texture transforms.\n */\nexport class VRMExpressionTextureTransformBind implements VRMExpressionBind {\n  private static _propertyNamesMap: { [distinguisher: string]: string[] } = {\n    isMeshStandardMaterial: [\n      'map',\n      'emissiveMap',\n      'bumpMap',\n      'normalMap',\n      'displacementMap',\n      'roughnessMap',\n      'metalnessMap',\n      'alphaMap',\n    ],\n    isMeshBasicMaterial: ['map', 'specularMap', 'alphaMap'],\n    isMToonMaterial: [\n      'map',\n      'normalMap',\n      'emissiveMap',\n      'shadeMultiplyTexture',\n      'rimMultiplyTexture',\n      'outlineWidthMultiplyTexture',\n      'uvAnimationMaskTexture',\n    ],\n  };\n\n  /**\n   * The target material.\n   */\n  public readonly material: THREE.Material;\n\n  /**\n   * The uv scale of the texture.\n   */\n  public readonly scale: THREE.Vector2;\n\n  /**\n   * The uv offset of the texture.\n   */\n  public readonly offset: THREE.Vector2;\n\n  /**\n   * The list of texture names and its state that should be transformed by this bind.\n   */\n  private _properties: {\n    name: string;\n    initialOffset: THREE.Vector2;\n    initialScale: THREE.Vector2;\n    deltaOffset: THREE.Vector2;\n    deltaScale: THREE.Vector2;\n  }[];\n\n  public constructor({\n    material,\n    scale,\n    offset,\n  }: {\n    /**\n     * The target material.\n     */\n    material: THREE.Material;\n\n    /**\n     * The uv scale of the texture.\n     */\n    scale: THREE.Vector2;\n\n    /**\n     * The uv offset of the texture.\n     */\n    offset: THREE.Vector2;\n  }) {\n    this.material = material;\n    this.scale = scale;\n    this.offset = offset;\n\n    const propertyNames = Object.entries(VRMExpressionTextureTransformBind._propertyNamesMap).find(\n      ([distinguisher]) => {\n        return (material as any)[distinguisher] === true;\n      },\n    )?.[1];\n\n    if (propertyNames == null) {\n      console.warn(\n        `Tried to add a texture transform bind to the material ${\n          material.name ?? '(no name)'\n        } but the material is not supported.`,\n      );\n\n      this._properties = [];\n    } else {\n      this._properties = [];\n\n      propertyNames.forEach((propertyName) => {\n        const texture = ((material as any)[propertyName] as THREE.Texture | undefined)?.clone();\n        if (!texture) {\n          return null;\n        }\n\n        (material as any)[propertyName] = texture; // because the texture is cloned\n\n        const initialOffset = texture.offset.clone();\n        const initialScale = texture.repeat.clone();\n        const deltaOffset = offset.clone().sub(initialOffset);\n        const deltaScale = scale.clone().sub(initialScale);\n\n        this._properties.push({\n          name: propertyName,\n          initialOffset,\n          deltaOffset,\n          initialScale,\n          deltaScale,\n        });\n      });\n    }\n  }\n\n  public applyWeight(weight: number): void {\n    this._properties.forEach((property) => {\n      const target = (this.material as any)[property.name] as THREE.Texture;\n      if (target === undefined) {\n        return;\n      } // TODO: we should kick this at `addMaterialValue`\n\n      target.offset.add(_v2.copy(property.deltaOffset).multiplyScalar(weight));\n      target.repeat.add(_v2.copy(property.deltaScale).multiplyScalar(weight));\n    });\n  }\n\n  public clearAppliedWeight(): void {\n    this._properties.forEach((property) => {\n      const target = (this.material as any)[property.name] as THREE.Texture;\n      if (target === undefined) {\n        return;\n      } // TODO: we should kick this at `addMaterialValue`\n\n      target.offset.copy(property.initialOffset);\n      target.repeat.copy(property.initialScale);\n    });\n  }\n}\n", "/* eslint-disable @typescript-eslint/naming-convention */\n\nexport const VRMExpressionOverrideType = {\n  None: 'none',\n  Block: 'block',\n  Blend: 'blend',\n} as const;\n\nexport type VRMExpressionOverrideType = (typeof VRMExpressionOverrideType)[keyof typeof VRMExpressionOverrideType];\n", "import type { VRMFirstPersonMeshAnnotation } from './VRMFirstPersonMeshAnnotation';\nimport * as THREE from 'three';\nimport type { VRMHumanoid } from '../humanoid';\n\nexport class VRMFirstPerson {\n  /**\n   * A default camera layer for `FirstPersonOnly` layer.\n   *\n   * @see {@link firstPersonOnlyLayer}\n   */\n  public static readonly DEFAULT_FIRSTPERSON_ONLY_LAYER = 9;\n\n  /**\n   * A default camera layer for `ThirdPersonOnly` layer.\n   *\n   * @see {@link thirdPersonOnlyLayer}\n   */\n  public static readonly DEFAULT_THIRDPERSON_ONLY_LAYER = 10;\n\n  /**\n   * Its associated {@link VRMHumanoid}.\n   */\n  public readonly humanoid: VRMHumanoid;\n  public meshAnnotations: VRMFirstPersonMeshAnnotation[];\n\n  private _firstPersonOnlyLayer = VRMFirstPerson.DEFAULT_FIRSTPERSON_ONLY_LAYER;\n  private _thirdPersonOnlyLayer = VRMFirstPerson.DEFAULT_THIRDPERSON_ONLY_LAYER;\n\n  private _initializedLayers = false;\n\n  /**\n   * Create a new VRMFirstPerson object.\n   *\n   * @param humanoid A {@link VRMHumanoid}\n   * @param meshAnnotations A {@link VRMFirstPersonMeshAnnotation}\n   */\n  public constructor(humanoid: VRMHumanoid, meshAnnotations: VRMFirstPersonMeshAnnotation[]) {\n    this.humanoid = humanoid;\n    this.meshAnnotations = meshAnnotations;\n  }\n\n  /**\n   * Copy the given {@link VRMFirstPerson} into this one.\n   * {@link humanoid} must be same as the source one.\n   * @param source The {@link VRMFirstPerson} you want to copy\n   * @returns this\n   */\n  public copy(source: VRMFirstPerson): this {\n    if (this.humanoid !== source.humanoid) {\n      throw new Error('VRMFirstPerson: humanoid must be same in order to copy');\n    }\n\n    this.meshAnnotations = source.meshAnnotations.map((annotation) => ({\n      meshes: annotation.meshes.concat(),\n      type: annotation.type,\n    }));\n\n    return this;\n  }\n\n  /**\n   * Returns a clone of this {@link VRMFirstPerson}.\n   * @returns Copied {@link VRMFirstPerson}\n   */\n  public clone(): VRMFirstPerson {\n    return new VRMFirstPerson(this.humanoid, this.meshAnnotations).copy(this);\n  }\n\n  /**\n   * A camera layer represents `FirstPersonOnly` layer.\n   * Note that **you must call {@link setup} first before you use the layer feature** or it does not work properly.\n   *\n   * The value is {@link DEFAULT_FIRSTPERSON_ONLY_LAYER} by default but you can change the layer by specifying via {@link setup} if you prefer.\n   *\n   * @see https://vrm.dev/en/univrm/api/univrm_use_firstperson/\n   * @see https://threejs.org/docs/#api/en/core/Layers\n   */\n  public get firstPersonOnlyLayer(): number {\n    return this._firstPersonOnlyLayer;\n  }\n\n  /**\n   * A camera layer represents `ThirdPersonOnly` layer.\n   * Note that **you must call {@link setup} first before you use the layer feature** or it does not work properly.\n   *\n   * The value is {@link DEFAULT_THIRDPERSON_ONLY_LAYER} by default but you can change the layer by specifying via {@link setup} if you prefer.\n   *\n   * @see https://vrm.dev/en/univrm/api/univrm_use_firstperson/\n   * @see https://threejs.org/docs/#api/en/core/Layers\n   */\n  public get thirdPersonOnlyLayer(): number {\n    return this._thirdPersonOnlyLayer;\n  }\n\n  /**\n   * In this method, it assigns layers for every meshes based on mesh annotations.\n   * You must call this method first before you use the layer feature.\n   *\n   * This is an equivalent of [VRMFirstPerson.Setup](https://github.com/vrm-c/UniVRM/blob/73a5bd8fcddaa2a7a8735099a97e63c9db3e5ea0/Assets/VRM/Runtime/FirstPerson/VRMFirstPerson.cs#L295-L299) of the UniVRM.\n   *\n   * The `cameraLayer` parameter specifies which layer will be assigned for `FirstPersonOnly` / `ThirdPersonOnly`.\n   * In UniVRM, we specified those by naming each desired layer as `FIRSTPERSON_ONLY_LAYER` / `THIRDPERSON_ONLY_LAYER`\n   * but we are going to specify these layers at here since we are unable to name layers in Three.js.\n   *\n   * @param cameraLayer Specify which layer will be for `FirstPersonOnly` / `ThirdPersonOnly`.\n   */\n  public setup({\n    firstPersonOnlyLayer = VRMFirstPerson.DEFAULT_FIRSTPERSON_ONLY_LAYER,\n    thirdPersonOnlyLayer = VRMFirstPerson.DEFAULT_THIRDPERSON_ONLY_LAYER,\n  } = {}): void {\n    if (this._initializedLayers) {\n      return;\n    }\n    this._firstPersonOnlyLayer = firstPersonOnlyLayer;\n    this._thirdPersonOnlyLayer = thirdPersonOnlyLayer;\n\n    this.meshAnnotations.forEach((item) => {\n      item.meshes.forEach((mesh) => {\n        if (item.type === 'firstPersonOnly') {\n          mesh.layers.set(this._firstPersonOnlyLayer);\n          mesh.traverse((child) => child.layers.set(this._firstPersonOnlyLayer));\n        } else if (item.type === 'thirdPersonOnly') {\n          mesh.layers.set(this._thirdPersonOnlyLayer);\n          mesh.traverse((child) => child.layers.set(this._thirdPersonOnlyLayer));\n        } else if (item.type === 'auto') {\n          this._createHeadlessModel(mesh);\n        }\n      });\n    });\n\n    this._initializedLayers = true;\n  }\n\n  private _excludeTriangles(triangles: number[], bws: number[][], skinIndex: number[][], exclude: number[]): number {\n    let count = 0;\n    if (bws != null && bws.length > 0) {\n      for (let i = 0; i < triangles.length; i += 3) {\n        const a = triangles[i];\n        const b = triangles[i + 1];\n        const c = triangles[i + 2];\n        const bw0 = bws[a];\n        const skin0 = skinIndex[a];\n\n        if (bw0[0] > 0 && exclude.includes(skin0[0])) continue;\n        if (bw0[1] > 0 && exclude.includes(skin0[1])) continue;\n        if (bw0[2] > 0 && exclude.includes(skin0[2])) continue;\n        if (bw0[3] > 0 && exclude.includes(skin0[3])) continue;\n\n        const bw1 = bws[b];\n        const skin1 = skinIndex[b];\n        if (bw1[0] > 0 && exclude.includes(skin1[0])) continue;\n        if (bw1[1] > 0 && exclude.includes(skin1[1])) continue;\n        if (bw1[2] > 0 && exclude.includes(skin1[2])) continue;\n        if (bw1[3] > 0 && exclude.includes(skin1[3])) continue;\n\n        const bw2 = bws[c];\n        const skin2 = skinIndex[c];\n        if (bw2[0] > 0 && exclude.includes(skin2[0])) continue;\n        if (bw2[1] > 0 && exclude.includes(skin2[1])) continue;\n        if (bw2[2] > 0 && exclude.includes(skin2[2])) continue;\n        if (bw2[3] > 0 && exclude.includes(skin2[3])) continue;\n\n        triangles[count++] = a;\n        triangles[count++] = b;\n        triangles[count++] = c;\n      }\n    }\n    return count;\n  }\n\n  private _createErasedMesh(src: THREE.SkinnedMesh, erasingBonesIndex: number[]): THREE.SkinnedMesh {\n    const dst = new THREE.SkinnedMesh(src.geometry.clone(), src.material);\n    dst.name = `${src.name}(erase)`;\n    dst.frustumCulled = src.frustumCulled;\n    dst.layers.set(this._firstPersonOnlyLayer);\n\n    const geometry = dst.geometry;\n\n    const skinIndexAttr = geometry.getAttribute('skinIndex');\n    const skinIndexAttrArray = skinIndexAttr instanceof THREE.GLBufferAttribute ? [] : skinIndexAttr.array;\n    const skinIndex = [];\n    for (let i = 0; i < skinIndexAttrArray.length; i += 4) {\n      skinIndex.push([\n        skinIndexAttrArray[i],\n        skinIndexAttrArray[i + 1],\n        skinIndexAttrArray[i + 2],\n        skinIndexAttrArray[i + 3],\n      ]);\n    }\n\n    const skinWeightAttr = geometry.getAttribute('skinWeight');\n    const skinWeightAttrArray = skinWeightAttr instanceof THREE.GLBufferAttribute ? [] : skinWeightAttr.array;\n    const skinWeight = [];\n    for (let i = 0; i < skinWeightAttrArray.length; i += 4) {\n      skinWeight.push([\n        skinWeightAttrArray[i],\n        skinWeightAttrArray[i + 1],\n        skinWeightAttrArray[i + 2],\n        skinWeightAttrArray[i + 3],\n      ]);\n    }\n\n    const index = geometry.getIndex();\n    if (!index) {\n      throw new Error(\"The geometry doesn't have an index buffer\");\n    }\n    const oldTriangles = Array.from(index.array);\n\n    const count = this._excludeTriangles(oldTriangles, skinWeight, skinIndex, erasingBonesIndex);\n    const newTriangle: number[] = [];\n    for (let i = 0; i < count; i++) {\n      newTriangle[i] = oldTriangles[i];\n    }\n    geometry.setIndex(newTriangle);\n\n    // mtoon material includes onBeforeRender. this is unsupported at SkinnedMesh#clone\n    if (src.onBeforeRender) {\n      dst.onBeforeRender = src.onBeforeRender;\n    }\n    dst.bind(new THREE.Skeleton(src.skeleton.bones, src.skeleton.boneInverses), new THREE.Matrix4());\n    return dst;\n  }\n\n  private _createHeadlessModelForSkinnedMesh(parent: THREE.Object3D, mesh: THREE.SkinnedMesh): void {\n    const eraseBoneIndexes: number[] = [];\n    mesh.skeleton.bones.forEach((bone, index) => {\n      if (this._isEraseTarget(bone)) eraseBoneIndexes.push(index);\n    });\n\n    // Unlike UniVRM we don't copy mesh if no invisible bone was found\n    if (!eraseBoneIndexes.length) {\n      mesh.layers.enable(this._thirdPersonOnlyLayer);\n      mesh.layers.enable(this._firstPersonOnlyLayer);\n      return;\n    }\n    mesh.layers.set(this._thirdPersonOnlyLayer);\n    const newMesh = this._createErasedMesh(mesh, eraseBoneIndexes);\n    parent.add(newMesh);\n  }\n\n  private _createHeadlessModel(node: THREE.Object3D): void {\n    if (node.type === 'Group') {\n      node.layers.set(this._thirdPersonOnlyLayer);\n      if (this._isEraseTarget(node)) {\n        node.traverse((child) => child.layers.set(this._thirdPersonOnlyLayer));\n      } else {\n        const parent = new THREE.Group();\n        parent.name = `_headless_${node.name}`;\n        parent.layers.set(this._firstPersonOnlyLayer);\n        node.parent!.add(parent);\n        node.children\n          .filter((child) => child.type === 'SkinnedMesh')\n          .forEach((child) => {\n            const skinnedMesh = child as THREE.SkinnedMesh;\n            this._createHeadlessModelForSkinnedMesh(parent, skinnedMesh);\n          });\n      }\n    } else if (node.type === 'SkinnedMesh') {\n      const skinnedMesh = node as THREE.SkinnedMesh;\n      this._createHeadlessModelForSkinnedMesh(node.parent!, skinnedMesh);\n    } else {\n      if (this._isEraseTarget(node)) {\n        node.layers.set(this._thirdPersonOnlyLayer);\n        node.traverse((child) => child.layers.set(this._thirdPersonOnlyLayer));\n      }\n    }\n  }\n\n  private _isEraseTarget(bone: THREE.Object3D): boolean {\n    if (bone === this.humanoid.getRawBoneNode('head')) {\n      return true;\n    } else if (!bone.parent) {\n      return false;\n    } else {\n      return this._isEraseTarget(bone.parent);\n    }\n  }\n}\n", "import type * as V0VRM from '@pixiv/types-vrm-0.0';\nimport type * as V1VRMSchema from '@pixiv/types-vrmc-vrm-1.0';\nimport type { GLTF, GLTFLoaderPlugin, GLTFParser } from 'three/examples/jsm/loaders/GLTFLoader.js';\nimport type { VRMHumanoid } from '../humanoid/VRMHumanoid';\nimport { gltfExtractPrimitivesFromNodes } from '../utils/gltfExtractPrimitivesFromNode';\nimport { VRMFirstPerson } from './VRMFirstPerson';\nimport type { VRMFirstPersonMeshAnnotation } from './VRMFirstPersonMeshAnnotation';\nimport type { VRMFirstPersonMeshAnnotationType } from './VRMFirstPersonMeshAnnotationType';\nimport { GLTF as GLTFSchema } from '@gltf-transform/core';\n\n/**\n * Possible spec versions it recognizes.\n */\nconst POSSIBLE_SPEC_VERSIONS = new Set(['1.0', '1.0-beta']);\n\n/**\n * A plugin of GLTFLoader that imports a {@link VRMFirstPerson} from a VRM extension of a GLTF.\n */\nexport class VRMFirstPersonLoaderPlugin implements GLTFLoaderPlugin {\n  public readonly parser: GLTFParser;\n\n  public get name(): string {\n    // We should use the extension name instead but we have multiple plugins for an extension...\n    return 'VRMFirstPersonLoaderPlugin';\n  }\n\n  public constructor(parser: GLTFParser) {\n    this.parser = parser;\n  }\n\n  public async afterRoot(gltf: GLTF): Promise<void> {\n    const vrmHumanoid = gltf.userData.vrmHumanoid as VRMHumanoid | undefined;\n\n    // explicitly distinguish null and undefined\n    // since vrmHumanoid might be null as a result\n    if (vrmHumanoid === null) {\n      return;\n    } else if (vrmHumanoid === undefined) {\n      throw new Error(\n        'VRMFirstPersonLoaderPlugin: vrmHumanoid is undefined. VRMHumanoidLoaderPlugin have to be used first',\n      );\n    }\n\n    gltf.userData.vrmFirstPerson = await this._import(gltf, vrmHumanoid);\n  }\n\n  /**\n   * Import a {@link VRMFirstPerson} from a VRM.\n   *\n   * @param gltf A parsed result of GLTF taken from GLTFLoader\n   * @param humanoid A {@link VRMHumanoid} instance that represents the VRM\n   */\n\n  private async _import(gltf: GLTF, humanoid: VRMHumanoid | null): Promise<VRMFirstPerson | null> {\n    if (humanoid == null) {\n      return null;\n    }\n\n    const v1Result = await this._v1Import(gltf, humanoid);\n    if (v1Result) {\n      return v1Result;\n    }\n\n    const v0Result = await this._v0Import(gltf, humanoid);\n    if (v0Result) {\n      return v0Result;\n    }\n\n    return null;\n  }\n\n  private async _v1Import(gltf: GLTF, humanoid: VRMHumanoid): Promise<VRMFirstPerson | null> {\n    const json = this.parser.json as GLTFSchema.IGLTF;\n\n    // early abort if it doesn't use vrm\n    const isVRMUsed = json.extensionsUsed?.indexOf('VRMC_vrm') !== -1;\n    if (!isVRMUsed) {\n      return null;\n    }\n\n    const extension = json.extensions?.['VRMC_vrm'] as V1VRMSchema.VRMCVRM | undefined;\n    if (!extension) {\n      return null;\n    }\n\n    const specVersion = extension.specVersion;\n    if (!POSSIBLE_SPEC_VERSIONS.has(specVersion)) {\n      console.warn(`VRMFirstPersonLoaderPlugin: Unknown VRMC_vrm specVersion \"${specVersion}\"`);\n      return null;\n    }\n\n    const schemaFirstPerson = extension.firstPerson;\n\n    const meshAnnotations: VRMFirstPersonMeshAnnotation[] = [];\n    const nodePrimitivesMap = await gltfExtractPrimitivesFromNodes(gltf);\n    Array.from(nodePrimitivesMap.entries()).forEach(([nodeIndex, primitives]) => {\n      const annotation = schemaFirstPerson?.meshAnnotations?.find((a) => a.node === nodeIndex);\n\n      meshAnnotations.push({\n        meshes: primitives,\n        type: annotation?.type ?? 'auto',\n      });\n    });\n\n    return new VRMFirstPerson(humanoid, meshAnnotations);\n  }\n\n  private async _v0Import(gltf: GLTF, humanoid: VRMHumanoid): Promise<VRMFirstPerson | null> {\n    const json = this.parser.json as GLTFSchema.IGLTF;\n\n    const vrmExt = json.extensions?.VRM as V0VRM.VRM | undefined;\n    if (!vrmExt) {\n      return null;\n    }\n\n    const schemaFirstPerson: V0VRM.FirstPerson | undefined = vrmExt.firstPerson;\n    if (!schemaFirstPerson) {\n      return null;\n    }\n\n    const meshAnnotations: VRMFirstPersonMeshAnnotation[] = [];\n    const nodePrimitivesMap = await gltfExtractPrimitivesFromNodes(gltf);\n\n    Array.from(nodePrimitivesMap.entries()).forEach(([nodeIndex, primitives]) => {\n      const schemaNode = json.nodes![nodeIndex];\n\n      const flag = schemaFirstPerson.meshAnnotations\n        ? schemaFirstPerson.meshAnnotations.find((a) => a.mesh === schemaNode.mesh)\n        : undefined;\n\n      meshAnnotations.push({\n        meshes: primitives,\n        type: this._convertV0FlagToV1Type(flag?.firstPersonFlag),\n      });\n    });\n\n    return new VRMFirstPerson(humanoid, meshAnnotations);\n  }\n\n  private _convertV0FlagToV1Type(flag: string | undefined): VRMFirstPersonMeshAnnotationType {\n    if (flag === 'FirstPersonOnly') {\n      return 'firstPersonOnly';\n    } else if (flag === 'ThirdPersonOnly') {\n      return 'thirdPersonOnly';\n    } else if (flag === 'Both') {\n      return 'both';\n    } else {\n      // The default value is 'Auto' even in VRM0\n      // See: https://github.com/vrm-c/UniVRM/blob/07d98e2f1abc528d387f860d2224d0855b0d0b59/Assets/VRM/Runtime/FirstPerson/VRMFirstPerson.cs#L117-L119\n      return 'auto';\n    }\n  }\n}\n", "/* eslint-disable @typescript-eslint/naming-convention */\n\nexport const VRMFirstPersonMeshAnnotationType = {\n  Auto: 'auto',\n  Both: 'both',\n  ThirdPersonOnly: 'thirdPersonOnly',\n  FirstPersonOnly: 'firstPersonOnly',\n} as const;\n\nexport type VRMFirstPersonMeshAnnotationType =\n  (typeof VRMFirstPersonMeshAnnotationType)[keyof typeof VRMFirstPersonMeshAnnotationType];\n", "import * as THREE from 'three';\nimport { VRMHumanBone } from '../VRMHumanBone';\nimport { VRMHumanoid } from '../VRMHumanoid';\n\nconst _v3A = new THREE.Vector3();\nconst _v3B = new THREE.Vector3();\nconst _quatA = new THREE.Quaternion();\n\nexport class VRMHumanoidHelper extends THREE.Group {\n  public readonly vrmHumanoid: VRMHumanoid;\n  private _boneAxesMap: Map<VRMHumanBone, THREE.AxesHelper>;\n\n  public constructor(humanoid: VRMHumanoid) {\n    super();\n\n    this.vrmHumanoid = humanoid;\n\n    this._boneAxesMap = new Map();\n\n    Object.values(humanoid.humanBones).forEach((bone) => {\n      const helper = new THREE.AxesHelper(1.0);\n\n      helper.matrixAutoUpdate = false;\n\n      (helper.material as THREE.Material).depthTest = false;\n      (helper.material as THREE.Material).depthWrite = false;\n\n      this.add(helper);\n\n      this._boneAxesMap.set(bone, helper);\n    });\n  }\n\n  public dispose(): void {\n    Array.from(this._boneAxesMap.values()).forEach((axes) => {\n      axes.geometry.dispose();\n      (axes.material as THREE.Material).dispose();\n    });\n  }\n\n  public updateMatrixWorld(force: boolean): void {\n    Array.from(this._boneAxesMap.entries()).forEach(([bone, axes]) => {\n      bone.node.updateWorldMatrix(true, false);\n\n      bone.node.matrixWorld.decompose(_v3A, _quatA, _v3B);\n\n      const scale = _v3A.set(0.1, 0.1, 0.1).divide(_v3B);\n      axes.matrix.copy(bone.node.matrixWorld).scale(scale);\n    });\n\n    super.updateMatrixWorld(force);\n  }\n}\n", "/* eslint-disable @typescript-eslint/naming-convention */\n\nimport { VRMHumanBoneName } from './VRMHumanBoneName';\n\n/**\n * The list of {@link VRMHumanBoneName}. Dependency aware.\n */\nexport const VRMHumanBoneList: VRMHumanBoneName[] = [\n  'hips',\n  'spine',\n  'chest',\n  'upperChest',\n  'neck',\n\n  'head',\n  'leftEye',\n  'rightEye',\n  'jaw',\n\n  'leftUpperLeg',\n  'leftLowerLeg',\n  'leftFoot',\n  'leftToes',\n\n  'rightUpperLeg',\n  'rightLowerLeg',\n  'rightFoot',\n  'rightToes',\n\n  'leftShoulder',\n  'leftUpperArm',\n  'leftLowerArm',\n  'leftHand',\n\n  'rightShoulder',\n  'rightUpperArm',\n  'rightLowerArm',\n  'rightHand',\n\n  'leftThumbMetacarpal',\n  'leftThumbProximal',\n  'leftThumbDistal',\n  'leftIndexProximal',\n  'leftIndexIntermediate',\n  'leftIndexDistal',\n  'leftMiddleProximal',\n  'leftMiddleIntermediate',\n  'leftMiddleDistal',\n  'leftRingProximal',\n  'leftRingIntermediate',\n  'leftRingDistal',\n  'leftLittleProximal',\n  'leftLittleIntermediate',\n  'leftLittleDistal',\n\n  'rightThumbMetacarpal',\n  'rightThumbProximal',\n  'rightThumbDistal',\n  'rightIndexProximal',\n  'rightIndexIntermediate',\n  'rightIndexDistal',\n  'rightMiddleProximal',\n  'rightMiddleIntermediate',\n  'rightMiddleDistal',\n  'rightRingProximal',\n  'rightRingIntermediate',\n  'rightRingDistal',\n  'rightLittleProximal',\n  'rightLittleIntermediate',\n  'rightLittleDistal',\n];\n", "/* eslint-disable @typescript-eslint/naming-convention */\n\n/**\n * The names of {@link VRMHumanoid} bone names.\n *\n * Ref: https://github.com/vrm-c/vrm-specification/blob/master/specification/VRMC_vrm-1.0/humanoid.md\n */\nexport const VRMHumanBoneName = {\n  Hips: 'hips',\n  Spine: 'spine',\n  Chest: 'chest',\n  UpperChest: 'upperChest',\n  Neck: 'neck',\n\n  Head: 'head',\n  LeftEye: 'leftEye',\n  RightEye: 'rightEye',\n  Jaw: 'jaw',\n\n  LeftUpperLeg: 'leftUpperLeg',\n  LeftLowerLeg: 'leftLowerLeg',\n  LeftFoot: 'leftFoot',\n  LeftToes: 'leftToes',\n\n  RightUpperLeg: 'rightUpperLeg',\n  RightLowerLeg: 'rightLowerLeg',\n  RightFoot: 'rightFoot',\n  RightToes: 'rightToes',\n\n  LeftShoulder: 'leftShoulder',\n  LeftUpperArm: 'leftUpperArm',\n  LeftLowerArm: 'leftLowerArm',\n  LeftHand: 'leftHand',\n\n  RightShoulder: 'rightShoulder',\n  RightUpperArm: 'rightUpperArm',\n  RightLowerArm: 'rightLowerArm',\n  RightHand: 'rightHand',\n\n  LeftThumbMetacarpal: 'leftThumbMetacarpal',\n  LeftThumbProximal: 'leftThumbProximal',\n  LeftThumbDistal: 'leftThumbDistal',\n  LeftIndexProximal: 'leftIndexProximal',\n  LeftIndexIntermediate: 'leftIndexIntermediate',\n  LeftIndexDistal: 'leftIndexDistal',\n  LeftMiddleProximal: 'leftMiddleProximal',\n  LeftMiddleIntermediate: 'leftMiddleIntermediate',\n  LeftMiddleDistal: 'leftMiddleDistal',\n  LeftRingProximal: 'leftRingProximal',\n  LeftRingIntermediate: 'leftRingIntermediate',\n  LeftRingDistal: 'leftRingDistal',\n  LeftLittleProximal: 'leftLittleProximal',\n  LeftLittleIntermediate: 'leftLittleIntermediate',\n  LeftLittleDistal: 'leftLittleDistal',\n\n  RightThumbMetacarpal: 'rightThumbMetacarpal',\n  RightThumbProximal: 'rightThumbProximal',\n  RightThumbDistal: 'rightThumbDistal',\n  RightIndexProximal: 'rightIndexProximal',\n  RightIndexIntermediate: 'rightIndexIntermediate',\n  RightIndexDistal: 'rightIndexDistal',\n  RightMiddleProximal: 'rightMiddleProximal',\n  RightMiddleIntermediate: 'rightMiddleIntermediate',\n  RightMiddleDistal: 'rightMiddleDistal',\n  RightRingProximal: 'rightRingProximal',\n  RightRingIntermediate: 'rightRingIntermediate',\n  RightRingDistal: 'rightRingDistal',\n  RightLittleProximal: 'rightLittleProximal',\n  RightLittleIntermediate: 'rightLittleIntermediate',\n  RightLittleDistal: 'rightLittleDistal',\n} as const;\n\nexport type VRMHumanBoneName = (typeof VRMHumanBoneName)[keyof typeof VRMHumanBoneName];\n", "/* eslint-disable @typescript-eslint/naming-convention */\n\nimport { VRMHumanBoneName } from './VRMHumanBoneName';\n\n/**\n * An object that maps from {@link VRMHumanBoneName} to its parent {@link VRMHumanBoneName}.\n *\n * Ref: https://github.com/vrm-c/vrm-specification/blob/master/specification/VRMC_vrm-1.0/humanoid.md\n */\nexport const VRMHumanBoneParentMap: { [bone in VRMHumanBoneName]: VRMHumanBoneName | null } = {\n  hips: null,\n  spine: 'hips',\n  chest: 'spine',\n  upperChest: 'chest',\n  neck: 'upperChest',\n\n  head: 'neck',\n  leftEye: 'head',\n  rightEye: 'head',\n  jaw: 'head',\n\n  leftUpperLeg: 'hips',\n  leftLowerLeg: 'leftUpperLeg',\n  leftFoot: 'leftLowerLeg',\n  leftToes: 'leftFoot',\n\n  rightUpperLeg: 'hips',\n  rightLowerLeg: 'rightUpperLeg',\n  rightFoot: 'rightLowerLeg',\n  rightToes: 'rightFoot',\n\n  leftShoulder: 'upperChest',\n  leftUpperArm: 'leftShoulder',\n  leftLowerArm: 'leftUpperArm',\n  leftHand: 'leftLowerArm',\n\n  rightShoulder: 'upperChest',\n  rightUpperArm: 'rightShoulder',\n  rightLowerArm: 'rightUpperArm',\n  rightHand: 'rightLowerArm',\n\n  leftThumbMetacarpal: 'leftHand',\n  leftThumbProximal: 'leftThumbMetacarpal',\n  leftThumbDistal: 'leftThumbProximal',\n  leftIndexProximal: 'leftHand',\n  leftIndexIntermediate: 'leftIndexProximal',\n  leftIndexDistal: 'leftIndexIntermediate',\n  leftMiddleProximal: 'leftHand',\n  leftMiddleIntermediate: 'leftMiddleProximal',\n  leftMiddleDistal: 'leftMiddleIntermediate',\n  leftRingProximal: 'leftHand',\n  leftRingIntermediate: 'leftRingProximal',\n  leftRingDistal: 'leftRingIntermediate',\n  leftLittleProximal: 'leftHand',\n  leftLittleIntermediate: 'leftLittleProximal',\n  leftLittleDistal: 'leftLittleIntermediate',\n\n  rightThumbMetacarpal: 'rightHand',\n  rightThumbProximal: 'rightThumbMetacarpal',\n  rightThumbDistal: 'rightThumbProximal',\n  rightIndexProximal: 'rightHand',\n  rightIndexIntermediate: 'rightIndexProximal',\n  rightIndexDistal: 'rightIndexIntermediate',\n  rightMiddleProximal: 'rightHand',\n  rightMiddleIntermediate: 'rightMiddleProximal',\n  rightMiddleDistal: 'rightMiddleIntermediate',\n  rightRingProximal: 'rightHand',\n  rightRingIntermediate: 'rightRingProximal',\n  rightRingDistal: 'rightRingIntermediate',\n  rightLittleProximal: 'rightHand',\n  rightLittleIntermediate: 'rightLittleProximal',\n  rightLittleDistal: 'rightLittleIntermediate',\n};\n", "import * as THREE from 'three';\nimport { quatInvertCompat } from '../utils/quatInvertCompat';\nimport type { VRMHumanBone } from './VRMHumanBone';\nimport type { VRMHumanBones } from './VRMHumanBones';\nimport type { VRMHumanBoneName } from './VRMHumanBoneName';\nimport type { VRMPose } from './VRMPose';\n\nconst _v3A = new THREE.Vector3();\nconst _quatA = new THREE.Quaternion();\n\n/**\n * A class represents the Rig of a VRM.\n */\nexport class VRMRig {\n  /**\n   * A {@link VRMHumanBones} that contains all the human bones of the VRM.\n   * You might want to get these bones using {@link VRMHumanoid.getBone}.\n   */\n  public humanBones: VRMHumanBones;\n\n  /**\n   * A {@link VRMPose} that is its default state.\n   * Note that it's not compatible with {@link setPose} and {@link getPose}, since it contains non-relative values of each local transforms.\n   */\n  public restPose: VRMPose;\n\n  /**\n   * Create a new {@link VRMHumanoid}.\n   * @param humanBones A {@link VRMHumanBones} contains all the bones of the new humanoid\n   */\n  public constructor(humanBones: VRMHumanBones) {\n    this.humanBones = humanBones;\n\n    this.restPose = this.getAbsolutePose();\n  }\n\n  /**\n   * Return the current absolute pose of this humanoid as a {@link VRMPose}.\n   * Note that the output result will contain initial state of the VRM and not compatible between different models.\n   * You might want to use {@link getPose} instead.\n   */\n  public getAbsolutePose(): VRMPose {\n    const pose = {} as VRMPose;\n\n    Object.keys(this.humanBones).forEach((vrmBoneNameString) => {\n      const vrmBoneName = vrmBoneNameString as VRMHumanBoneName;\n      const node = this.getBoneNode(vrmBoneName);\n\n      // Ignore when there are no bone on the VRMHumanoid\n      if (!node) {\n        return;\n      }\n\n      // Get the position / rotation from the node\n      _v3A.copy(node.position);\n      _quatA.copy(node.quaternion);\n\n      // Convert to raw arrays\n      pose[vrmBoneName] = {\n        position: _v3A.toArray() as [number, number, number],\n        rotation: _quatA.toArray() as [number, number, number, number],\n      };\n    });\n\n    return pose;\n  }\n\n  /**\n   * Return the current pose of this humanoid as a {@link VRMPose}.\n   *\n   * Each transform is a local transform relative from rest pose (T-pose).\n   */\n  public getPose(): VRMPose {\n    const pose = {} as VRMPose;\n\n    Object.keys(this.humanBones).forEach((boneNameString) => {\n      const boneName = boneNameString as VRMHumanBoneName;\n      const node = this.getBoneNode(boneName);\n\n      // Ignore when there are no bone on the VRMHumanoid\n      if (!node) {\n        return;\n      }\n\n      // Take a diff from restPose\n      _v3A.set(0, 0, 0);\n      _quatA.identity();\n\n      const restState = this.restPose[boneName];\n      if (restState?.position) {\n        _v3A.fromArray(restState.position).negate();\n      }\n      if (restState?.rotation) {\n        quatInvertCompat(_quatA.fromArray(restState.rotation));\n      }\n\n      // Get the position / rotation from the node\n      _v3A.add(node.position);\n      _quatA.premultiply(node.quaternion);\n\n      // Convert to raw arrays\n      pose[boneName] = {\n        position: _v3A.toArray() as [number, number, number],\n        rotation: _quatA.toArray() as [number, number, number, number],\n      };\n    });\n\n    return pose;\n  }\n\n  /**\n   * Let the humanoid do a specified pose.\n   *\n   * Each transform have to be a local transform relative from rest pose (T-pose).\n   * You can pass what you got from {@link getPose}.\n   *\n   * @param poseObject A {@link VRMPose} that represents a single pose\n   */\n  public setPose(poseObject: VRMPose): void {\n    Object.entries(poseObject).forEach(([boneNameString, state]) => {\n      const boneName = boneNameString as VRMHumanBoneName;\n      const node = this.getBoneNode(boneName);\n\n      // Ignore when there are no bone that is defined in the pose on the VRMHumanoid\n      if (!node) {\n        return;\n      }\n\n      const restState = this.restPose[boneName];\n      if (!restState) {\n        // It's very unlikely. Possibly a bug\n        return;\n      }\n\n      // Apply the state to the actual bone\n      if (state?.position) {\n        node.position.fromArray(state.position);\n\n        if (restState.position) {\n          node.position.add(_v3A.fromArray(restState.position));\n        }\n      }\n\n      if (state?.rotation) {\n        node.quaternion.fromArray(state.rotation);\n\n        if (restState.rotation) {\n          node.quaternion.multiply(_quatA.fromArray(restState.rotation));\n        }\n      }\n    });\n  }\n\n  /**\n   * Reset the humanoid to its rest pose.\n   */\n  public resetPose(): void {\n    Object.entries(this.restPose).forEach(([boneName, rest]) => {\n      const node = this.getBoneNode(boneName as VRMHumanBoneName);\n\n      if (!node) {\n        return;\n      }\n\n      if (rest?.position) {\n        node.position.fromArray(rest.position);\n      }\n\n      if (rest?.rotation) {\n        node.quaternion.fromArray(rest.rotation);\n      }\n    });\n  }\n\n  /**\n   * Return a bone bound to a specified {@link VRMHumanBoneName}, as a {@link VRMHumanBone}.\n   *\n   * @param name Name of the bone you want\n   */\n  public getBone(name: VRMHumanBoneName): VRMHumanBone | undefined {\n    return this.humanBones[name] ?? undefined;\n  }\n\n  /**\n   * Return a bone bound to a specified {@link VRMHumanBoneName}, as a `THREE.Object3D`.\n   *\n   * @param name Name of the bone you want\n   */\n  public getBoneNode(name: VRMHumanBoneName): THREE.Object3D | null {\n    return this.humanBones[name]?.node ?? null;\n  }\n}\n", "import * as THREE from 'three';\n\n/**\n * A compat function for `Quaternion.invert()` / `Quaternion.inverse()`.\n * `Quaternion.invert()` is introduced in r123 and `Quaternion.inverse()` emits a warning.\n * We are going to use this compat for a while.\n * @param target A target quaternion\n */\nexport function quatInvertCompat<T extends THREE.Quaternion>(target: T): T {\n  if ((target as any).invert) {\n    target.invert();\n  } else {\n    (target as any).inverse();\n  }\n\n  return target;\n}\n", "import * as THREE from 'three';\nimport { VRMHumanBoneName, VRMHumanBones } from '.';\nimport { VRMHumanBoneList } from './VRMHumanBoneList';\nimport { VRMHumanBoneParentMap } from './VRMHumanBoneParentMap';\nimport { VRMRig } from './VRMRig';\n\nconst _v3A = new THREE.Vector3();\nconst _quatA = new THREE.Quaternion();\nconst _boneWorldPos = new THREE.Vector3();\n\n/**\n * A class represents the normalized Rig of a VRM.\n */\nexport class VRMHumanoidRig extends VRMRig {\n  protected static _setupTransforms(modelRig: VRMRig): {\n    rigBones: VRMHumanBones;\n    root: THREE.Object3D;\n    parentWorldRotations: { [boneName in VRMHumanBoneName]?: THREE.Quaternion };\n    boneRotations: { [boneName in VRMHumanBoneName]?: THREE.Quaternion };\n  } {\n    const root = new THREE.Object3D();\n    root.name = 'VRMHumanoidRig';\n\n    // store boneWorldPositions, boneWorldRotations, and parentWorldRotations\n    const boneWorldPositions: { [boneName in VRMHumanBoneName]?: THREE.Vector3 } = {};\n    const boneWorldRotations: { [boneName in VRMHumanBoneName]?: THREE.Quaternion } = {};\n    const boneRotations: { [boneName in VRMHumanBoneName]?: THREE.Quaternion } = {};\n    const parentWorldRotations: { [boneName in VRMHumanBoneName]?: THREE.Quaternion } = {};\n\n    VRMHumanBoneList.forEach((boneName) => {\n      const boneNode = modelRig.getBoneNode(boneName);\n\n      if (boneNode) {\n        const boneWorldPosition = new THREE.Vector3();\n        const boneWorldRotation = new THREE.Quaternion();\n\n        boneNode.updateWorldMatrix(true, false);\n        boneNode.matrixWorld.decompose(boneWorldPosition, boneWorldRotation, _v3A);\n\n        boneWorldPositions[boneName] = boneWorldPosition;\n        boneWorldRotations[boneName] = boneWorldRotation;\n        boneRotations[boneName] = boneNode.quaternion.clone();\n\n        const parentWorldRotation = new THREE.Quaternion();\n        boneNode.parent?.matrixWorld.decompose(_v3A, parentWorldRotation, _v3A);\n        parentWorldRotations[boneName] = parentWorldRotation;\n      }\n    });\n\n    // build rig hierarchy + store parentWorldRotations\n    const rigBones: Partial<VRMHumanBones> = {};\n    VRMHumanBoneList.forEach((boneName) => {\n      const boneNode = modelRig.getBoneNode(boneName);\n\n      if (boneNode) {\n        const boneWorldPosition = boneWorldPositions[boneName] as THREE.Vector3;\n\n        // see the nearest parent position\n        let currentBoneName: VRMHumanBoneName | null = boneName;\n        let parentBoneWorldPosition: THREE.Vector3 | undefined;\n        while (parentBoneWorldPosition == null) {\n          currentBoneName = VRMHumanBoneParentMap[currentBoneName];\n          if (currentBoneName == null) {\n            break;\n          }\n          parentBoneWorldPosition = boneWorldPositions[currentBoneName];\n        }\n\n        // add to hierarchy\n        const rigBoneNode = new THREE.Object3D();\n        rigBoneNode.name = 'Normalized_' + boneNode.name;\n\n        const parentRigBoneNode = (currentBoneName ? rigBones[currentBoneName]?.node : root) as THREE.Object3D;\n\n        parentRigBoneNode.add(rigBoneNode);\n        rigBoneNode.position.copy(boneWorldPosition);\n        if (parentBoneWorldPosition) {\n          rigBoneNode.position.sub(parentBoneWorldPosition);\n        }\n\n        rigBones[boneName] = { node: rigBoneNode };\n      }\n    });\n\n    return {\n      rigBones: rigBones as VRMHumanBones,\n      root,\n      parentWorldRotations,\n      boneRotations,\n    };\n  }\n\n  public readonly original: VRMRig;\n  public readonly root: THREE.Object3D;\n  protected readonly _parentWorldRotations: { [boneName in VRMHumanBoneName]?: THREE.Quaternion };\n  protected readonly _boneRotations: { [boneName in VRMHumanBoneName]?: THREE.Quaternion };\n\n  public constructor(humanoid: VRMRig) {\n    const { rigBones, root, parentWorldRotations, boneRotations } = VRMHumanoidRig._setupTransforms(humanoid);\n\n    super(rigBones);\n\n    this.original = humanoid;\n    this.root = root;\n    this._parentWorldRotations = parentWorldRotations;\n    this._boneRotations = boneRotations;\n  }\n\n  /**\n   * Update this humanoid rig.\n   */\n  public update(): void {\n    VRMHumanBoneList.forEach((boneName) => {\n      const boneNode = this.original.getBoneNode(boneName);\n\n      if (boneNode != null) {\n        const rigBoneNode = this.getBoneNode(boneName)!;\n        const parentWorldRotation = this._parentWorldRotations[boneName]!;\n        const invParentWorldRotation = _quatA.copy(parentWorldRotation).invert();\n        const boneRotation = this._boneRotations[boneName]!;\n\n        boneNode.quaternion\n          .copy(rigBoneNode.quaternion)\n          .multiply(parentWorldRotation)\n          .premultiply(invParentWorldRotation)\n          .multiply(boneRotation);\n\n        // Move the mass center of the VRM\n        if (boneName === 'hips') {\n          const boneWorldPosition = rigBoneNode.getWorldPosition(_boneWorldPos);\n          boneNode.parent!.updateWorldMatrix(true, false);\n          const parentWorldMatrix = boneNode.parent!.matrixWorld;\n          const localPosition = boneWorldPosition.applyMatrix4(parentWorldMatrix.invert());\n          boneNode.position.copy(localPosition);\n        }\n      }\n    });\n  }\n}\n", "import * as THREE from 'three';\nimport type { VRMHumanBone } from './VRMHumanBone';\nimport type { VRMHumanBones } from './VRMHumanBones';\nimport type { VRMHumanBoneName } from './VRMHumanBoneName';\nimport type { VRMPose } from './VRMPose';\nimport { VRMRig } from './VRMRig';\nimport { VRMHumanoidRig } from './VRMHumanoidRig';\n\n/**\n * A class represents a humanoid of a VRM.\n */\nexport class VRMHumanoid {\n  /**\n   * Whether it copies pose from normalizedHumanBones to rawHumanBones on {@link update}.\n   * `true` by default.\n   *\n   * @default true\n   */\n  public autoUpdateHumanBones: boolean;\n\n  /**\n   * A raw rig of the VRM.\n   */\n  private _rawHumanBones: VRMRig; // TODO: Rename\n\n  /**\n   * A normalized rig of the VRM.\n   */\n  private _normalizedHumanBones: VRMHumanoidRig; // TODO: Rename\n\n  /**\n   * @deprecated Deprecated. Use either {@link rawRestPose} or {@link normalizedRestPose} instead.\n   */\n  public get restPose(): VRMPose {\n    console.warn('VRMHumanoid: restPose is deprecated. Use either rawRestPose or normalizedRestPose instead.');\n\n    return this.rawRestPose;\n  }\n\n  /**\n   * A {@link VRMPose} of its raw human bones that is its default state.\n   * Note that it's not compatible with {@link setRawPose} and {@link getRawPose}, since it contains non-relative values of each local transforms.\n   */\n  public get rawRestPose(): VRMPose {\n    return this._rawHumanBones.restPose;\n  }\n\n  /**\n   * A {@link VRMPose} of its normalized human bones that is its default state.\n   * Note that it's not compatible with {@link setNormalizedPose} and {@link getNormalizedPose}, since it contains non-relative values of each local transforms.\n   */\n  public get normalizedRestPose(): VRMPose {\n    return this._normalizedHumanBones.restPose;\n  }\n\n  /**\n   * A map from {@link VRMHumanBoneName} to raw {@link VRMHumanBone}s.\n   */\n  public get humanBones(): VRMHumanBones {\n    // an alias of `rawHumanBones`\n    return this._rawHumanBones.humanBones;\n  }\n\n  /**\n   * A map from {@link VRMHumanBoneName} to raw {@link VRMHumanBone}s.\n   */\n  public get rawHumanBones(): VRMHumanBones {\n    return this._rawHumanBones.humanBones;\n  }\n\n  /**\n   * A map from {@link VRMHumanBoneName} to normalized {@link VRMHumanBone}s.\n   */\n  public get normalizedHumanBones(): VRMHumanBones {\n    return this._normalizedHumanBones.humanBones;\n  }\n\n  /**\n   * The root of normalized {@link VRMHumanBone}s.\n   */\n  public get normalizedHumanBonesRoot(): THREE.Object3D {\n    return this._normalizedHumanBones.root;\n  }\n\n  /**\n   * Create a new {@link VRMHumanoid}.\n   * @param humanBones A {@link VRMHumanBones} contains all the bones of the new humanoid\n   * @param autoUpdateHumanBones Whether it copies pose from normalizedHumanBones to rawHumanBones on {@link update}. `true` by default.\n   */\n  public constructor(humanBones: VRMHumanBones, options?: { autoUpdateHumanBones?: boolean }) {\n    this.autoUpdateHumanBones = options?.autoUpdateHumanBones ?? true;\n    this._rawHumanBones = new VRMRig(humanBones);\n    this._normalizedHumanBones = new VRMHumanoidRig(this._rawHumanBones);\n  }\n\n  /**\n   * Copy the given {@link VRMHumanoid} into this one.\n   * @param source The {@link VRMHumanoid} you want to copy\n   * @returns this\n   */\n  public copy(source: VRMHumanoid): this {\n    this.autoUpdateHumanBones = source.autoUpdateHumanBones;\n    this._rawHumanBones = new VRMRig(source.humanBones);\n    this._normalizedHumanBones = new VRMHumanoidRig(this._rawHumanBones);\n\n    return this;\n  }\n\n  /**\n   * Returns a clone of this {@link VRMHumanoid}.\n   * @returns Copied {@link VRMHumanoid}\n   */\n  public clone(): VRMHumanoid {\n    return new VRMHumanoid(this.humanBones, { autoUpdateHumanBones: this.autoUpdateHumanBones }).copy(this);\n  }\n\n  /**\n   * @deprecated Deprecated. Use either {@link getRawAbsolutePose} or {@link getNormalizedAbsolutePose} instead.\n   */\n  public getAbsolutePose(): VRMPose {\n    console.warn(\n      'VRMHumanoid: getAbsolutePose() is deprecated. Use either getRawAbsolutePose() or getNormalizedAbsolutePose() instead.',\n    );\n\n    return this.getRawAbsolutePose();\n  }\n\n  /**\n   * Return the current absolute pose of this raw human bones as a {@link VRMPose}.\n   * Note that the output result will contain initial state of the VRM and not compatible between different models.\n   * You might want to use {@link getRawPose} instead.\n   */\n  public getRawAbsolutePose(): VRMPose {\n    return this._rawHumanBones.getAbsolutePose();\n  }\n\n  /**\n   * Return the current absolute pose of this normalized human bones as a {@link VRMPose}.\n   * Note that the output result will contain initial state of the VRM and not compatible between different models.\n   * You might want to use {@link getNormalizedPose} instead.\n   */\n  public getNormalizedAbsolutePose(): VRMPose {\n    return this._normalizedHumanBones.getAbsolutePose();\n  }\n\n  /**\n   * @deprecated Deprecated. Use either {@link getRawPose} or {@link getNormalizedPose} instead.\n   */\n  public getPose(): VRMPose {\n    console.warn('VRMHumanoid: getPose() is deprecated. Use either getRawPose() or getNormalizedPose() instead.');\n\n    return this.getRawPose();\n  }\n\n  /**\n   * Return the current pose of raw human bones as a {@link VRMPose}.\n   *\n   * Each transform is a local transform relative from rest pose (T-pose).\n   */\n  public getRawPose(): VRMPose {\n    return this._rawHumanBones.getPose();\n  }\n\n  /**\n   * Return the current pose of normalized human bones as a {@link VRMPose}.\n   *\n   * Each transform is a local transform relative from rest pose (T-pose).\n   */\n  public getNormalizedPose(): VRMPose {\n    return this._normalizedHumanBones.getPose();\n  }\n\n  /**\n   * @deprecated Deprecated. Use either {@link setRawPose} or {@link setNormalizedPose} instead.\n   */\n  public setPose(poseObject: VRMPose): void {\n    console.warn('VRMHumanoid: setPose() is deprecated. Use either setRawPose() or setNormalizedPose() instead.');\n\n    return this.setRawPose(poseObject);\n  }\n\n  /**\n   * Let the raw human bones do a specified pose.\n   *\n   * Each transform have to be a local transform relative from rest pose (T-pose).\n   * You can pass what you got from {@link getRawPose}.\n   *\n   * If you are using {@link autoUpdateHumanBones}, you might want to use {@link setNormalizedPose} instead.\n   *\n   * @param poseObject A {@link VRMPose} that represents a single pose\n   */\n  public setRawPose(poseObject: VRMPose): void {\n    return this._rawHumanBones.setPose(poseObject);\n  }\n\n  /**\n   * Let the normalized human bones do a specified pose.\n   *\n   * Each transform have to be a local transform relative from rest pose (T-pose).\n   * You can pass what you got from {@link getNormalizedPose}.\n   *\n   * @param poseObject A {@link VRMPose} that represents a single pose\n   */\n  public setNormalizedPose(poseObject: VRMPose): void {\n    return this._normalizedHumanBones.setPose(poseObject);\n  }\n\n  /**\n   * @deprecated Deprecated. Use either {@link resetRawPose} or {@link resetNormalizedPose} instead.\n   */\n  public resetPose(): void {\n    console.warn('VRMHumanoid: resetPose() is deprecated. Use either resetRawPose() or resetNormalizedPose() instead.');\n\n    return this.resetRawPose();\n  }\n\n  /**\n   * Reset the raw humanoid to its rest pose.\n   *\n   * If you are using {@link autoUpdateHumanBones}, you might want to use {@link resetNormalizedPose} instead.\n   */\n  public resetRawPose(): void {\n    return this._rawHumanBones.resetPose();\n  }\n\n  /**\n   * Reset the normalized humanoid to its rest pose.\n   */\n  public resetNormalizedPose(): void {\n    return this._normalizedHumanBones.resetPose();\n  }\n\n  /**\n   * @deprecated Deprecated. Use either {@link getRawBone} or {@link getNormalizedBone} instead.\n   */\n  public getBone(name: VRMHumanBoneName): VRMHumanBone | undefined {\n    console.warn('VRMHumanoid: getBone() is deprecated. Use either getRawBone() or getNormalizedBone() instead.');\n\n    return this.getRawBone(name);\n  }\n\n  /**\n   * Return a raw {@link VRMHumanBone} bound to a specified {@link VRMHumanBoneName}.\n   *\n   * @param name Name of the bone you want\n   */\n  public getRawBone(name: VRMHumanBoneName): VRMHumanBone | undefined {\n    return this._rawHumanBones.getBone(name);\n  }\n\n  /**\n   * Return a normalized {@link VRMHumanBone} bound to a specified {@link VRMHumanBoneName}.\n   *\n   * @param name Name of the bone you want\n   */\n  public getNormalizedBone(name: VRMHumanBoneName): VRMHumanBone | undefined {\n    return this._normalizedHumanBones.getBone(name);\n  }\n\n  /**\n   * @deprecated Deprecated. Use either {@link getRawBoneNode} or {@link getNormalizedBoneNode} instead.\n   */\n  public getBoneNode(name: VRMHumanBoneName): THREE.Object3D | null {\n    console.warn(\n      'VRMHumanoid: getBoneNode() is deprecated. Use either getRawBoneNode() or getNormalizedBoneNode() instead.',\n    );\n\n    return this.getRawBoneNode(name);\n  }\n\n  /**\n   * Return a raw bone as a `THREE.Object3D` bound to a specified {@link VRMHumanBoneName}.\n   *\n   * @param name Name of the bone you want\n   */\n  public getRawBoneNode(name: VRMHumanBoneName): THREE.Object3D | null {\n    return this._rawHumanBones.getBoneNode(name);\n  }\n\n  /**\n   * Return a normalized bone as a `THREE.Object3D` bound to a specified {@link VRMHumanBoneName}.\n   *\n   * @param name Name of the bone you want\n   */\n  public getNormalizedBoneNode(name: VRMHumanBoneName): THREE.Object3D | null {\n    return this._normalizedHumanBones.getBoneNode(name);\n  }\n\n  /**\n   * Update the humanoid component.\n   *\n   * If {@link autoUpdateHumanBones} is `true`, it transfers the pose of normalized human bones to raw human bones.\n   */\n  public update(): void {\n    if (this.autoUpdateHumanBones) {\n      this._normalizedHumanBones.update();\n    }\n  }\n}\n", "/* eslint-disable @typescript-eslint/naming-convention */\n\nexport const VRMRequiredHumanBoneName = {\n  Hips: 'hips',\n  Spine: 'spine',\n  Head: 'head',\n  LeftUpperLeg: 'leftUpperLeg',\n  LeftLowerLeg: 'leftLowerLeg',\n  LeftFoot: 'leftFoot',\n  RightUpperLeg: 'rightUpperLeg',\n  RightLowerLeg: 'rightLowerLeg',\n  RightFoot: 'rightFoot',\n  LeftUpperArm: 'leftUpperArm',\n  LeftLowerArm: 'leftLowerArm',\n  LeftHand: 'leftHand',\n  RightUpperArm: 'rightUpperArm',\n  RightLowerArm: 'rightLowerArm',\n  RightHand: 'rightHand',\n} as const;\n\nexport type VRMRequiredHumanBoneName = (typeof VRMRequiredHumanBoneName)[keyof typeof VRMRequiredHumanBoneName];\n", "import type * as THREE from 'three';\nimport type * as V0VRM from '@pixiv/types-vrm-0.0';\nimport type * as V1VRMSchema from '@pixiv/types-vrmc-vrm-1.0';\nimport type { GLTF, GLTFLoaderPlugin, GLTFParser } from 'three/examples/jsm/loaders/GLTFLoader.js';\nimport { VRMHumanoid } from './VRMHumanoid';\nimport type { VRMHumanBones } from './VRMHumanBones';\nimport { VRMRequiredHumanBoneName } from './VRMRequiredHumanBoneName';\nimport { GLTF as GLTFSchema } from '@gltf-transform/core';\nimport { VRMHumanoidHelper } from './helpers/VRMHumanoidHelper';\nimport { VRMHumanoidLoaderPluginOptions } from './VRMHumanoidLoaderPluginOptions';\n\n/**\n * Possible spec versions it recognizes.\n */\nconst POSSIBLE_SPEC_VERSIONS = new Set(['1.0', '1.0-beta']);\n\n/**\n * A map from old thumb bone names to new thumb bone names\n */\nconst thumbBoneNameMap: { [key: string]: V1VRMSchema.HumanoidHumanBoneName | undefined } = {\n  leftThumbProximal: 'leftThumbMetacarpal',\n  leftThumbIntermediate: 'leftThumbProximal',\n  rightThumbProximal: 'rightThumbMetacarpal',\n  rightThumbIntermediate: 'rightThumbProximal',\n};\n\n/**\n * A plugin of GLTFLoader that imports a {@link VRMHumanoid} from a VRM extension of a GLTF.\n */\nexport class VRMHumanoidLoaderPlugin implements GLTFLoaderPlugin {\n  /**\n   * Specify an Object3D to add {@link VRMHumanoidHelper}.\n   * If not specified, helper will not be created.\n   * If `renderOrder` is set to the root, the helper will copy the same `renderOrder` .\n   */\n  public helperRoot?: THREE.Object3D;\n\n  public autoUpdateHumanBones?: boolean;\n\n  public readonly parser: GLTFParser;\n\n  public get name(): string {\n    // We should use the extension name instead but we have multiple plugins for an extension...\n    return 'VRMHumanoidLoaderPlugin';\n  }\n\n  public constructor(parser: GLTFParser, options?: VRMHumanoidLoaderPluginOptions) {\n    this.parser = parser;\n\n    this.helperRoot = options?.helperRoot;\n    this.autoUpdateHumanBones = options?.autoUpdateHumanBones;\n  }\n\n  public async afterRoot(gltf: GLTF): Promise<void> {\n    gltf.userData.vrmHumanoid = await this._import(gltf);\n  }\n\n  /**\n   * Import a {@link VRMHumanoid} from a VRM.\n   *\n   * @param gltf A parsed result of GLTF taken from GLTFLoader\n   */\n  private async _import(gltf: GLTF): Promise<VRMHumanoid | null> {\n    const v1Result = await this._v1Import(gltf);\n    if (v1Result) {\n      return v1Result;\n    }\n\n    const v0Result = await this._v0Import(gltf);\n    if (v0Result) {\n      return v0Result;\n    }\n\n    return null;\n  }\n\n  private async _v1Import(gltf: GLTF): Promise<VRMHumanoid | null> {\n    const json = this.parser.json as GLTFSchema.IGLTF;\n\n    // early abort if it doesn't use vrm\n    const isVRMUsed = json.extensionsUsed?.indexOf('VRMC_vrm') !== -1;\n    if (!isVRMUsed) {\n      return null;\n    }\n\n    const extension = json.extensions?.['VRMC_vrm'] as V1VRMSchema.VRMCVRM | undefined;\n    if (!extension) {\n      return null;\n    }\n\n    const specVersion = extension.specVersion;\n    if (!POSSIBLE_SPEC_VERSIONS.has(specVersion)) {\n      console.warn(`VRMHumanoidLoaderPlugin: Unknown VRMC_vrm specVersion \"${specVersion}\"`);\n      return null;\n    }\n\n    const schemaHumanoid = extension.humanoid;\n    if (!schemaHumanoid) {\n      return null;\n    }\n\n    /**\n     * compat: 1.0-beta thumb bone names\n     *\n     * `true` if `leftThumbIntermediate` or `rightThumbIntermediate` exists\n     */\n    const existsPreviousThumbName =\n      (schemaHumanoid.humanBones as any).leftThumbIntermediate != null ||\n      (schemaHumanoid.humanBones as any).rightThumbIntermediate != null;\n\n    const humanBones: Partial<VRMHumanBones> = {};\n    if (schemaHumanoid.humanBones != null) {\n      await Promise.all(\n        Object.entries(schemaHumanoid.humanBones).map(async ([boneNameString, schemaHumanBone]) => {\n          let boneName = boneNameString as V1VRMSchema.HumanoidHumanBoneName;\n          const index = schemaHumanBone.node;\n\n          // compat: 1.0-beta previous thumb bone names\n          if (existsPreviousThumbName) {\n            const thumbBoneName = thumbBoneNameMap[boneName];\n            if (thumbBoneName != null) {\n              boneName = thumbBoneName;\n            }\n          }\n\n          const node = await this.parser.getDependency('node', index);\n\n          // if the specified node does not exist, emit a warning\n          if (node == null) {\n            console.warn(`A glTF node bound to the humanoid bone ${boneName} (index = ${index}) does not exist`);\n            return;\n          }\n\n          // set to the `humanBones`\n          humanBones[boneName] = { node };\n        }),\n      );\n    }\n\n    const humanoid = new VRMHumanoid(this._ensureRequiredBonesExist(humanBones), {\n      autoUpdateHumanBones: this.autoUpdateHumanBones,\n    });\n    gltf.scene.add(humanoid.normalizedHumanBonesRoot);\n\n    if (this.helperRoot) {\n      const helper = new VRMHumanoidHelper(humanoid);\n      this.helperRoot.add(helper);\n      helper.renderOrder = this.helperRoot.renderOrder;\n    }\n\n    return humanoid;\n  }\n\n  private async _v0Import(gltf: GLTF): Promise<VRMHumanoid | null> {\n    const json = this.parser.json as GLTFSchema.IGLTF;\n\n    const vrmExt = json.extensions?.VRM as V0VRM.VRM | undefined;\n    if (!vrmExt) {\n      return null;\n    }\n\n    const schemaHumanoid: V0VRM.Humanoid | undefined = vrmExt.humanoid;\n    if (!schemaHumanoid) {\n      return null;\n    }\n\n    const humanBones: Partial<VRMHumanBones> = {};\n    if (schemaHumanoid.humanBones != null) {\n      await Promise.all(\n        schemaHumanoid.humanBones.map(async (bone) => {\n          const boneName = bone.bone;\n          const index = bone.node;\n\n          if (boneName == null || index == null) {\n            return;\n          }\n\n          const node = await this.parser.getDependency('node', index);\n\n          // if the specified node does not exist, emit a warning\n          if (node == null) {\n            console.warn(`A glTF node bound to the humanoid bone ${boneName} (index = ${index}) does not exist`);\n            return;\n          }\n\n          // map to new bone name\n          const thumbBoneName = thumbBoneNameMap[boneName];\n          const newBoneName = (thumbBoneName ?? boneName) as V1VRMSchema.HumanoidHumanBoneName;\n\n          // v0 VRMs might have a multiple nodes attached to a single bone...\n          // so if there already is an entry in the `humanBones`, show a warning and ignore it\n          if (humanBones[newBoneName] != null) {\n            console.warn(\n              `Multiple bone entries for ${newBoneName} detected (index = ${index}), ignoring duplicated entries.`,\n            );\n            return;\n          }\n\n          // set to the `humanBones`\n          humanBones[newBoneName] = { node };\n        }),\n      );\n    }\n\n    const humanoid = new VRMHumanoid(this._ensureRequiredBonesExist(humanBones), {\n      autoUpdateHumanBones: this.autoUpdateHumanBones,\n    });\n    gltf.scene.add(humanoid.normalizedHumanBonesRoot);\n\n    if (this.helperRoot) {\n      const helper = new VRMHumanoidHelper(humanoid);\n      this.helperRoot.add(helper);\n      helper.renderOrder = this.helperRoot.renderOrder;\n    }\n\n    return humanoid;\n  }\n\n  /**\n   * Ensure required bones exist in given human bones.\n   * @param humanBones Human bones\n   * @returns Human bones, no longer partial!\n   */\n  private _ensureRequiredBonesExist(humanBones: Partial<VRMHumanBones>): VRMHumanBones {\n    // ensure required bones exist\n    const missingRequiredBones = Object.values(VRMRequiredHumanBoneName).filter(\n      (requiredBoneName) => humanBones[requiredBoneName] == null,\n    );\n\n    // throw an error if there are missing bones\n    if (missingRequiredBones.length > 0) {\n      throw new Error(\n        `VRMHumanoidLoaderPlugin: These humanoid bones are required but not exist: ${missingRequiredBones.join(', ')}`,\n      );\n    }\n\n    return humanBones as VRMHumanBones;\n  }\n}\n", "import * as THREE from 'three';\nimport { VRMLookAt } from '../VRMLookAt';\nimport { FanBufferGeometry } from './utils/FanBufferGeometry';\nimport { LineAndSphereBufferGeometry } from './utils/LineAndSphereBufferGeometry';\n\nconst _quatA = new THREE.Quaternion();\nconst _quatB = new THREE.Quaternion();\nconst _v3A = new THREE.Vector3();\nconst _v3B = new THREE.Vector3();\n\nconst SQRT_2_OVER_2 = Math.sqrt(2.0) / 2.0;\nconst QUAT_XY_CW90 = new THREE.Quaternion(0, 0, -SQRT_2_OVER_2, SQRT_2_OVER_2);\nconst VEC3_POSITIVE_Y = new THREE.Vector3(0.0, 1.0, 0.0);\n\nexport class VRMLookAtHelper extends THREE.Group {\n  public readonly vrmLookAt: VRMLookAt;\n  private readonly _meshYaw: THREE.Mesh<FanBufferGeometry, THREE.MeshBasicMaterial>;\n  private readonly _meshPitch: THREE.Mesh<FanBufferGeometry, THREE.MeshBasicMaterial>;\n  private readonly _lineTarget: THREE.LineSegments<LineAndSphereBufferGeometry, THREE.LineBasicMaterial>;\n\n  public constructor(lookAt: VRMLookAt) {\n    super();\n    this.matrixAutoUpdate = false;\n\n    this.vrmLookAt = lookAt;\n\n    {\n      const geometry = new FanBufferGeometry();\n      geometry.radius = 0.5;\n\n      const material = new THREE.MeshBasicMaterial({\n        color: 0x00ff00,\n        transparent: true,\n        opacity: 0.5,\n        side: THREE.DoubleSide,\n        depthTest: false,\n        depthWrite: false,\n      });\n\n      this._meshPitch = new THREE.Mesh(geometry, material);\n      this.add(this._meshPitch);\n    }\n\n    {\n      const geometry = new FanBufferGeometry();\n      geometry.radius = 0.5;\n\n      const material = new THREE.MeshBasicMaterial({\n        color: 0xff0000,\n        transparent: true,\n        opacity: 0.5,\n        side: THREE.DoubleSide,\n        depthTest: false,\n        depthWrite: false,\n      });\n\n      this._meshYaw = new THREE.Mesh(geometry, material);\n      this.add(this._meshYaw);\n    }\n\n    {\n      const geometry = new LineAndSphereBufferGeometry();\n      geometry.radius = 0.1;\n\n      const material = new THREE.LineBasicMaterial({\n        color: 0xffffff,\n        depthTest: false,\n        depthWrite: false,\n      });\n\n      this._lineTarget = new THREE.LineSegments(geometry, material);\n      this._lineTarget.frustumCulled = false;\n      this.add(this._lineTarget);\n    }\n  }\n\n  public dispose(): void {\n    this._meshYaw.geometry.dispose();\n    this._meshYaw.material.dispose();\n\n    this._meshPitch.geometry.dispose();\n    this._meshPitch.material.dispose();\n\n    this._lineTarget.geometry.dispose();\n    this._lineTarget.material.dispose();\n  }\n\n  public updateMatrixWorld(force: boolean): void {\n    // update geometries\n    const yaw = THREE.MathUtils.DEG2RAD * this.vrmLookAt.yaw;\n    this._meshYaw.geometry.theta = yaw;\n    this._meshYaw.geometry.update();\n\n    const pitch = THREE.MathUtils.DEG2RAD * this.vrmLookAt.pitch;\n    this._meshPitch.geometry.theta = pitch;\n    this._meshPitch.geometry.update();\n\n    // get world position and quaternion\n    this.vrmLookAt.getLookAtWorldPosition(_v3A);\n    this.vrmLookAt.getLookAtWorldQuaternion(_quatA);\n\n    // calculate rotation using faceFront\n    _quatA.multiply(this.vrmLookAt.getFaceFrontQuaternion(_quatB));\n\n    // set transform to meshes\n    this._meshYaw.position.copy(_v3A);\n    this._meshYaw.quaternion.copy(_quatA);\n\n    this._meshPitch.position.copy(_v3A);\n    this._meshPitch.quaternion.copy(_quatA);\n    this._meshPitch.quaternion.multiply(_quatB.setFromAxisAngle(VEC3_POSITIVE_Y, yaw));\n    this._meshPitch.quaternion.multiply(QUAT_XY_CW90);\n\n    // update target line and sphere\n    const { target, autoUpdate } = this.vrmLookAt;\n    if (target != null && autoUpdate) {\n      target.getWorldPosition(_v3B).sub(_v3A);\n      this._lineTarget.geometry.tail.copy(_v3B);\n      this._lineTarget.geometry.update();\n      this._lineTarget.position.copy(_v3A);\n    }\n\n    // apply transform to meshes\n    super.updateMatrixWorld(force);\n  }\n}\n", "import * as THREE from 'three';\n\nexport class FanBufferGeometry extends THREE.BufferGeometry {\n  public theta: number;\n  public radius: number;\n  private _currentTheta = 0;\n  private _currentRadius = 0;\n  private readonly _attrPos: THREE.BufferAttribute;\n  private readonly _attrIndex: THREE.BufferAttribute;\n\n  public constructor() {\n    super();\n\n    this.theta = 0.0;\n    this.radius = 0.0;\n    this._currentTheta = 0.0;\n    this._currentRadius = 0.0;\n\n    this._attrPos = new THREE.BufferAttribute(new Float32Array(65 * 3), 3);\n    this.setAttribute('position', this._attrPos);\n\n    this._attrIndex = new THREE.BufferAttribute(new Uint16Array(3 * 63), 1);\n    this.setIndex(this._attrIndex);\n\n    this._buildIndex();\n    this.update();\n  }\n\n  public update(): void {\n    let shouldUpdateGeometry = false;\n\n    if (this._currentTheta !== this.theta) {\n      this._currentTheta = this.theta;\n      shouldUpdateGeometry = true;\n    }\n\n    if (this._currentRadius !== this.radius) {\n      this._currentRadius = this.radius;\n      shouldUpdateGeometry = true;\n    }\n\n    if (shouldUpdateGeometry) {\n      this._buildPosition();\n    }\n  }\n\n  private _buildPosition(): void {\n    this._attrPos.setXYZ(0, 0.0, 0.0, 0.0);\n\n    for (let i = 0; i < 64; i++) {\n      const t = (i / 63.0) * this._currentTheta;\n\n      this._attrPos.setXYZ(i + 1, this._currentRadius * Math.sin(t), 0.0, this._currentRadius * Math.cos(t));\n    }\n\n    this._attrPos.needsUpdate = true;\n  }\n\n  private _buildIndex(): void {\n    for (let i = 0; i < 63; i++) {\n      this._attrIndex.setXYZ(i * 3, 0, i + 1, i + 2);\n    }\n\n    this._attrIndex.needsUpdate = true;\n  }\n}\n", "import * as THREE from 'three';\n\nexport class LineAndSphereBufferGeometry extends THREE.BufferGeometry {\n  public radius: number;\n  public tail: THREE.Vector3;\n  private _currentRadius: number;\n  private _currentTail: THREE.Vector3;\n  private readonly _attrPos: THREE.BufferAttribute;\n  private readonly _attrIndex: THREE.BufferAttribute;\n\n  public constructor() {\n    super();\n\n    this.radius = 0.0;\n    this._currentRadius = 0.0;\n\n    this.tail = new THREE.Vector3();\n    this._currentTail = new THREE.Vector3();\n\n    this._attrPos = new THREE.BufferAttribute(new Float32Array(294), 3);\n    this.setAttribute('position', this._attrPos);\n\n    this._attrIndex = new THREE.BufferAttribute(new Uint16Array(194), 1);\n    this.setIndex(this._attrIndex);\n\n    this._buildIndex();\n    this.update();\n  }\n\n  public update(): void {\n    let shouldUpdateGeometry = false;\n\n    if (this._currentRadius !== this.radius) {\n      this._currentRadius = this.radius;\n      shouldUpdateGeometry = true;\n    }\n\n    if (!this._currentTail.equals(this.tail)) {\n      this._currentTail.copy(this.tail);\n      shouldUpdateGeometry = true;\n    }\n\n    if (shouldUpdateGeometry) {\n      this._buildPosition();\n    }\n  }\n\n  private _buildPosition(): void {\n    for (let i = 0; i < 32; i++) {\n      const t = (i / 16.0) * Math.PI;\n\n      this._attrPos.setXYZ(i, Math.cos(t), Math.sin(t), 0.0);\n      this._attrPos.setXYZ(32 + i, 0.0, Math.cos(t), Math.sin(t));\n      this._attrPos.setXYZ(64 + i, Math.sin(t), 0.0, Math.cos(t));\n    }\n\n    this.scale(this._currentRadius, this._currentRadius, this._currentRadius);\n    this.translate(this._currentTail.x, this._currentTail.y, this._currentTail.z);\n\n    this._attrPos.setXYZ(96, 0, 0, 0);\n    this._attrPos.setXYZ(97, this._currentTail.x, this._currentTail.y, this._currentTail.z);\n\n    this._attrPos.needsUpdate = true;\n  }\n\n  private _buildIndex(): void {\n    for (let i = 0; i < 32; i++) {\n      const i1 = (i + 1) % 32;\n\n      this._attrIndex.setXY(i * 2, i, i1);\n      this._attrIndex.setXY(64 + i * 2, 32 + i, 32 + i1);\n      this._attrIndex.setXY(128 + i * 2, 64 + i, 64 + i1);\n    }\n    this._attrIndex.setXY(192, 96, 97);\n\n    this._attrIndex.needsUpdate = true;\n  }\n}\n", "import * as THREE from 'three';\nimport { VRMHumanoid } from '../humanoid';\nimport { getWorldQuaternionLite } from '../utils/getWorldQuaternionLite';\nimport { quatInvertCompat } from '../utils/quatInvertCompat';\nimport { calcAzimuthAltitude } from './utils/calcAzimuthAltitude';\nimport type { VRMLookAtApplier } from './VRMLookAtApplier';\nimport { sanitizeAngle } from './utils/sanitizeAngle';\n\nconst VEC3_POSITIVE_Z = new THREE.Vector3(0.0, 0.0, 1.0);\n\nconst _v3A = new THREE.Vector3();\nconst _v3B = new THREE.Vector3();\nconst _v3C = new THREE.Vector3();\nconst _quatA = new THREE.Quaternion();\nconst _quatB = new THREE.Quaternion();\nconst _quatC = new THREE.Quaternion();\nconst _quatD = new THREE.Quaternion();\nconst _eulerA = new THREE.Euler();\n\n/**\n * A class controls eye gaze movements of a VRM.\n */\nexport class VRMLookAt {\n  public static readonly EULER_ORDER = 'YXZ'; // yaw-pitch-roll\n\n  /**\n   * The origin of LookAt. Position offset from the head bone.\n   */\n  public offsetFromHeadBone = new THREE.Vector3();\n\n  /**\n   * Its associated {@link VRMHumanoid}.\n   */\n  public readonly humanoid: VRMHumanoid;\n\n  /**\n   * The {@link VRMLookAtApplier} of the LookAt.\n   */\n  public applier: VRMLookAtApplier;\n\n  /**\n   * If this is true, the LookAt will be updated automatically by calling {@link update}, towarding the direction to the {@link target}.\n   * `true` by default.\n   *\n   * See also: {@link target}\n   */\n  public autoUpdate = true;\n\n  /**\n   * The target object of the LookAt.\n   * Note that it does not make any sense if {@link autoUpdate} is disabled.\n   *\n   * See also: {@link autoUpdate}\n   */\n  public target?: THREE.Object3D | null;\n\n  /**\n   * The front direction of the face.\n   * Intended to be used for VRM 0.0 compat (VRM 0.0 models are facing Z- instead of Z+).\n   * You usually don't want to touch this.\n   */\n  public faceFront = new THREE.Vector3(0.0, 0.0, 1.0);\n\n  /**\n   * Its current angle around Y axis, in degree.\n   */\n  protected _yaw: number;\n\n  /**\n   * Its current angle around Y axis, in degree.\n   */\n  public get yaw(): number {\n    return this._yaw;\n  }\n\n  /**\n   * Its current angle around Y axis, in degree.\n   */\n  public set yaw(value: number) {\n    this._yaw = value;\n    this._needsUpdate = true;\n  }\n\n  /**\n   * Its current angle around X axis, in degree.\n   */\n  protected _pitch: number;\n\n  /**\n   * Its current angle around X axis, in degree.\n   */\n  public get pitch(): number {\n    return this._pitch;\n  }\n\n  /**\n   * Its current angle around X axis, in degree.\n   */\n  public set pitch(value: number) {\n    this._pitch = value;\n    this._needsUpdate = true;\n  }\n\n  /**\n   * Specifies that angles need to be applied to its [@link applier].\n   */\n  protected _needsUpdate: boolean;\n\n  /**\n   * World rotation of the head in its rest pose.\n   */\n  private _restHeadWorldQuaternion: THREE.Quaternion;\n\n  /**\n   * @deprecated Use {@link getEuler} instead.\n   */\n  public get euler(): THREE.Euler {\n    console.warn('VRMLookAt: euler is deprecated. use getEuler() instead.');\n\n    return this.getEuler(new THREE.Euler());\n  }\n\n  /**\n   * Create a new {@link VRMLookAt}.\n   *\n   * @param humanoid A {@link VRMHumanoid}\n   * @param applier A {@link VRMLookAtApplier}\n   */\n  public constructor(humanoid: VRMHumanoid, applier: VRMLookAtApplier) {\n    this.humanoid = humanoid;\n    this.applier = applier;\n\n    this._yaw = 0.0;\n    this._pitch = 0.0;\n    this._needsUpdate = true;\n\n    this._restHeadWorldQuaternion = this.getLookAtWorldQuaternion(new THREE.Quaternion());\n  }\n\n  /**\n   * Get its yaw-pitch angles as an `Euler`.\n   * Does NOT consider {@link faceFront}; it returns `Euler(0, 0, 0; \"YXZ\")` by default regardless of the faceFront value.\n   *\n   * @param target The target euler\n   */\n  public getEuler(target: THREE.Euler): THREE.Euler {\n    return target.set(THREE.MathUtils.DEG2RAD * this._pitch, THREE.MathUtils.DEG2RAD * this._yaw, 0.0, 'YXZ');\n  }\n\n  /**\n   * Copy the given {@link VRMLookAt} into this one.\n   * {@link humanoid} must be same as the source one.\n   * {@link applier} will reference the same instance as the source one.\n   * @param source The {@link VRMLookAt} you want to copy\n   * @returns this\n   */\n  public copy(source: VRMLookAt): this {\n    if (this.humanoid !== source.humanoid) {\n      throw new Error('VRMLookAt: humanoid must be same in order to copy');\n    }\n\n    this.offsetFromHeadBone.copy(source.offsetFromHeadBone);\n    this.applier = source.applier;\n    this.autoUpdate = source.autoUpdate;\n    this.target = source.target;\n    this.faceFront.copy(source.faceFront);\n\n    return this;\n  }\n\n  /**\n   * Returns a clone of this {@link VRMLookAt}.\n   * Note that {@link humanoid} and {@link applier} will reference the same instance as this one.\n   * @returns Copied {@link VRMLookAt}\n   */\n  public clone(): VRMLookAt {\n    return new VRMLookAt(this.humanoid, this.applier).copy(this);\n  }\n\n  /**\n   * Reset the lookAt direction (yaw and pitch) to the initial direction.\n   */\n  public reset(): void {\n    this._yaw = 0.0;\n    this._pitch = 0.0;\n    this._needsUpdate = true;\n  }\n\n  /**\n   * Get its lookAt position in world coordinate.\n   *\n   * @param target A target `THREE.Vector3`\n   */\n  public getLookAtWorldPosition(target: THREE.Vector3): THREE.Vector3 {\n    const head = this.humanoid.getRawBoneNode('head')!;\n\n    return target.copy(this.offsetFromHeadBone).applyMatrix4(head.matrixWorld);\n  }\n\n  /**\n   * Get its lookAt rotation in world coordinate.\n   * Does NOT consider {@link faceFront}.\n   *\n   * @param target A target `THREE.Quaternion`\n   */\n  public getLookAtWorldQuaternion(target: THREE.Quaternion): THREE.Quaternion {\n    const head = this.humanoid.getRawBoneNode('head')!;\n\n    return getWorldQuaternionLite(head, target);\n  }\n\n  /**\n   * Get a quaternion that rotates the +Z unit vector of the humanoid Head to the {@link faceFront} direction.\n   *\n   * @param target A target `THREE.Quaternion`\n   */\n  public getFaceFrontQuaternion(target: THREE.Quaternion): THREE.Quaternion {\n    if (this.faceFront.distanceToSquared(VEC3_POSITIVE_Z) < 0.01) {\n      return target.copy(this._restHeadWorldQuaternion).invert();\n    }\n\n    const [faceFrontAzimuth, faceFrontAltitude] = calcAzimuthAltitude(this.faceFront);\n    _eulerA.set(0.0, 0.5 * Math.PI + faceFrontAzimuth, faceFrontAltitude, 'YZX');\n\n    return target.setFromEuler(_eulerA).premultiply(_quatD.copy(this._restHeadWorldQuaternion).invert());\n  }\n\n  /**\n   * Get its LookAt direction in world coordinate.\n   *\n   * @param target A target `THREE.Vector3`\n   */\n  public getLookAtWorldDirection(target: THREE.Vector3): THREE.Vector3 {\n    this.getLookAtWorldQuaternion(_quatB);\n    this.getFaceFrontQuaternion(_quatC);\n\n    return target\n      .copy(VEC3_POSITIVE_Z)\n      .applyQuaternion(_quatB)\n      .applyQuaternion(_quatC)\n      .applyEuler(this.getEuler(_eulerA));\n  }\n\n  /**\n   * Set its lookAt target position.\n   *\n   * Note that its result will be instantly overwritten if {@link VRMLookAtHead.autoUpdate} is enabled.\n   *\n   * If you want to track an object continuously, you might want to use {@link target} instead.\n   *\n   * @param position A target position, in world space\n   */\n  public lookAt(position: THREE.Vector3): void {\n    // Look at direction in local coordinate\n    const headRotDiffInv = _quatA\n      .copy(this._restHeadWorldQuaternion)\n      .multiply(quatInvertCompat(this.getLookAtWorldQuaternion(_quatB)));\n    const headPos = this.getLookAtWorldPosition(_v3B);\n    const lookAtDir = _v3C.copy(position).sub(headPos).applyQuaternion(headRotDiffInv).normalize();\n\n    // calculate angles\n    const [azimuthFrom, altitudeFrom] = calcAzimuthAltitude(this.faceFront);\n    const [azimuthTo, altitudeTo] = calcAzimuthAltitude(lookAtDir);\n    const yaw = sanitizeAngle(azimuthTo - azimuthFrom);\n    const pitch = sanitizeAngle(altitudeFrom - altitudeTo); // spinning (1, 0, 0) CCW around Z axis makes the vector look up, while spinning (0, 0, 1) CCW around X axis makes the vector look down\n\n    // apply angles\n    this._yaw = THREE.MathUtils.RAD2DEG * yaw;\n    this._pitch = THREE.MathUtils.RAD2DEG * pitch;\n\n    this._needsUpdate = true;\n  }\n\n  /**\n   * Update the VRMLookAtHead.\n   * If {@link autoUpdate} is enabled, this will make it look at the {@link target}.\n   *\n   * @param delta deltaTime, it isn't used though. You can use the parameter if you want to use this in your own extended {@link VRMLookAt}.\n   */\n  public update(delta: number): void {\n    if (this.target != null && this.autoUpdate) {\n      this.lookAt(this.target.getWorldPosition(_v3A));\n    }\n\n    if (this._needsUpdate) {\n      this._needsUpdate = false;\n\n      this.applier.applyYawPitch(this._yaw, this._pitch);\n    }\n  }\n}\n", "import * as THREE from 'three';\n\nconst _position = new THREE.Vector3();\nconst _scale = new THREE.Vector3();\n\n/**\n * A replacement of `Object3D.getWorldQuaternion`.\n * Extract the world quaternion of an object from its world space matrix, without calling `Object3D.updateWorldMatrix`.\n * Use this when you're sure that the world matrix is up-to-date.\n *\n * @param object The object\n * @param out A target quaternion\n */\nexport function getWorldQuaternionLite(object: THREE.Object3D, out: THREE.Quaternion): THREE.Quaternion {\n  object.matrixWorld.decompose(_position, out, _scale);\n  return out;\n}\n", "import * as THREE from 'three';\n\n/**\n * Calculate azimuth / altitude angles from a vector.\n *\n * This returns a difference of angles from (1, 0, 0).\n * Azimuth represents an angle around Y axis.\n * Altitude represents an angle around Z axis.\n * It is rotated in intrinsic Y-Z order.\n *\n * @param vector The vector\n * @returns A tuple contains two angles, `[ azimuth, altitude ]`\n */\nexport function calcAzimuthAltitude(vector: THREE.Vector3): [azimuth: number, altitude: number] {\n  return [Math.atan2(-vector.z, vector.x), Math.atan2(vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z))];\n}\n", "/**\n * Make sure the angle is within -PI to PI.\n *\n * @example\n * ```js\n * sanitizeAngle(1.5 * Math.PI) // -0.5 * PI\n * ```\n *\n * @param angle An input angle\n */\nexport function sanitizeAngle(angle: number): number {\n  const roundTurn = Math.round(angle / 2.0 / Math.PI);\n  return angle - 2.0 * Math.PI * roundTurn;\n}\n", "import { VRMHumanoid } from '../humanoid';\nimport * as THREE from 'three';\nimport type { VRMLookAtApplier } from './VRMLookAtApplier';\nimport { VRMLookAtRangeMap } from './VRMLookAtRangeMap';\nimport { calcAzimuthAltitude } from './utils/calcAzimuthAltitude';\nimport { getWorldQuaternionLite } from '../utils/getWorldQuaternionLite';\n\nconst VEC3_POSITIVE_Z = new THREE.Vector3(0.0, 0.0, 1.0);\n\nconst _quatA = new THREE.Quaternion();\nconst _quatB = new THREE.Quaternion();\nconst _eulerA = new THREE.Euler(0.0, 0.0, 0.0, 'YXZ');\n\n/**\n * A class that applies eye gaze directions to a VRM.\n * It will be used by {@link VRMLookAt}.\n */\nexport class VRMLookAtBoneApplier implements VRMLookAtApplier {\n  /**\n   * Represent its type of applier.\n   */\n  public static readonly type = 'bone';\n\n  /**\n   * Its associated {@link VRMHumanoid}.\n   */\n  public readonly humanoid: VRMHumanoid;\n\n  /**\n   * A {@link VRMLookAtRangeMap} for horizontal inward movement. The left eye moves right. The right eye moves left.\n   */\n  public rangeMapHorizontalInner: VRMLookAtRangeMap;\n\n  /**\n   * A {@link VRMLookAtRangeMap} for horizontal outward movement. The left eye moves left. The right eye moves right.\n   */\n  public rangeMapHorizontalOuter: VRMLookAtRangeMap;\n\n  /**\n   * A {@link VRMLookAtRangeMap} for vertical downward movement. Both eyes move upwards.\n   */\n  public rangeMapVerticalDown: VRMLookAtRangeMap;\n\n  /**\n   * A {@link VRMLookAtRangeMap} for vertical upward movement. Both eyes move downwards.\n   */\n  public rangeMapVerticalUp: VRMLookAtRangeMap;\n\n  /**\n   * The front direction of the face.\n   * Intended to be used for VRM 0.0 compat (VRM 0.0 models are facing Z- instead of Z+).\n   * You usually don't want to touch this.\n   */\n  public faceFront: THREE.Vector3;\n\n  /**\n   * The rest quaternion of LeftEye bone.\n   */\n  private _restQuatLeftEye: THREE.Quaternion;\n\n  /**\n   * The rest quaternion of RightEye bone.\n   */\n  private _restQuatRightEye: THREE.Quaternion;\n\n  /**\n   * The world-space rest quaternion of the parent of the humanoid LeftEye.\n   */\n  private _restLeftEyeParentWorldQuat: THREE.Quaternion;\n\n  /**\n   * The world-space rest quaternion of the parent of the humanoid RightEye.\n   */\n  private _restRightEyeParentWorldQuat: THREE.Quaternion;\n\n  /**\n   * Create a new {@link VRMLookAtBoneApplier}.\n   *\n   * @param humanoid A {@link VRMHumanoid}\n   * @param rangeMapHorizontalInner A {@link VRMLookAtRangeMap} used for inner transverse direction\n   * @param rangeMapHorizontalOuter A {@link VRMLookAtRangeMap} used for outer transverse direction\n   * @param rangeMapVerticalDown A {@link VRMLookAtRangeMap} used for down direction\n   * @param rangeMapVerticalUp A {@link VRMLookAtRangeMap} used for up direction\n   */\n  public constructor(\n    humanoid: VRMHumanoid,\n    rangeMapHorizontalInner: VRMLookAtRangeMap,\n    rangeMapHorizontalOuter: VRMLookAtRangeMap,\n    rangeMapVerticalDown: VRMLookAtRangeMap,\n    rangeMapVerticalUp: VRMLookAtRangeMap,\n  ) {\n    this.humanoid = humanoid;\n\n    this.rangeMapHorizontalInner = rangeMapHorizontalInner;\n    this.rangeMapHorizontalOuter = rangeMapHorizontalOuter;\n    this.rangeMapVerticalDown = rangeMapVerticalDown;\n    this.rangeMapVerticalUp = rangeMapVerticalUp;\n\n    this.faceFront = new THREE.Vector3(0.0, 0.0, 1.0);\n\n    // set rest quaternions\n    this._restQuatLeftEye = new THREE.Quaternion();\n    this._restQuatRightEye = new THREE.Quaternion();\n    this._restLeftEyeParentWorldQuat = new THREE.Quaternion();\n    this._restRightEyeParentWorldQuat = new THREE.Quaternion();\n\n    const leftEye = this.humanoid.getRawBoneNode('leftEye');\n    const rightEye = this.humanoid.getRawBoneNode('rightEye');\n\n    if (leftEye) {\n      this._restQuatLeftEye.copy(leftEye.quaternion);\n      getWorldQuaternionLite(leftEye.parent!, this._restLeftEyeParentWorldQuat);\n    }\n\n    if (rightEye) {\n      this._restQuatRightEye.copy(rightEye.quaternion);\n      getWorldQuaternionLite(rightEye.parent!, this._restRightEyeParentWorldQuat);\n    }\n  }\n\n  /**\n   * Apply the input angle to its associated VRM model.\n   *\n   * @param yaw Rotation around Y axis, in degree\n   * @param pitch Rotation around X axis, in degree\n   */\n  public applyYawPitch(yaw: number, pitch: number): void {\n    const leftEye = this.humanoid.getRawBoneNode('leftEye');\n    const rightEye = this.humanoid.getRawBoneNode('rightEye');\n    const leftEyeNormalized = this.humanoid.getNormalizedBoneNode('leftEye');\n    const rightEyeNormalized = this.humanoid.getNormalizedBoneNode('rightEye');\n    // left\n    if (leftEye) {\n      if (pitch < 0.0) {\n        _eulerA.x = -THREE.MathUtils.DEG2RAD * this.rangeMapVerticalDown.map(-pitch);\n      } else {\n        _eulerA.x = THREE.MathUtils.DEG2RAD * this.rangeMapVerticalUp.map(pitch);\n      }\n\n      if (yaw < 0.0) {\n        _eulerA.y = -THREE.MathUtils.DEG2RAD * this.rangeMapHorizontalInner.map(-yaw);\n      } else {\n        _eulerA.y = THREE.MathUtils.DEG2RAD * this.rangeMapHorizontalOuter.map(yaw);\n      }\n\n      _quatA.setFromEuler(_eulerA);\n      this._getWorldFaceFrontQuat(_quatB);\n\n      // _quatB * _quatA * _quatB^-1\n      // where _quatA is LookAt rotation\n      // and _quatB is worldFaceFrontQuat\n      leftEyeNormalized!.quaternion.copy(_quatB).multiply(_quatA).multiply(_quatB.invert());\n\n      _quatA.copy(this._restLeftEyeParentWorldQuat);\n\n      // _quatA^-1 * leftEyeNormalized.quaternion * _quatA * restQuatLeftEye\n      // where _quatA is restLeftEyeParentWorldQuat\n      leftEye.quaternion\n        .copy(leftEyeNormalized!.quaternion)\n        .multiply(_quatA)\n        .premultiply(_quatA.invert())\n        .multiply(this._restQuatLeftEye);\n    }\n\n    // right\n    if (rightEye) {\n      if (pitch < 0.0) {\n        _eulerA.x = -THREE.MathUtils.DEG2RAD * this.rangeMapVerticalDown.map(-pitch);\n      } else {\n        _eulerA.x = THREE.MathUtils.DEG2RAD * this.rangeMapVerticalUp.map(pitch);\n      }\n\n      if (yaw < 0.0) {\n        _eulerA.y = -THREE.MathUtils.DEG2RAD * this.rangeMapHorizontalOuter.map(-yaw);\n      } else {\n        _eulerA.y = THREE.MathUtils.DEG2RAD * this.rangeMapHorizontalInner.map(yaw);\n      }\n\n      _quatA.setFromEuler(_eulerA);\n      this._getWorldFaceFrontQuat(_quatB);\n\n      // _quatB * _quatA * _quatB^-1\n      // where _quatA is LookAt rotation\n      // and _quatB is worldFaceFrontQuat\n      rightEyeNormalized!.quaternion.copy(_quatB).multiply(_quatA).multiply(_quatB.invert());\n\n      _quatA.copy(this._restRightEyeParentWorldQuat);\n\n      // _quatA^-1 * rightEyeNormalized.quaternion * _quatA * restQuatRightEye\n      // where _quatA is restRightEyeParentWorldQuat\n      rightEye.quaternion\n        .copy(rightEyeNormalized!.quaternion)\n        .multiply(_quatA)\n        .premultiply(_quatA.invert())\n        .multiply(this._restQuatRightEye);\n    }\n  }\n\n  /**\n   * @deprecated Use {@link applyYawPitch} instead.\n   */\n  public lookAt(euler: THREE.Euler): void {\n    console.warn('VRMLookAtBoneApplier: lookAt() is deprecated. use apply() instead.');\n\n    const yaw = THREE.MathUtils.RAD2DEG * euler.y;\n    const pitch = THREE.MathUtils.RAD2DEG * euler.x;\n\n    this.applyYawPitch(yaw, pitch);\n  }\n\n  /**\n   * Get a quaternion that rotates the world-space +Z unit vector to the {@link faceFront} direction.\n   *\n   * @param target A target `THREE.Quaternion`\n   */\n  private _getWorldFaceFrontQuat(target: THREE.Quaternion): THREE.Quaternion {\n    if (this.faceFront.distanceToSquared(VEC3_POSITIVE_Z) < 0.01) {\n      return target.identity();\n    }\n\n    const [faceFrontAzimuth, faceFrontAltitude] = calcAzimuthAltitude(this.faceFront);\n    _eulerA.set(0.0, 0.5 * Math.PI + faceFrontAzimuth, faceFrontAltitude, 'YZX');\n\n    return target.setFromEuler(_eulerA);\n  }\n}\n", "import { VRMExpressionManager } from '../expressions';\nimport * as THREE from 'three';\nimport type { VRMLookAtApplier } from './VRMLookAtApplier';\nimport { VRMLookAtRangeMap } from './VRMLookAtRangeMap';\n\n/**\n * A class that applies eye gaze directions to a VRM.\n * It will be used by {@link VRMLookAt}.\n */\nexport class VRMLookAtExpressionApplier implements VRMLookAtApplier {\n  /**\n   * Represent its type of applier.\n   */\n  public static readonly type = 'expression';\n\n  /**\n   * Its associated {@link VRMExpressionManager}.\n   */\n  public readonly expressions: VRMExpressionManager;\n\n  /**\n   * It won't be used in expression applier.\n   * See also: {@link rangeMapHorizontalOuter}\n   */\n  public rangeMapHorizontalInner: VRMLookAtRangeMap;\n\n  /**\n   * A {@link VRMLookAtRangeMap} for horizontal movement. Both eyes move left or right.\n   */\n  public rangeMapHorizontalOuter: VRMLookAtRangeMap;\n\n  /**\n   * A {@link VRMLookAtRangeMap} for vertical downward movement. Both eyes move upwards.\n   */\n  public rangeMapVerticalDown: VRMLookAtRangeMap;\n\n  /**\n   * A {@link VRMLookAtRangeMap} for vertical upward movement. Both eyes move downwards.\n   */\n  public rangeMapVerticalUp: VRMLookAtRangeMap;\n\n  /**\n   * Create a new {@link VRMLookAtExpressionApplier}.\n   *\n   * @param expressions A {@link VRMExpressionManager}\n   * @param rangeMapHorizontalInner A {@link VRMLookAtRangeMap} used for inner transverse direction\n   * @param rangeMapHorizontalOuter A {@link VRMLookAtRangeMap} used for outer transverse direction\n   * @param rangeMapVerticalDown A {@link VRMLookAtRangeMap} used for down direction\n   * @param rangeMapVerticalUp A {@link VRMLookAtRangeMap} used for up direction\n   */\n  public constructor(\n    expressions: VRMExpressionManager,\n    rangeMapHorizontalInner: VRMLookAtRangeMap,\n    rangeMapHorizontalOuter: VRMLookAtRangeMap,\n    rangeMapVerticalDown: VRMLookAtRangeMap,\n    rangeMapVerticalUp: VRMLookAtRangeMap,\n  ) {\n    this.expressions = expressions;\n\n    this.rangeMapHorizontalInner = rangeMapHorizontalInner;\n    this.rangeMapHorizontalOuter = rangeMapHorizontalOuter;\n    this.rangeMapVerticalDown = rangeMapVerticalDown;\n    this.rangeMapVerticalUp = rangeMapVerticalUp;\n  }\n\n  /**\n   * Apply the input angle to its associated VRM model.\n   *\n   * @param yaw Rotation around Y axis, in degree\n   * @param pitch Rotation around X axis, in degree\n   */\n  public applyYawPitch(yaw: number, pitch: number): void {\n    if (pitch < 0.0) {\n      this.expressions.setValue('lookDown', 0.0);\n      this.expressions.setValue('lookUp', this.rangeMapVerticalUp.map(-pitch));\n    } else {\n      this.expressions.setValue('lookUp', 0.0);\n      this.expressions.setValue('lookDown', this.rangeMapVerticalDown.map(pitch));\n    }\n\n    if (yaw < 0.0) {\n      this.expressions.setValue('lookLeft', 0.0);\n      this.expressions.setValue('lookRight', this.rangeMapHorizontalOuter.map(-yaw));\n    } else {\n      this.expressions.setValue('lookRight', 0.0);\n      this.expressions.setValue('lookLeft', this.rangeMapHorizontalOuter.map(yaw));\n    }\n  }\n\n  /**\n   * @deprecated Use {@link applyYawPitch} instead.\n   */\n  public lookAt(euler: THREE.Euler): void {\n    console.warn('VRMLookAtBoneApplier: lookAt() is deprecated. use apply() instead.');\n\n    const yaw = THREE.MathUtils.RAD2DEG * euler.y;\n    const pitch = THREE.MathUtils.RAD2DEG * euler.x;\n\n    this.applyYawPitch(yaw, pitch);\n  }\n}\n", "import { saturate } from '../utils/saturate';\n\nexport class VRMLookAtRangeMap {\n  /**\n   * Limits the maximum angle of the input angle of the LookAt vector from the front of the head (the positive z axis).\n   */\n  public inputMaxValue: number;\n\n  /**\n   * Represents an angle (in degrees) for bone type of LookAt appliers, or a weight for expression type of LookAt appliers.\n   * The input value will take `1.0` when the input angle equals (or greater) to {@link inputMaxValue}.\n   */\n  public outputScale: number;\n\n  /**\n   * Create a new {@link VRMLookAtRangeMap}.\n   *\n   * @param inputMaxValue The {@link inputMaxValue} of the map\n   * @param outputScale The {@link outputScale} of the map\n   */\n  public constructor(inputMaxValue: number, outputScale: number) {\n    this.inputMaxValue = inputMaxValue;\n    this.outputScale = outputScale;\n  }\n\n  /**\n   * Evaluate an input value and output a mapped value.\n   * @param src The input value\n   */\n  public map(src: number): number {\n    return this.outputScale * saturate(src / this.inputMaxValue);\n  }\n}\n", "import type * as THREE from 'three';\nimport type * as V0VRM from '@pixiv/types-vrm-0.0';\nimport type * as V1VRMSchema from '@pixiv/types-vrmc-vrm-1.0';\nimport type { GLTF, GLTFLoaderPlugin, GLTFParser } from 'three/examples/jsm/loaders/GLTFLoader.js';\nimport type { VRMExpressionManager } from '../expressions/VRMExpressionManager';\nimport type { VRMHumanoid } from '../humanoid/VRMHumanoid';\nimport { VRMLookAtHelper } from './helpers/VRMLookAtHelper';\nimport { VRMLookAt } from './VRMLookAt';\nimport type { VRMLookAtApplier } from './VRMLookAtApplier';\nimport { VRMLookAtBoneApplier } from './VRMLookAtBoneApplier';\nimport { VRMLookAtExpressionApplier } from './VRMLookAtExpressionApplier';\nimport type { VRMLookAtLoaderPluginOptions } from './VRMLookAtLoaderPluginOptions';\nimport { VRMLookAtRangeMap } from './VRMLookAtRangeMap';\nimport { GLTF as GLTFSchema } from '@gltf-transform/core';\n\n/**\n * Possible spec versions it recognizes.\n */\nconst POSSIBLE_SPEC_VERSIONS = new Set(['1.0', '1.0-beta']);\n\n/**\n * The minimum permitted value for {@link V1VRMSchema.LookAtRangeMap.inputMaxValue}.\n * If the given value is smaller than this, the loader shows a warning and clamps up the value.\n */\nconst INPUT_MAX_VALUE_MINIMUM = 0.01;\n\n/**\n * A plugin of GLTFLoader that imports a {@link VRMLookAt} from a VRM extension of a GLTF.\n */\nexport class VRMLookAtLoaderPlugin implements GLTFLoaderPlugin {\n  /**\n   * Specify an Object3D to add {@link VRMLookAtHelper} s.\n   * If not specified, helper will not be created.\n   * If `renderOrder` is set to the root, helpers will copy the same `renderOrder` .\n   */\n  public helperRoot?: THREE.Object3D;\n\n  public readonly parser: GLTFParser;\n\n  public get name(): string {\n    // We should use the extension name instead but we have multiple plugins for an extension...\n    return 'VRMLookAtLoaderPlugin';\n  }\n\n  public constructor(parser: GLTFParser, options?: VRMLookAtLoaderPluginOptions) {\n    this.parser = parser;\n\n    this.helperRoot = options?.helperRoot;\n  }\n\n  public async afterRoot(gltf: GLTF): Promise<void> {\n    const vrmHumanoid = gltf.userData.vrmHumanoid as VRMHumanoid | undefined;\n\n    // explicitly distinguish null and undefined\n    // since vrmHumanoid might be null as a result\n    if (vrmHumanoid === null) {\n      return;\n    } else if (vrmHumanoid === undefined) {\n      throw new Error('VRMLookAtLoaderPlugin: vrmHumanoid is undefined. VRMHumanoidLoaderPlugin have to be used first');\n    }\n\n    const vrmExpressionManager = gltf.userData.vrmExpressionManager as VRMExpressionManager | undefined;\n\n    if (vrmExpressionManager === null) {\n      return;\n    } else if (vrmExpressionManager === undefined) {\n      throw new Error(\n        'VRMLookAtLoaderPlugin: vrmExpressionManager is undefined. VRMExpressionLoaderPlugin have to be used first',\n      );\n    }\n\n    gltf.userData.vrmLookAt = await this._import(gltf, vrmHumanoid, vrmExpressionManager);\n  }\n\n  /**\n   * Import a {@link VRMLookAt} from a VRM.\n   *\n   * @param gltf A parsed result of GLTF taken from GLTFLoader\n   * @param humanoid A {@link VRMHumanoid} instance that represents the VRM\n   * @param expressions A {@link VRMExpressionManager} instance that represents the VRM\n   */\n  private async _import(\n    gltf: GLTF,\n    humanoid: VRMHumanoid | null,\n    expressions: VRMExpressionManager | null,\n  ): Promise<VRMLookAt | null> {\n    if (humanoid == null || expressions == null) {\n      return null;\n    }\n\n    const v1Result = await this._v1Import(gltf, humanoid, expressions);\n    if (v1Result) {\n      return v1Result;\n    }\n\n    const v0Result = await this._v0Import(gltf, humanoid, expressions);\n    if (v0Result) {\n      return v0Result;\n    }\n\n    return null;\n  }\n\n  private async _v1Import(\n    gltf: GLTF,\n    humanoid: VRMHumanoid,\n    expressions: VRMExpressionManager,\n  ): Promise<VRMLookAt | null> {\n    const json = this.parser.json as GLTFSchema.IGLTF;\n\n    // early abort if it doesn't use vrm\n    const isVRMUsed = json.extensionsUsed?.indexOf('VRMC_vrm') !== -1;\n    if (!isVRMUsed) {\n      return null;\n    }\n\n    const extension = json.extensions?.['VRMC_vrm'] as V1VRMSchema.VRMCVRM | undefined;\n    if (!extension) {\n      return null;\n    }\n\n    const specVersion = extension.specVersion;\n    if (!POSSIBLE_SPEC_VERSIONS.has(specVersion)) {\n      console.warn(`VRMLookAtLoaderPlugin: Unknown VRMC_vrm specVersion \"${specVersion}\"`);\n      return null;\n    }\n\n    const schemaLookAt = extension.lookAt;\n    if (!schemaLookAt) {\n      return null;\n    }\n\n    const defaultOutputScale = schemaLookAt.type === 'expression' ? 1.0 : 10.0;\n\n    const mapHI = this._v1ImportRangeMap(schemaLookAt.rangeMapHorizontalInner, defaultOutputScale);\n    const mapHO = this._v1ImportRangeMap(schemaLookAt.rangeMapHorizontalOuter, defaultOutputScale);\n    const mapVD = this._v1ImportRangeMap(schemaLookAt.rangeMapVerticalDown, defaultOutputScale);\n    const mapVU = this._v1ImportRangeMap(schemaLookAt.rangeMapVerticalUp, defaultOutputScale);\n\n    let applier;\n\n    if (schemaLookAt.type === 'expression') {\n      applier = new VRMLookAtExpressionApplier(expressions, mapHI, mapHO, mapVD, mapVU);\n    } else {\n      applier = new VRMLookAtBoneApplier(humanoid, mapHI, mapHO, mapVD, mapVU);\n    }\n\n    const lookAt = this._importLookAt(humanoid, applier);\n\n    lookAt.offsetFromHeadBone.fromArray(schemaLookAt.offsetFromHeadBone ?? [0.0, 0.06, 0.0]);\n\n    return lookAt;\n  }\n\n  private _v1ImportRangeMap(\n    schemaRangeMap: V1VRMSchema.LookAtRangeMap | undefined,\n    defaultOutputScale: number,\n  ): VRMLookAtRangeMap {\n    let inputMaxValue = schemaRangeMap?.inputMaxValue ?? 90.0;\n    const outputScale = schemaRangeMap?.outputScale ?? defaultOutputScale;\n\n    // It might cause NaN when `inputMaxValue` is too small\n    // which makes the mesh of the head disappear\n    // See: https://github.com/pixiv/three-vrm/issues/1201\n    if (inputMaxValue < INPUT_MAX_VALUE_MINIMUM) {\n      console.warn(\n        'VRMLookAtLoaderPlugin: inputMaxValue of a range map is too small. Consider reviewing the range map!',\n      );\n      inputMaxValue = INPUT_MAX_VALUE_MINIMUM;\n    }\n\n    return new VRMLookAtRangeMap(inputMaxValue, outputScale);\n  }\n\n  private async _v0Import(\n    gltf: GLTF,\n    humanoid: VRMHumanoid,\n    expressions: VRMExpressionManager,\n  ): Promise<VRMLookAt | null> {\n    const json = this.parser.json as GLTFSchema.IGLTF;\n\n    // early abort if it doesn't use vrm\n    const vrmExt = json.extensions?.VRM as V0VRM.VRM | undefined;\n    if (!vrmExt) {\n      return null;\n    }\n\n    const schemaFirstPerson = vrmExt.firstPerson;\n    if (!schemaFirstPerson) {\n      return null;\n    }\n\n    const defaultOutputScale = schemaFirstPerson.lookAtTypeName === 'BlendShape' ? 1.0 : 10.0;\n\n    const mapHI = this._v0ImportDegreeMap(schemaFirstPerson.lookAtHorizontalInner, defaultOutputScale);\n    const mapHO = this._v0ImportDegreeMap(schemaFirstPerson.lookAtHorizontalOuter, defaultOutputScale);\n    const mapVD = this._v0ImportDegreeMap(schemaFirstPerson.lookAtVerticalDown, defaultOutputScale);\n    const mapVU = this._v0ImportDegreeMap(schemaFirstPerson.lookAtVerticalUp, defaultOutputScale);\n\n    let applier;\n\n    if (schemaFirstPerson.lookAtTypeName === 'BlendShape') {\n      applier = new VRMLookAtExpressionApplier(expressions, mapHI, mapHO, mapVD, mapVU);\n    } else {\n      applier = new VRMLookAtBoneApplier(humanoid, mapHI, mapHO, mapVD, mapVU);\n    }\n\n    const lookAt = this._importLookAt(humanoid, applier);\n\n    if (schemaFirstPerson.firstPersonBoneOffset) {\n      lookAt.offsetFromHeadBone.set(\n        schemaFirstPerson.firstPersonBoneOffset.x ?? 0.0,\n        schemaFirstPerson.firstPersonBoneOffset.y ?? 0.06,\n        -(schemaFirstPerson.firstPersonBoneOffset.z ?? 0.0),\n      );\n    } else {\n      lookAt.offsetFromHeadBone.set(0.0, 0.06, 0.0);\n    }\n\n    // VRM 0.0 are facing Z- instead of Z+\n    lookAt.faceFront.set(0.0, 0.0, -1.0);\n\n    if (applier instanceof VRMLookAtBoneApplier) {\n      applier.faceFront.set(0.0, 0.0, -1.0);\n    }\n\n    return lookAt;\n  }\n\n  private _v0ImportDegreeMap(\n    schemaDegreeMap: V0VRM.FirstPersonDegreeMap | undefined,\n    defaultOutputScale: number,\n  ): VRMLookAtRangeMap {\n    const curve = schemaDegreeMap?.curve;\n    if (JSON.stringify(curve) !== '[0,0,0,1,1,1,1,0]') {\n      console.warn('Curves of LookAtDegreeMap defined in VRM 0.0 are not supported');\n    }\n\n    let xRange = schemaDegreeMap?.xRange ?? 90.0;\n    const yRange = schemaDegreeMap?.yRange ?? defaultOutputScale;\n\n    // It might cause NaN when `xRange` is too small\n    // which makes the mesh of the head disappear\n    // See: https://github.com/pixiv/three-vrm/issues/1201\n    if (xRange < INPUT_MAX_VALUE_MINIMUM) {\n      console.warn('VRMLookAtLoaderPlugin: xRange of a degree map is too small. Consider reviewing the degree map!');\n      xRange = INPUT_MAX_VALUE_MINIMUM;\n    }\n\n    return new VRMLookAtRangeMap(xRange, yRange);\n  }\n\n  private _importLookAt(humanoid: VRMHumanoid, applier: VRMLookAtApplier): VRMLookAt {\n    const lookAt = new VRMLookAt(humanoid, applier);\n\n    if (this.helperRoot) {\n      const helper = new VRMLookAtHelper(lookAt);\n      this.helperRoot.add(helper);\n      helper.renderOrder = this.helperRoot.renderOrder;\n    }\n\n    return lookAt;\n  }\n}\n", "/* eslint-disable @typescript-eslint/naming-convention */\n\n/**\n * Represents a type of applier.\n */\nexport const VRMLookAtTypeName = {\n  Bone: 'bone',\n  Expression: 'expression',\n};\n\nexport type VRMLookAtTypeName = (typeof VRMLookAtTypeName)[keyof typeof VRMLookAtTypeName];\n", "import type { GLTF, GLTFLoaderPlugin, GLTFParser } from 'three/examples/jsm/loaders/GLTFLoader.js';\nimport type { VRM0Meta } from './VRM0Meta';\nimport type { VRM1Meta } from './VRM1Meta';\nimport type { VRMMeta } from './VRMMeta';\nimport type { VRMMetaLoaderPluginOptions } from './VRMMetaLoaderPluginOptions';\nimport type * as V0VRM from '@pixiv/types-vrm-0.0';\nimport type * as V1VRMSchema from '@pixiv/types-vrmc-vrm-1.0';\nimport * as THREE from 'three';\nimport { resolveURL } from '../utils/resolveURL';\nimport { GLTF as GLTFSchema } from '@gltf-transform/core';\n\n/**\n * Possible spec versions it recognizes.\n */\nconst POSSIBLE_SPEC_VERSIONS = new Set(['1.0', '1.0-beta']);\n\n/**\n * A plugin of GLTFLoader that imports a {@link VRM1Meta} from a VRM extension of a GLTF.\n */\nexport class VRMMetaLoaderPlugin implements GLTFLoaderPlugin {\n  public readonly parser: GLTFParser;\n\n  /**\n   * If `false`, it won't load its thumbnail image ({@link VRM1Meta.thumbnailImage}).\n   * `false` by default.\n   */\n  public needThumbnailImage: boolean;\n\n  /**\n   * A list of license urls.\n   * This meta loader will accept these `licenseUrl`s.\n   * Otherwise it won't be loaded.\n   */\n  public acceptLicenseUrls: string[];\n\n  /**\n   * Whether it should accept VRM0.0 meta or not.\n   * Note that it might load {@link VRM0Meta} instead of {@link VRM1Meta} when this is `true`.\n   * `true` by default.\n   */\n  public acceptV0Meta: boolean;\n\n  public get name(): string {\n    // We should use the extension name instead but we have multiple plugins for an extension...\n    return 'VRMMetaLoaderPlugin';\n  }\n\n  public constructor(parser: GLTFParser, options?: VRMMetaLoaderPluginOptions) {\n    this.parser = parser;\n\n    this.needThumbnailImage = options?.needThumbnailImage ?? false;\n    this.acceptLicenseUrls = options?.acceptLicenseUrls ?? ['https://vrm.dev/licenses/1.0/'];\n    this.acceptV0Meta = options?.acceptV0Meta ?? true;\n  }\n\n  public async afterRoot(gltf: GLTF): Promise<void> {\n    gltf.userData.vrmMeta = await this._import(gltf);\n  }\n\n  private async _import(gltf: GLTF): Promise<VRMMeta | null> {\n    const v1Result = await this._v1Import(gltf);\n    if (v1Result != null) {\n      return v1Result;\n    }\n\n    const v0Result = await this._v0Import(gltf);\n    if (v0Result != null) {\n      return v0Result;\n    }\n\n    return null;\n  }\n\n  private async _v1Import(gltf: GLTF): Promise<VRM1Meta | null> {\n    const json = this.parser.json as GLTFSchema.IGLTF;\n\n    // early abort if it doesn't use vrm\n    const isVRMUsed = json.extensionsUsed?.indexOf('VRMC_vrm') !== -1;\n    if (!isVRMUsed) {\n      return null;\n    }\n\n    const extension = json.extensions?.['VRMC_vrm'] as V1VRMSchema.VRMCVRM | undefined;\n    if (extension == null) {\n      return null;\n    }\n\n    const specVersion = extension.specVersion;\n    if (!POSSIBLE_SPEC_VERSIONS.has(specVersion)) {\n      console.warn(`VRMMetaLoaderPlugin: Unknown VRMC_vrm specVersion \"${specVersion}\"`);\n      return null;\n    }\n\n    const schemaMeta = extension.meta;\n    if (!schemaMeta) {\n      return null;\n    }\n\n    // throw an error if acceptV0Meta is false\n    const licenseUrl = schemaMeta.licenseUrl;\n    const acceptLicenseUrlsSet = new Set(this.acceptLicenseUrls);\n    if (!acceptLicenseUrlsSet.has(licenseUrl)) {\n      throw new Error(`VRMMetaLoaderPlugin: The license url \"${licenseUrl}\" is not accepted`);\n    }\n\n    let thumbnailImage: HTMLImageElement | undefined = undefined;\n    if (this.needThumbnailImage && schemaMeta.thumbnailImage != null) {\n      thumbnailImage = (await this._extractGLTFImage(schemaMeta.thumbnailImage)) ?? undefined;\n    }\n\n    return {\n      metaVersion: '1',\n      name: schemaMeta.name,\n      version: schemaMeta.version,\n      authors: schemaMeta.authors,\n      copyrightInformation: schemaMeta.copyrightInformation,\n      contactInformation: schemaMeta.contactInformation,\n      references: schemaMeta.references,\n      thirdPartyLicenses: schemaMeta.thirdPartyLicenses,\n      thumbnailImage,\n      licenseUrl: schemaMeta.licenseUrl,\n      avatarPermission: schemaMeta.avatarPermission,\n      allowExcessivelyViolentUsage: schemaMeta.allowExcessivelyViolentUsage,\n      allowExcessivelySexualUsage: schemaMeta.allowExcessivelySexualUsage,\n      commercialUsage: schemaMeta.commercialUsage,\n      allowPoliticalOrReligiousUsage: schemaMeta.allowPoliticalOrReligiousUsage,\n      allowAntisocialOrHateUsage: schemaMeta.allowAntisocialOrHateUsage,\n      creditNotation: schemaMeta.creditNotation,\n      allowRedistribution: schemaMeta.allowRedistribution,\n      modification: schemaMeta.modification,\n      otherLicenseUrl: schemaMeta.otherLicenseUrl,\n    };\n  }\n\n  private async _v0Import(gltf: GLTF): Promise<VRM0Meta | null> {\n    const json = this.parser.json as GLTFSchema.IGLTF;\n\n    // early abort if it doesn't use vrm\n    const vrmExt = json.extensions?.VRM as V0VRM.VRM | undefined;\n    if (!vrmExt) {\n      return null;\n    }\n\n    const schemaMeta = vrmExt.meta;\n    if (!schemaMeta) {\n      return null;\n    }\n\n    // throw an error if acceptV0Meta is false\n    if (!this.acceptV0Meta) {\n      throw new Error('VRMMetaLoaderPlugin: Attempted to load VRM0.0 meta but acceptV0Meta is false');\n    }\n\n    // load thumbnail texture\n    let texture: THREE.Texture | null | undefined;\n    if (this.needThumbnailImage && schemaMeta.texture != null && schemaMeta.texture !== -1) {\n      texture = await this.parser.getDependency('texture', schemaMeta.texture);\n    }\n\n    return {\n      metaVersion: '0',\n      allowedUserName: schemaMeta.allowedUserName,\n      author: schemaMeta.author,\n      commercialUssageName: schemaMeta.commercialUssageName,\n      contactInformation: schemaMeta.contactInformation,\n      licenseName: schemaMeta.licenseName,\n      otherLicenseUrl: schemaMeta.otherLicenseUrl,\n      otherPermissionUrl: schemaMeta.otherPermissionUrl,\n      reference: schemaMeta.reference,\n      sexualUssageName: schemaMeta.sexualUssageName,\n      texture: texture ?? undefined,\n      title: schemaMeta.title,\n      version: schemaMeta.version,\n      violentUssageName: schemaMeta.violentUssageName,\n    };\n  }\n\n  private async _extractGLTFImage(index: number): Promise<HTMLImageElement | null> {\n    const json = this.parser.json as GLTFSchema.IGLTF;\n\n    const source = json.images?.[index];\n\n    if (source == null) {\n      console.warn(\n        `VRMMetaLoaderPlugin: Attempt to use images[${index}] of glTF as a thumbnail but the image doesn't exist`,\n      );\n      return null;\n    }\n\n    // Ref: https://github.com/mrdoob/three.js/blob/r124/examples/jsm/loaders/GLTFLoader.js#L2467\n\n    // `source.uri` might be a reference to a file\n    let sourceURI: string | undefined = source.uri;\n\n    // Load the binary as a blob\n    if (source.bufferView != null) {\n      const bufferView = await this.parser.getDependency('bufferView', source.bufferView);\n      const blob = new Blob([bufferView], { type: source.mimeType });\n      sourceURI = URL.createObjectURL(blob);\n    }\n\n    if (sourceURI == null) {\n      console.warn(\n        `VRMMetaLoaderPlugin: Attempt to use images[${index}] of glTF as a thumbnail but the image couldn't load properly`,\n      );\n      return null;\n    }\n\n    const loader = new THREE.ImageLoader();\n    return await loader.loadAsync(resolveURL(sourceURI, (this.parser as any).options.path)).catch((error) => {\n      console.error(error);\n      console.warn('VRMMetaLoaderPlugin: Failed to load a thumbnail image');\n      return null;\n    });\n  }\n}\n", "/**\n * Yoinked from https://github.com/mrdoob/three.js/blob/master/examples/jsm/loaders/GLTFLoader.js\n */\nexport function resolveURL(url: string, path: string): string {\n  // Invalid URL\n  if (typeof url !== 'string' || url === '') return '';\n\n  // Host Relative URL\n  if (/^https?:\\/\\//i.test(path) && /^\\//.test(url)) {\n    path = path.replace(/(^https?:\\/\\/[^/]+).*/i, '$1');\n  }\n\n  // Absolute URL http://,https://,//\n  if (/^(https?:)?\\/\\//i.test(url)) return url;\n\n  // Data URI\n  if (/^data:.*,.*$/i.test(url)) return url;\n\n  // Blob URL\n  if (/^blob:.*$/i.test(url)) return url;\n\n  // Relative URL\n  return path + url;\n}\n", "import * as THREE from 'three';\nimport { VRMExpressionManager } from './expressions/VRMExpressionManager';\nimport { VRMFirstPerson } from './firstPerson/VRMFirstPerson';\nimport { VRMHumanoid } from './humanoid/VRMHumanoid';\nimport { VRMLookAt } from './lookAt/VRMLookAt';\nimport { VRMMeta } from './meta/VRMMeta';\nimport { VRMCoreParameters } from './VRMCoreParameters';\n\n/**\n * A class that represents a single VRM model.\n * This class only includes core spec of the VRM (`VRMC_vrm`).\n */\nexport class VRMCore {\n  /**\n   * `THREE.Group` that contains the entire VRM.\n   */\n  public readonly scene: THREE.Group;\n\n  /**\n   * Contains meta fields of the VRM.\n   * You might want to refer these license fields before use your VRMs.\n   */\n  public readonly meta: VRMMeta;\n\n  /**\n   * Contains {@link VRMHumanoid} of the VRM.\n   * You can control each bones using {@link VRMHumanoid.getNormalizedBoneNode} or {@link VRMHumanoid.getRawBoneNode}.\n   *\n   * @TODO Add a link to VRM spec\n   */\n  public readonly humanoid: VRMHumanoid;\n\n  /**\n   * Contains {@link VRMExpressionManager} of the VRM.\n   * You might want to control these facial expressions via {@link VRMExpressionManager.setValue}.\n   */\n  public readonly expressionManager?: VRMExpressionManager;\n\n  /**\n   * Contains {@link VRMFirstPerson} of the VRM.\n   * VRMFirstPerson is mostly used for mesh culling for first person view.\n   */\n  public readonly firstPerson?: VRMFirstPerson;\n\n  /**\n   * Contains {@link VRMLookAt} of the VRM.\n   * You might want to use {@link VRMLookAt.target} to control the eye direction of your VRMs.\n   */\n  public readonly lookAt?: VRMLookAt;\n\n  /**\n   * Create a new VRM instance.\n   *\n   * @param params {@link VRMParameters} that represents components of the VRM\n   */\n  public constructor(params: VRMCoreParameters) {\n    this.scene = params.scene;\n    this.meta = params.meta;\n    this.humanoid = params.humanoid;\n    this.expressionManager = params.expressionManager;\n    this.firstPerson = params.firstPerson;\n    this.lookAt = params.lookAt;\n  }\n\n  /**\n   * **You need to call this on your update loop.**\n   *\n   * This function updates every VRM components.\n   *\n   * @param delta deltaTime\n   */\n  public update(delta: number): void {\n    this.humanoid.update();\n\n    if (this.lookAt) {\n      this.lookAt.update(delta);\n    }\n\n    if (this.expressionManager) {\n      this.expressionManager.update();\n    }\n  }\n}\n", "import { GLTF, GLTFLoaderPlugin, GLTFParser } from 'three/examples/jsm/loaders/GLTFLoader.js';\nimport { VRMCoreLoaderPluginOptions } from './VRMCoreLoaderPluginOptions';\nimport { VRMCore } from './VRMCore';\nimport { VRMExpressionLoaderPlugin } from './expressions/VRMExpressionLoaderPlugin';\nimport { VRMFirstPersonLoaderPlugin } from './firstPerson/VRMFirstPersonLoaderPlugin';\nimport { VRMHumanoidLoaderPlugin } from './humanoid/VRMHumanoidLoaderPlugin';\nimport { VRMMetaLoaderPlugin } from './meta/VRMMetaLoaderPlugin';\nimport { VRMLookAtLoaderPlugin } from './lookAt/VRMLookAtLoaderPlugin';\nimport type { VRMHumanoid } from './humanoid';\nimport type { VRMMeta } from './meta';\n\nexport class VRMCoreLoaderPlugin implements GLTFLoaderPlugin {\n  public get name(): string {\n    // We should use the extension name instead but we have multiple plugins for an extension...\n    return 'VRMC_vrm';\n  }\n\n  public readonly parser: GLTFParser;\n\n  public readonly expressionPlugin: VRMExpressionLoaderPlugin;\n  public readonly firstPersonPlugin: VRMFirstPersonLoaderPlugin;\n  public readonly humanoidPlugin: VRMHumanoidLoaderPlugin;\n  public readonly lookAtPlugin: VRMLookAtLoaderPlugin;\n  public readonly metaPlugin: VRMMetaLoaderPlugin;\n\n  public constructor(parser: GLTFParser, options?: VRMCoreLoaderPluginOptions) {\n    this.parser = parser;\n\n    const helperRoot = options?.helperRoot;\n    const autoUpdateHumanBones = options?.autoUpdateHumanBones;\n\n    this.expressionPlugin = options?.expressionPlugin ?? new VRMExpressionLoaderPlugin(parser);\n    this.firstPersonPlugin = options?.firstPersonPlugin ?? new VRMFirstPersonLoaderPlugin(parser);\n    this.humanoidPlugin =\n      options?.humanoidPlugin ?? new VRMHumanoidLoaderPlugin(parser, { helperRoot, autoUpdateHumanBones });\n    this.lookAtPlugin = options?.lookAtPlugin ?? new VRMLookAtLoaderPlugin(parser, { helperRoot });\n    this.metaPlugin = options?.metaPlugin ?? new VRMMetaLoaderPlugin(parser);\n  }\n\n  public async afterRoot(gltf: GLTF): Promise<void> {\n    await this.metaPlugin.afterRoot(gltf);\n    await this.humanoidPlugin.afterRoot(gltf);\n    await this.expressionPlugin.afterRoot(gltf);\n    await this.lookAtPlugin.afterRoot(gltf);\n    await this.firstPersonPlugin.afterRoot(gltf);\n\n    const meta = gltf.userData.vrmMeta as VRMMeta | null;\n    const humanoid = gltf.userData.vrmHumanoid as VRMHumanoid | null;\n\n    // meta and humanoid are required to be a VRM.\n    // Don't create VRM if they are null\n    if (meta && humanoid) {\n      const vrmCore = new VRMCore({\n        scene: gltf.scene,\n        expressionManager: gltf.userData.vrmExpressionManager,\n        firstPerson: gltf.userData.vrmFirstPerson,\n        humanoid,\n        lookAt: gltf.userData.vrmLookAt,\n        meta,\n      });\n\n      gltf.userData.vrmCore = vrmCore;\n    }\n  }\n}\n", "import * as THREE from 'three';\nimport { VRMCore } from '@pixiv/three-vrm-core';\nimport { VRMNodeConstraintManager } from '@pixiv/three-vrm-node-constraint';\nimport { VRMSpringBoneManager } from '@pixiv/three-vrm-springbone';\nimport { VRMParameters } from './VRMParameters';\n\n/**\n * A class that represents a single VRM model.\n */\nexport class VRM extends VRMCore {\n  /**\n   * Contains materials of the VRM.\n   * `update` method of these materials will be called via its {@link VRM.update} method.\n   */\n  public readonly materials?: THREE.Material[];\n\n  /**\n   * A {@link VRMSpringBoneManager} manipulates all spring bones attached on the VRM.\n   * Usually you don't have to care about this property.\n   */\n  public readonly springBoneManager?: VRMSpringBoneManager;\n\n  /**\n   * A {@link VRMNodeConstraintManager} manipulates all constraints attached on the VRM.\n   * Usually you don't have to care about this property.\n   */\n  public readonly nodeConstraintManager?: VRMNodeConstraintManager;\n\n  /**\n   * Create a new VRM instance.\n   *\n   * @param params {@link VRMParameters} that represents components of the VRM\n   */\n  public constructor(params: VRMParameters) {\n    super(params);\n\n    this.materials = params.materials;\n    this.springBoneManager = params.springBoneManager;\n    this.nodeConstraintManager = params.nodeConstraintManager;\n  }\n\n  /**\n   * **You need to call this on your update loop.**\n   *\n   * This function updates every VRM components.\n   *\n   * @param delta deltaTime\n   */\n  public update(delta: number): void {\n    super.update(delta);\n\n    if (this.nodeConstraintManager) {\n      this.nodeConstraintManager.update();\n    }\n\n    if (this.springBoneManager) {\n      this.springBoneManager.update(delta);\n    }\n\n    if (this.materials) {\n      this.materials.forEach((material: any) => {\n        if (material.update) {\n          material.update(delta);\n        }\n      });\n    }\n  }\n}\n", "import * as THREE from 'three';\nimport * as V1MToonSchema from '@pixiv/types-vrmc-materials-mtoon-1.0';\nimport type { GLTF, GLTFLoader, GLTFLoaderPlugin, GLTFParser } from 'three/examples/jsm/loaders/GLTFLoader.js';\nimport type { MToonMaterialParameters } from './MToonMaterialParameters';\nimport type { MToonMaterialOutlineWidthMode } from './MToonMaterialOutlineWidthMode';\nimport { GLTFMToonMaterialParamsAssignHelper } from './GLTFMToonMaterialParamsAssignHelper';\nimport type { MToonMaterialLoaderPluginOptions } from './MToonMaterialLoaderPluginOptions';\nimport type { MToonMaterialDebugMode } from './MToonMaterialDebugMode';\nimport { GLTF as GLTFSchema } from '@gltf-transform/core';\nimport { MToonMaterial } from './MToonMaterial';\nimport type { MToonNodeMaterial } from './nodes/MToonNodeMaterial';\n\n/**\n * Possible spec versions it recognizes.\n */\nconst POSSIBLE_SPEC_VERSIONS = new Set(['1.0', '1.0-beta']);\n\n/**\n * A loader plugin of {@link GLTFLoader} for the extension `VRMC_materials_mtoon`.\n *\n * This plugin is for uses with WebGLRenderer by default.\n * To use MToon in WebGPURenderer, set {@link materialType} to {@link MToonNodeMaterial}.\n *\n * @example to use with WebGPURenderer\n * ```js\n * import { MToonMaterialLoaderPlugin } from '@pixiv/three-vrm-materials-mtoon';\n * import { MToonNodeMaterial } from '@pixiv/three-vrm-materials-mtoon/nodes';\n *\n * // ...\n *\n * // Register a MToonMaterialLoaderPlugin with MToonNodeMaterial\n * loader.register((parser) => {\n *\n *   // create a WebGPU compatible MToonMaterialLoaderPlugin\n *   return new MToonMaterialLoaderPlugin(parser, {\n *\n *     // set the material type to MToonNodeMaterial\n *     materialType: MToonNodeMaterial,\n *\n *   });\n *\n * });\n * ```\n */\nexport class MToonMaterialLoaderPlugin implements GLTFLoaderPlugin {\n  public static EXTENSION_NAME = 'VRMC_materials_mtoon';\n\n  /**\n   * The type of the material that this plugin will generate.\n   *\n   * If you are using this plugin with WebGPU, set this to {@link MToonNodeMaterial}.\n   *\n   * @default MToonMaterial\n   */\n  public materialType: typeof THREE.Material;\n\n  /**\n   * This value will be added to `renderOrder` of every meshes who have MaterialsMToon.\n   * The final renderOrder will be sum of this `renderOrderOffset` and `renderQueueOffsetNumber` for each materials.\n   *\n   * @default 0\n   */\n  public renderOrderOffset: number;\n\n  /**\n   * There is a line of the shader called \"comment out if you want to PBR absolutely\" in VRM0.0 MToon.\n   * When this is true, the material enables the line to make it compatible with the legacy rendering of VRM.\n   * Usually not recommended to turn this on.\n   *\n   * @default false\n   */\n  public v0CompatShade: boolean;\n\n  /**\n   * Debug mode for the material.\n   * You can visualize several components for diagnosis using debug mode.\n   *\n   * See: {@link MToonMaterialDebugMode}\n   *\n   * @default 'none'\n   */\n  public debugMode: MToonMaterialDebugMode;\n\n  public readonly parser: GLTFParser;\n\n  /**\n   * Loaded materials will be stored in this set.\n   * Will be transferred into `gltf.userData.vrmMToonMaterials` in {@link afterRoot}.\n   */\n  private readonly _mToonMaterialSet: Set<THREE.Material>;\n\n  public get name(): string {\n    return MToonMaterialLoaderPlugin.EXTENSION_NAME;\n  }\n\n  public constructor(parser: GLTFParser, options: MToonMaterialLoaderPluginOptions = {}) {\n    this.parser = parser;\n\n    this.materialType = options.materialType ?? MToonMaterial;\n    this.renderOrderOffset = options.renderOrderOffset ?? 0;\n    this.v0CompatShade = options.v0CompatShade ?? false;\n    this.debugMode = options.debugMode ?? 'none';\n\n    this._mToonMaterialSet = new Set();\n  }\n\n  public async beforeRoot(): Promise<void> {\n    this._removeUnlitExtensionIfMToonExists();\n  }\n\n  public async afterRoot(gltf: GLTF): Promise<void> {\n    gltf.userData.vrmMToonMaterials = Array.from(this._mToonMaterialSet);\n  }\n\n  public getMaterialType(materialIndex: number): typeof THREE.Material | null {\n    const v1Extension = this._getMToonExtension(materialIndex);\n    if (v1Extension) {\n      return this.materialType;\n    }\n\n    return null;\n  }\n\n  public extendMaterialParams(materialIndex: number, materialParams: MToonMaterialParameters): Promise<any> | null {\n    const extension = this._getMToonExtension(materialIndex);\n    if (extension) {\n      return this._extendMaterialParams(extension, materialParams);\n    }\n\n    return null;\n  }\n\n  public async loadMesh(meshIndex: number): Promise<THREE.Group | THREE.Mesh | THREE.SkinnedMesh> {\n    const parser = this.parser;\n    const json = parser.json as GLTFSchema.IGLTF;\n\n    const meshDef = json.meshes?.[meshIndex];\n\n    if (meshDef == null) {\n      throw new Error(\n        `MToonMaterialLoaderPlugin: Attempt to use meshes[${meshIndex}] of glTF but the mesh doesn't exist`,\n      );\n    }\n\n    const primitivesDef = meshDef.primitives;\n\n    const meshOrGroup = await parser.loadMesh(meshIndex);\n\n    if (primitivesDef.length === 1) {\n      const mesh = meshOrGroup as THREE.Mesh;\n      const materialIndex = primitivesDef[0].material;\n\n      if (materialIndex != null) {\n        this._setupPrimitive(mesh, materialIndex);\n      }\n    } else {\n      const group = meshOrGroup as THREE.Group;\n      for (let i = 0; i < primitivesDef.length; i++) {\n        const mesh = group.children[i] as THREE.Mesh;\n        const materialIndex = primitivesDef[i].material;\n\n        if (materialIndex != null) {\n          this._setupPrimitive(mesh, materialIndex);\n        }\n      }\n    }\n\n    return meshOrGroup;\n  }\n\n  /**\n   * Delete use of `KHR_materials_unlit` from its `materials` if the material is using MToon.\n   *\n   * Since GLTFLoader have so many hardcoded procedure related to `KHR_materials_unlit`\n   * we have to delete the extension before we start to parse the glTF.\n   */\n  private _removeUnlitExtensionIfMToonExists(): void {\n    const parser = this.parser;\n    const json = parser.json as GLTFSchema.IGLTF;\n\n    const materialDefs = json.materials;\n    materialDefs?.map((materialDef, iMaterial) => {\n      const extension = this._getMToonExtension(iMaterial);\n\n      if (extension && materialDef.extensions?.['KHR_materials_unlit']) {\n        delete materialDef.extensions['KHR_materials_unlit'];\n      }\n    });\n  }\n\n  protected _getMToonExtension(materialIndex: number): V1MToonSchema.VRMCMaterialsMToon | undefined {\n    const parser = this.parser;\n    const json = parser.json as GLTFSchema.IGLTF;\n\n    const materialDef = json.materials?.[materialIndex];\n\n    if (materialDef == null) {\n      console.warn(\n        `MToonMaterialLoaderPlugin: Attempt to use materials[${materialIndex}] of glTF but the material doesn't exist`,\n      );\n      return undefined;\n    }\n\n    const extension = materialDef.extensions?.[MToonMaterialLoaderPlugin.EXTENSION_NAME] as\n      | V1MToonSchema.VRMCMaterialsMToon\n      | undefined;\n    if (extension == null) {\n      return undefined;\n    }\n\n    const specVersion = extension.specVersion;\n    if (!POSSIBLE_SPEC_VERSIONS.has(specVersion)) {\n      console.warn(\n        `MToonMaterialLoaderPlugin: Unknown ${MToonMaterialLoaderPlugin.EXTENSION_NAME} specVersion \"${specVersion}\"`,\n      );\n      return undefined;\n    }\n\n    return extension;\n  }\n\n  private async _extendMaterialParams(\n    extension: V1MToonSchema.VRMCMaterialsMToon,\n    materialParams: MToonMaterialParameters,\n  ): Promise<void> {\n    // Removing material params that is not required to supress warnings.\n    delete (materialParams as THREE.MeshStandardMaterialParameters).metalness;\n    delete (materialParams as THREE.MeshStandardMaterialParameters).roughness;\n\n    const assignHelper = new GLTFMToonMaterialParamsAssignHelper(this.parser, materialParams);\n\n    assignHelper.assignPrimitive('transparentWithZWrite', extension.transparentWithZWrite);\n    assignHelper.assignColor('shadeColorFactor', extension.shadeColorFactor);\n    assignHelper.assignTexture('shadeMultiplyTexture', extension.shadeMultiplyTexture, true);\n    assignHelper.assignPrimitive('shadingShiftFactor', extension.shadingShiftFactor);\n    assignHelper.assignTexture('shadingShiftTexture', extension.shadingShiftTexture, true);\n    assignHelper.assignPrimitive('shadingShiftTextureScale', extension.shadingShiftTexture?.scale);\n    assignHelper.assignPrimitive('shadingToonyFactor', extension.shadingToonyFactor);\n    assignHelper.assignPrimitive('giEqualizationFactor', extension.giEqualizationFactor);\n    assignHelper.assignColor('matcapFactor', extension.matcapFactor);\n    assignHelper.assignTexture('matcapTexture', extension.matcapTexture, true);\n    assignHelper.assignColor('parametricRimColorFactor', extension.parametricRimColorFactor);\n    assignHelper.assignTexture('rimMultiplyTexture', extension.rimMultiplyTexture, true);\n    assignHelper.assignPrimitive('rimLightingMixFactor', extension.rimLightingMixFactor);\n    assignHelper.assignPrimitive('parametricRimFresnelPowerFactor', extension.parametricRimFresnelPowerFactor);\n    assignHelper.assignPrimitive('parametricRimLiftFactor', extension.parametricRimLiftFactor);\n    assignHelper.assignPrimitive('outlineWidthMode', extension.outlineWidthMode as MToonMaterialOutlineWidthMode);\n    assignHelper.assignPrimitive('outlineWidthFactor', extension.outlineWidthFactor);\n    assignHelper.assignTexture('outlineWidthMultiplyTexture', extension.outlineWidthMultiplyTexture, false);\n    assignHelper.assignColor('outlineColorFactor', extension.outlineColorFactor);\n    assignHelper.assignPrimitive('outlineLightingMixFactor', extension.outlineLightingMixFactor);\n    assignHelper.assignTexture('uvAnimationMaskTexture', extension.uvAnimationMaskTexture, false);\n    assignHelper.assignPrimitive('uvAnimationScrollXSpeedFactor', extension.uvAnimationScrollXSpeedFactor);\n    assignHelper.assignPrimitive('uvAnimationScrollYSpeedFactor', extension.uvAnimationScrollYSpeedFactor);\n    assignHelper.assignPrimitive('uvAnimationRotationSpeedFactor', extension.uvAnimationRotationSpeedFactor);\n\n    assignHelper.assignPrimitive('v0CompatShade', this.v0CompatShade);\n    assignHelper.assignPrimitive('debugMode', this.debugMode);\n\n    await assignHelper.pending;\n  }\n\n  /**\n   * This will do two processes that is required to render MToon properly.\n   *\n   * - Set render order\n   * - Generate outline\n   *\n   * @param mesh A target GLTF primitive\n   * @param materialIndex The material index of the primitive\n   */\n  private _setupPrimitive(mesh: THREE.Mesh, materialIndex: number): void {\n    const extension = this._getMToonExtension(materialIndex);\n    if (extension) {\n      const renderOrder = this._parseRenderOrder(extension);\n      mesh.renderOrder = renderOrder + this.renderOrderOffset;\n\n      this._generateOutline(mesh);\n\n      this._addToMaterialSet(mesh);\n\n      return;\n    }\n  }\n\n  /**\n   * Check whether the material should generate outline or not.\n   * @param surfaceMaterial The material to check\n   * @returns True if the material should generate outline\n   */\n  private _shouldGenerateOutline(surfaceMaterial: THREE.Material): boolean {\n    // we might receive MToonNodeMaterial as well as MToonMaterial\n    // so we're gonna duck type to check if it's compatible with MToon type outlines\n    return (\n      typeof (surfaceMaterial as any).outlineWidthMode === 'string' &&\n      (surfaceMaterial as any).outlineWidthMode !== 'none' &&\n      typeof (surfaceMaterial as any).outlineWidthFactor === 'number' &&\n      (surfaceMaterial as any).outlineWidthFactor > 0.0\n    );\n  }\n\n  /**\n   * Generate outline for the given mesh, if it needs.\n   *\n   * @param mesh The target mesh\n   */\n  private _generateOutline(mesh: THREE.Mesh): void {\n    // OK, it's the hacky part.\n    // We are going to duplicate the MToonMaterial for outline use.\n    // Then we are going to create two geometry groups and refer same buffer but different material.\n    // It's how we draw two materials at once using a single mesh.\n\n    // make sure the material is single\n    const surfaceMaterial = mesh.material;\n    if (!(surfaceMaterial instanceof THREE.Material)) {\n      return;\n    }\n\n    if (!this._shouldGenerateOutline(surfaceMaterial)) {\n      return;\n    }\n\n    // make its material an array\n    mesh.material = [surfaceMaterial]; // mesh.material is guaranteed to be a Material in GLTFLoader\n\n    // duplicate the material for outline use\n    const outlineMaterial = surfaceMaterial.clone();\n    outlineMaterial.name += ' (Outline)';\n    (outlineMaterial as any).isOutline = true;\n    outlineMaterial.side = THREE.BackSide;\n    mesh.material.push(outlineMaterial);\n\n    // make two geometry groups out of a same buffer\n    const geometry = mesh.geometry; // mesh.geometry is guaranteed to be a BufferGeometry in GLTFLoader\n    const primitiveVertices = geometry.index ? geometry.index.count : geometry.attributes.position.count / 3;\n    geometry.addGroup(0, primitiveVertices, 0);\n    geometry.addGroup(0, primitiveVertices, 1);\n  }\n\n  private _addToMaterialSet(mesh: THREE.Mesh): void {\n    const materialOrMaterials = mesh.material;\n    const materialSet = new Set<THREE.Material>();\n\n    if (Array.isArray(materialOrMaterials)) {\n      materialOrMaterials.forEach((material) => materialSet.add(material));\n    } else {\n      materialSet.add(materialOrMaterials);\n    }\n\n    for (const material of materialSet) {\n      this._mToonMaterialSet.add(material);\n    }\n  }\n\n  private _parseRenderOrder(extension: V1MToonSchema.VRMCMaterialsMToon): number {\n    // transparentWithZWrite ranges from 0 to +9\n    // mere transparent ranges from -9 to 0\n    const enabledZWrite = extension.transparentWithZWrite;\n    return (enabledZWrite ? 0 : 19) + (extension.renderQueueOffsetNumber ?? 0);\n  }\n}\n", "import * as THREE from 'three';\nimport { GLTFParser } from 'three/examples/jsm/loaders/GLTFLoader.js';\nimport { MToonMaterialParameters } from './MToonMaterialParameters';\nimport { setTextureColorSpace } from './utils/setTextureColorSpace';\n\n/**\n * MaterialParameters hates `undefined`. This helper automatically rejects assign of these `undefined`.\n * It also handles asynchronous process of textures.\n * Make sure await for {@link GLTFMToonMaterialParamsAssignHelper.pending}.\n */\nexport class GLTFMToonMaterialParamsAssignHelper {\n  private readonly _parser: GLTFParser;\n  private _materialParams: MToonMaterialParameters;\n  private _pendings: Promise<any>[];\n\n  public get pending(): Promise<unknown> {\n    return Promise.all(this._pendings);\n  }\n\n  public constructor(parser: GLTFParser, materialParams: MToonMaterialParameters) {\n    this._parser = parser;\n    this._materialParams = materialParams;\n    this._pendings = [];\n  }\n\n  public assignPrimitive<T extends keyof MToonMaterialParameters>(key: T, value: MToonMaterialParameters[T]): void {\n    if (value != null) {\n      this._materialParams[key] = value;\n    }\n  }\n\n  public assignColor<T extends keyof MToonMaterialParameters>(\n    key: T,\n    value: number[] | undefined,\n    convertSRGBToLinear?: boolean,\n  ): void {\n    if (value != null) {\n      const color = new THREE.Color().fromArray(value);\n\n      if (convertSRGBToLinear) {\n        color.convertSRGBToLinear();\n      }\n      (this._materialParams as any)[key] = color;\n    }\n  }\n\n  public async assignTexture<T extends keyof MToonMaterialParameters>(\n    key: T,\n    texture: { index: number } | undefined,\n    isColorTexture: boolean,\n  ): Promise<void> {\n    const promise = (async () => {\n      if (texture != null) {\n        await this._parser.assignTexture(this._materialParams, key, texture);\n\n        if (isColorTexture) {\n          setTextureColorSpace(this._materialParams[key] as THREE.Texture, 'srgb');\n        }\n      }\n    })();\n\n    this._pendings.push(promise);\n\n    return promise;\n  }\n\n  public async assignTextureByIndex<T extends keyof MToonMaterialParameters>(\n    key: T,\n    textureIndex: number | undefined,\n    isColorTexture: boolean,\n  ): Promise<void> {\n    return this.assignTexture(key, textureIndex != null ? { index: textureIndex } : undefined, isColorTexture);\n  }\n}\n", "import * as THREE from 'three';\n\nconst colorSpaceEncodingMap: Record<'' | 'srgb', any> = {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  '': 3000,\n  srgb: 3001,\n};\n\n/**\n * A compat function to set texture color space.\n *\n * COMPAT: pre-r152\n * Starting from Three.js r152, `texture.encoding` is renamed to `texture.colorSpace`.\n * This function will handle the comapt.\n *\n * @param texture The texture you want to set the color space to\n * @param colorSpace The color space you want to set to the texture\n */\nexport function setTextureColorSpace(texture: THREE.Texture, colorSpace: '' | 'srgb'): void {\n  if (parseInt(THREE.REVISION, 10) >= 152) {\n    texture.colorSpace = colorSpace;\n  } else {\n    (texture as any).encoding = colorSpaceEncodingMap[colorSpace];\n  }\n}\n", "/* tslint:disable:member-ordering */\n\nimport * as THREE from 'three';\nimport vertexShader from './shaders/mtoon.vert';\nimport fragmentShader from './shaders/mtoon.frag';\nimport { MToonMaterialDebugMode } from './MToonMaterialDebugMode';\nimport { MToonMaterialOutlineWidthMode } from './MToonMaterialOutlineWidthMode';\nimport type { MToonMaterialParameters } from './MToonMaterialParameters';\nimport { getTextureColorSpace } from './utils/getTextureColorSpace';\n\n/**\n * MToon is a material specification that has various features.\n * The spec and implementation are originally founded for Unity engine and this is a port of the material.\n *\n * See: https://github.com/Santarh/MToon\n */\nexport class MToonMaterial extends THREE.ShaderMaterial {\n  public uniforms: {\n    litFactor: THREE.IUniform<THREE.Color>;\n    alphaTest: THREE.IUniform<number>;\n    opacity: THREE.IUniform<number>;\n    map: THREE.IUniform<THREE.Texture | null>;\n    mapUvTransform: THREE.IUniform<THREE.Matrix3>;\n    normalMap: THREE.IUniform<THREE.Texture | null>;\n    normalMapUvTransform: THREE.IUniform<THREE.Matrix3>;\n    normalScale: THREE.IUniform<THREE.Vector2>;\n    emissive: THREE.IUniform<THREE.Color>;\n    emissiveIntensity: THREE.IUniform<number>;\n    emissiveMap: THREE.IUniform<THREE.Texture | null>;\n    emissiveMapUvTransform: THREE.IUniform<THREE.Matrix3>;\n    shadeColorFactor: THREE.IUniform<THREE.Color>;\n    shadeMultiplyTexture: THREE.IUniform<THREE.Texture | null>;\n    shadeMultiplyTextureUvTransform: THREE.IUniform<THREE.Matrix3>;\n    shadingShiftFactor: THREE.IUniform<number>;\n    shadingShiftTexture: THREE.IUniform<THREE.Texture | null>;\n    shadingShiftTextureUvTransform: THREE.IUniform<THREE.Matrix3>;\n    shadingShiftTextureScale: THREE.IUniform<number>;\n    shadingToonyFactor: THREE.IUniform<number>;\n    giEqualizationFactor: THREE.IUniform<number>;\n    matcapFactor: THREE.IUniform<THREE.Color>;\n    matcapTexture: THREE.IUniform<THREE.Texture | null>;\n    matcapTextureUvTransform: THREE.IUniform<THREE.Matrix3>;\n    parametricRimColorFactor: THREE.IUniform<THREE.Color>;\n    rimMultiplyTexture: THREE.IUniform<THREE.Texture | null>;\n    rimMultiplyTextureUvTransform: THREE.IUniform<THREE.Matrix3>;\n    rimLightingMixFactor: THREE.IUniform<number>;\n    parametricRimFresnelPowerFactor: THREE.IUniform<number>;\n    parametricRimLiftFactor: THREE.IUniform<number>;\n    outlineWidthMultiplyTexture: THREE.IUniform<THREE.Texture | null>;\n    outlineWidthMultiplyTextureUvTransform: THREE.IUniform<THREE.Matrix3>;\n    outlineWidthFactor: THREE.IUniform<number>;\n    outlineColorFactor: THREE.IUniform<THREE.Color>;\n    outlineLightingMixFactor: THREE.IUniform<number>;\n    uvAnimationMaskTexture: THREE.IUniform<THREE.Texture | null>;\n    uvAnimationMaskTextureUvTransform: THREE.IUniform<THREE.Matrix3>;\n    uvAnimationScrollXOffset: THREE.IUniform<number>;\n    uvAnimationScrollYOffset: THREE.IUniform<number>;\n    uvAnimationRotationPhase: THREE.IUniform<number>;\n  };\n\n  public get color(): THREE.Color {\n    return this.uniforms.litFactor.value;\n  }\n  public set color(value: THREE.Color) {\n    this.uniforms.litFactor.value = value;\n  }\n\n  public get map(): THREE.Texture | null {\n    return this.uniforms.map.value;\n  }\n  public set map(value: THREE.Texture | null) {\n    this.uniforms.map.value = value;\n  }\n\n  public get normalMap(): THREE.Texture | null {\n    return this.uniforms.normalMap.value;\n  }\n  public set normalMap(value: THREE.Texture | null) {\n    this.uniforms.normalMap.value = value;\n  }\n\n  public get normalScale(): THREE.Vector2 {\n    return this.uniforms.normalScale.value;\n  }\n  public set normalScale(value: THREE.Vector2) {\n    this.uniforms.normalScale.value = value;\n  }\n\n  public get emissive(): THREE.Color {\n    return this.uniforms.emissive.value;\n  }\n  public set emissive(value: THREE.Color) {\n    this.uniforms.emissive.value = value;\n  }\n\n  public get emissiveIntensity(): number {\n    return this.uniforms.emissiveIntensity.value;\n  }\n  public set emissiveIntensity(value: number) {\n    this.uniforms.emissiveIntensity.value = value;\n  }\n\n  public get emissiveMap(): THREE.Texture | null {\n    return this.uniforms.emissiveMap.value;\n  }\n  public set emissiveMap(value: THREE.Texture | null) {\n    this.uniforms.emissiveMap.value = value;\n  }\n\n  public get shadeColorFactor(): THREE.Color {\n    return this.uniforms.shadeColorFactor.value;\n  }\n  public set shadeColorFactor(value: THREE.Color) {\n    this.uniforms.shadeColorFactor.value = value;\n  }\n\n  public get shadeMultiplyTexture(): THREE.Texture | null {\n    return this.uniforms.shadeMultiplyTexture.value;\n  }\n  public set shadeMultiplyTexture(value: THREE.Texture | null) {\n    this.uniforms.shadeMultiplyTexture.value = value;\n  }\n\n  public get shadingShiftFactor(): number {\n    return this.uniforms.shadingShiftFactor.value;\n  }\n  public set shadingShiftFactor(value: number) {\n    this.uniforms.shadingShiftFactor.value = value;\n  }\n\n  public get shadingShiftTexture(): THREE.Texture | null {\n    return this.uniforms.shadingShiftTexture.value;\n  }\n  public set shadingShiftTexture(value: THREE.Texture | null) {\n    this.uniforms.shadingShiftTexture.value = value;\n  }\n\n  public get shadingShiftTextureScale(): number {\n    return this.uniforms.shadingShiftTextureScale.value;\n  }\n  public set shadingShiftTextureScale(value: number) {\n    this.uniforms.shadingShiftTextureScale.value = value;\n  }\n\n  public get shadingToonyFactor(): number {\n    return this.uniforms.shadingToonyFactor.value;\n  }\n  public set shadingToonyFactor(value: number) {\n    this.uniforms.shadingToonyFactor.value = value;\n  }\n\n  public get giEqualizationFactor(): number {\n    return this.uniforms.giEqualizationFactor.value;\n  }\n  public set giEqualizationFactor(value: number) {\n    this.uniforms.giEqualizationFactor.value = value;\n  }\n\n  public get matcapFactor(): THREE.Color {\n    return this.uniforms.matcapFactor.value;\n  }\n  public set matcapFactor(value: THREE.Color) {\n    this.uniforms.matcapFactor.value = value;\n  }\n\n  public get matcapTexture(): THREE.Texture | null {\n    return this.uniforms.matcapTexture.value;\n  }\n  public set matcapTexture(value: THREE.Texture | null) {\n    this.uniforms.matcapTexture.value = value;\n  }\n\n  public get parametricRimColorFactor(): THREE.Color {\n    return this.uniforms.parametricRimColorFactor.value;\n  }\n  public set parametricRimColorFactor(value: THREE.Color) {\n    this.uniforms.parametricRimColorFactor.value = value;\n  }\n\n  public get rimMultiplyTexture(): THREE.Texture | null {\n    return this.uniforms.rimMultiplyTexture.value;\n  }\n  public set rimMultiplyTexture(value: THREE.Texture | null) {\n    this.uniforms.rimMultiplyTexture.value = value;\n  }\n\n  public get rimLightingMixFactor(): number {\n    return this.uniforms.rimLightingMixFactor.value;\n  }\n  public set rimLightingMixFactor(value: number) {\n    this.uniforms.rimLightingMixFactor.value = value;\n  }\n\n  public get parametricRimFresnelPowerFactor(): number {\n    return this.uniforms.parametricRimFresnelPowerFactor.value;\n  }\n  public set parametricRimFresnelPowerFactor(value: number) {\n    this.uniforms.parametricRimFresnelPowerFactor.value = value;\n  }\n\n  public get parametricRimLiftFactor(): number {\n    return this.uniforms.parametricRimLiftFactor.value;\n  }\n  public set parametricRimLiftFactor(value: number) {\n    this.uniforms.parametricRimLiftFactor.value = value;\n  }\n\n  public get outlineWidthMultiplyTexture(): THREE.Texture | null {\n    return this.uniforms.outlineWidthMultiplyTexture.value;\n  }\n  public set outlineWidthMultiplyTexture(value: THREE.Texture | null) {\n    this.uniforms.outlineWidthMultiplyTexture.value = value;\n  }\n\n  public get outlineWidthFactor(): number {\n    return this.uniforms.outlineWidthFactor.value;\n  }\n  public set outlineWidthFactor(value: number) {\n    this.uniforms.outlineWidthFactor.value = value;\n  }\n\n  public get outlineColorFactor(): THREE.Color {\n    return this.uniforms.outlineColorFactor.value;\n  }\n  public set outlineColorFactor(value: THREE.Color) {\n    this.uniforms.outlineColorFactor.value = value;\n  }\n\n  public get outlineLightingMixFactor(): number {\n    return this.uniforms.outlineLightingMixFactor.value;\n  }\n  public set outlineLightingMixFactor(value: number) {\n    this.uniforms.outlineLightingMixFactor.value = value;\n  }\n\n  public get uvAnimationMaskTexture(): THREE.Texture | null {\n    return this.uniforms.uvAnimationMaskTexture.value;\n  }\n  public set uvAnimationMaskTexture(value: THREE.Texture | null) {\n    this.uniforms.uvAnimationMaskTexture.value = value;\n  }\n\n  public get uvAnimationScrollXOffset(): number {\n    return this.uniforms.uvAnimationScrollXOffset.value;\n  }\n  public set uvAnimationScrollXOffset(value: number) {\n    this.uniforms.uvAnimationScrollXOffset.value = value;\n  }\n\n  public get uvAnimationScrollYOffset(): number {\n    return this.uniforms.uvAnimationScrollYOffset.value;\n  }\n  public set uvAnimationScrollYOffset(value: number) {\n    this.uniforms.uvAnimationScrollYOffset.value = value;\n  }\n\n  public get uvAnimationRotationPhase(): number {\n    return this.uniforms.uvAnimationRotationPhase.value;\n  }\n  public set uvAnimationRotationPhase(value: number) {\n    this.uniforms.uvAnimationRotationPhase.value = value;\n  }\n\n  public uvAnimationScrollXSpeedFactor = 0.0;\n  public uvAnimationScrollYSpeedFactor = 0.0;\n  public uvAnimationRotationSpeedFactor = 0.0;\n\n  /**\n   * Whether the material is affected by fog.\n   * `true` by default.\n   */\n  public fog = true;\n\n  /**\n   * Will be read in WebGLPrograms\n   *\n   * See: https://github.com/mrdoob/three.js/blob/4f5236ac3d6f41d904aa58401b40554e8fbdcb15/src/renderers/webgl/WebGLPrograms.js#L190-L191\n   */\n  public normalMapType = THREE.TangentSpaceNormalMap;\n\n  /**\n   * When this is `true`, vertex colors will be ignored.\n   * `true` by default.\n   */\n  private _ignoreVertexColor = true;\n\n  /**\n   * When this is `true`, vertex colors will be ignored.\n   * `true` by default.\n   */\n  public get ignoreVertexColor(): boolean {\n    return this._ignoreVertexColor;\n  }\n  public set ignoreVertexColor(value: boolean) {\n    this._ignoreVertexColor = value;\n\n    this.needsUpdate = true;\n  }\n\n  private _v0CompatShade = false;\n\n  /**\n   * There is a line of the shader called \"comment out if you want to PBR absolutely\" in VRM0.0 MToon.\n   * When this is true, the material enables the line to make it compatible with the legacy rendering of VRM.\n   * Usually not recommended to turn this on.\n   * `false` by default.\n   */\n  get v0CompatShade(): boolean {\n    return this._v0CompatShade;\n  }\n\n  /**\n   * There is a line of the shader called \"comment out if you want to PBR absolutely\" in VRM0.0 MToon.\n   * When this is true, the material enables the line to make it compatible with the legacy rendering of VRM.\n   * Usually not recommended to turn this on.\n   * `false` by default.\n   */\n  set v0CompatShade(v: boolean) {\n    this._v0CompatShade = v;\n\n    this.needsUpdate = true;\n  }\n\n  private _debugMode: MToonMaterialDebugMode = MToonMaterialDebugMode.None;\n\n  /**\n   * Debug mode for the material.\n   * You can visualize several components for diagnosis using debug mode.\n   *\n   * See: {@link MToonMaterialDebugMode}\n   */\n  get debugMode(): MToonMaterialDebugMode {\n    return this._debugMode;\n  }\n\n  /**\n   * Debug mode for the material.\n   * You can visualize several components for diagnosis using debug mode.\n   *\n   * See: {@link MToonMaterialDebugMode}\n   */\n  set debugMode(m: MToonMaterialDebugMode) {\n    this._debugMode = m;\n\n    this.needsUpdate = true;\n  }\n\n  private _outlineWidthMode: MToonMaterialOutlineWidthMode = MToonMaterialOutlineWidthMode.None;\n\n  get outlineWidthMode(): MToonMaterialOutlineWidthMode {\n    return this._outlineWidthMode;\n  }\n  set outlineWidthMode(m: MToonMaterialOutlineWidthMode) {\n    this._outlineWidthMode = m;\n\n    this.needsUpdate = true;\n  }\n\n  private _isOutline = false;\n\n  get isOutline(): boolean {\n    return this._isOutline;\n  }\n  set isOutline(b: boolean) {\n    this._isOutline = b;\n\n    this.needsUpdate = true;\n  }\n\n  /**\n   * Readonly boolean that indicates this is a {@link MToonMaterial}.\n   */\n  public get isMToonMaterial(): true {\n    return true;\n  }\n\n  constructor(parameters: MToonMaterialParameters = {}) {\n    super({ vertexShader, fragmentShader });\n\n    // override depthWrite with transparentWithZWrite\n    if (parameters.transparentWithZWrite) {\n      parameters.depthWrite = true;\n    }\n    delete parameters.transparentWithZWrite;\n\n    // == enabling bunch of stuff ==================================================================\n    parameters.fog = true;\n    parameters.lights = true;\n    parameters.clipping = true;\n\n    // == uniforms =================================================================================\n    this.uniforms = THREE.UniformsUtils.merge([\n      THREE.UniformsLib.common, // map\n      THREE.UniformsLib.normalmap, // normalMap\n      THREE.UniformsLib.emissivemap, // emissiveMap\n      THREE.UniformsLib.fog,\n      THREE.UniformsLib.lights,\n      {\n        litFactor: { value: new THREE.Color(1.0, 1.0, 1.0) },\n        mapUvTransform: { value: new THREE.Matrix3() },\n        colorAlpha: { value: 1.0 },\n        normalMapUvTransform: { value: new THREE.Matrix3() },\n        shadeColorFactor: { value: new THREE.Color(0.0, 0.0, 0.0) },\n        shadeMultiplyTexture: { value: null },\n        shadeMultiplyTextureUvTransform: { value: new THREE.Matrix3() },\n        shadingShiftFactor: { value: 0.0 },\n        shadingShiftTexture: { value: null },\n        shadingShiftTextureUvTransform: { value: new THREE.Matrix3() },\n        shadingShiftTextureScale: { value: 1.0 },\n        shadingToonyFactor: { value: 0.9 },\n        giEqualizationFactor: { value: 0.9 },\n        matcapFactor: { value: new THREE.Color(1.0, 1.0, 1.0) },\n        matcapTexture: { value: null },\n        matcapTextureUvTransform: { value: new THREE.Matrix3() },\n        parametricRimColorFactor: { value: new THREE.Color(0.0, 0.0, 0.0) },\n        rimMultiplyTexture: { value: null },\n        rimMultiplyTextureUvTransform: { value: new THREE.Matrix3() },\n        rimLightingMixFactor: { value: 1.0 },\n        parametricRimFresnelPowerFactor: { value: 5.0 },\n        parametricRimLiftFactor: { value: 0.0 },\n        emissive: { value: new THREE.Color(0.0, 0.0, 0.0) },\n        emissiveIntensity: { value: 1.0 },\n        emissiveMapUvTransform: { value: new THREE.Matrix3() },\n        outlineWidthMultiplyTexture: { value: null },\n        outlineWidthMultiplyTextureUvTransform: { value: new THREE.Matrix3() },\n        outlineWidthFactor: { value: 0.0 },\n        outlineColorFactor: { value: new THREE.Color(0.0, 0.0, 0.0) },\n        outlineLightingMixFactor: { value: 1.0 },\n        uvAnimationMaskTexture: { value: null },\n        uvAnimationMaskTextureUvTransform: { value: new THREE.Matrix3() },\n        uvAnimationScrollXOffset: { value: 0.0 },\n        uvAnimationScrollYOffset: { value: 0.0 },\n        uvAnimationRotationPhase: { value: 0.0 },\n      },\n      parameters.uniforms ?? {},\n    ]) as typeof MToonMaterial.prototype.uniforms;\n\n    // == finally compile the shader program =======================================================\n    this.setValues(parameters);\n\n    // == upload uniforms that need to upload ======================================================\n    this._uploadUniformsWorkaround();\n\n    // == update shader stuff ======================================================================\n    this.customProgramCacheKey = () =>\n      [\n        ...Object.entries(this._generateDefines()).map(([token, macro]) => `${token}:${macro}`),\n        this.matcapTexture ? `matcapTextureColorSpace:${getTextureColorSpace(this.matcapTexture)}` : '',\n        this.shadeMultiplyTexture\n          ? `shadeMultiplyTextureColorSpace:${getTextureColorSpace(this.shadeMultiplyTexture)}`\n          : '',\n        this.rimMultiplyTexture ? `rimMultiplyTextureColorSpace:${getTextureColorSpace(this.rimMultiplyTexture)}` : '',\n      ].join(',');\n\n    this.onBeforeCompile = (shader) => {\n      const threeRevision = parseInt(THREE.REVISION, 10);\n\n      const defines =\n        Object.entries({ ...this._generateDefines(), ...this.defines })\n          .filter(([token, macro]) => !!macro)\n          .map(([token, macro]) => `#define ${token} ${macro}`)\n          .join('\\n') + '\\n';\n\n      // -- generate shader code -------------------------------------------------------------------\n      shader.vertexShader = defines + shader.vertexShader;\n      shader.fragmentShader = defines + shader.fragmentShader;\n\n      // -- compat ---------------------------------------------------------------------------------\n\n      // COMPAT: pre-r154\n      // Three.js r154 renames the shader chunk <colorspace_fragment> to <encodings_fragment>\n      if (threeRevision < 154) {\n        shader.fragmentShader = shader.fragmentShader.replace(\n          '#include <colorspace_fragment>',\n          '#include <encodings_fragment>',\n        );\n      }\n    };\n  }\n\n  /**\n   * Update this material.\n   *\n   * @param delta deltaTime since last update\n   */\n  public update(delta: number): void {\n    this._uploadUniformsWorkaround();\n    this._updateUVAnimation(delta);\n  }\n\n  public copy(source: this): this {\n    super.copy(source);\n    // uniforms are already copied at this moment\n\n    // Beginning from r133, uniform textures will be cloned instead of reference\n    // See: https://github.com/mrdoob/three.js/blob/a8813be04a849bd155f7cf6f1b23d8ee2e0fb48b/examples/jsm/loaders/GLTFLoader.js#L3047\n    // See: https://github.com/mrdoob/three.js/blob/a8813be04a849bd155f7cf6f1b23d8ee2e0fb48b/src/renderers/shaders/UniformsUtils.js#L22\n    // This will leave their `.version` to be `0`\n    // and these textures won't be uploaded to GPU\n    // We are going to workaround this in here\n    // I've opened an issue for this: https://github.com/mrdoob/three.js/issues/22718\n    this.map = source.map;\n    this.normalMap = source.normalMap;\n    this.emissiveMap = source.emissiveMap;\n    this.shadeMultiplyTexture = source.shadeMultiplyTexture;\n    this.shadingShiftTexture = source.shadingShiftTexture;\n    this.matcapTexture = source.matcapTexture;\n    this.rimMultiplyTexture = source.rimMultiplyTexture;\n    this.outlineWidthMultiplyTexture = source.outlineWidthMultiplyTexture;\n    this.uvAnimationMaskTexture = source.uvAnimationMaskTexture;\n\n    // == copy members =============================================================================\n    this.normalMapType = source.normalMapType;\n\n    this.uvAnimationScrollXSpeedFactor = source.uvAnimationScrollXSpeedFactor;\n    this.uvAnimationScrollYSpeedFactor = source.uvAnimationScrollYSpeedFactor;\n    this.uvAnimationRotationSpeedFactor = source.uvAnimationRotationSpeedFactor;\n\n    this.ignoreVertexColor = source.ignoreVertexColor;\n\n    this.v0CompatShade = source.v0CompatShade;\n    this.debugMode = source.debugMode;\n    this.outlineWidthMode = source.outlineWidthMode;\n\n    this.isOutline = source.isOutline;\n\n    // == update shader stuff ======================================================================\n    this.needsUpdate = true;\n\n    return this;\n  }\n\n  /**\n   * Update UV animation state.\n   * Intended to be called via {@link update}.\n   * @param delta deltaTime\n   */\n  private _updateUVAnimation(delta: number): void {\n    this.uniforms.uvAnimationScrollXOffset.value += delta * this.uvAnimationScrollXSpeedFactor;\n    this.uniforms.uvAnimationScrollYOffset.value += delta * this.uvAnimationScrollYSpeedFactor;\n    this.uniforms.uvAnimationRotationPhase.value += delta * this.uvAnimationRotationSpeedFactor;\n    this.uniforms.alphaTest.value = this.alphaTest;\n\n    this.uniformsNeedUpdate = true;\n  }\n\n  /**\n   * Upload uniforms that need to upload but doesn't automatically because of reasons.\n   * Intended to be called via {@link constructor} and {@link update}.\n   */\n  private _uploadUniformsWorkaround(): void {\n    // workaround: since opacity is defined as a property in THREE.Material\n    // and cannot be overridden as an accessor,\n    // We are going to update opacity here\n    this.uniforms.opacity.value = this.opacity;\n\n    // workaround: texture transforms are not updated automatically\n    this._updateTextureMatrix(this.uniforms.map, this.uniforms.mapUvTransform);\n    this._updateTextureMatrix(this.uniforms.normalMap, this.uniforms.normalMapUvTransform);\n    this._updateTextureMatrix(this.uniforms.emissiveMap, this.uniforms.emissiveMapUvTransform);\n    this._updateTextureMatrix(this.uniforms.shadeMultiplyTexture, this.uniforms.shadeMultiplyTextureUvTransform);\n    this._updateTextureMatrix(this.uniforms.shadingShiftTexture, this.uniforms.shadingShiftTextureUvTransform);\n    this._updateTextureMatrix(this.uniforms.matcapTexture, this.uniforms.matcapTextureUvTransform);\n    this._updateTextureMatrix(this.uniforms.rimMultiplyTexture, this.uniforms.rimMultiplyTextureUvTransform);\n    this._updateTextureMatrix(\n      this.uniforms.outlineWidthMultiplyTexture,\n      this.uniforms.outlineWidthMultiplyTextureUvTransform,\n    );\n    this._updateTextureMatrix(this.uniforms.uvAnimationMaskTexture, this.uniforms.uvAnimationMaskTextureUvTransform);\n\n    this.uniformsNeedUpdate = true;\n  }\n\n  /**\n   * Returns a map object of preprocessor token and macro of the shader program.\n   */\n  private _generateDefines(): { [token: string]: boolean | number | string } {\n    const threeRevision = parseInt(THREE.REVISION, 10);\n\n    const useUvInVert = this.outlineWidthMultiplyTexture !== null;\n    const useUvInFrag =\n      this.map !== null ||\n      this.normalMap !== null ||\n      this.emissiveMap !== null ||\n      this.shadeMultiplyTexture !== null ||\n      this.shadingShiftTexture !== null ||\n      this.rimMultiplyTexture !== null ||\n      this.uvAnimationMaskTexture !== null;\n\n    return {\n      // Temporary compat against shader change @ Three.js r126\n      // See: #21205, #21307, #21299\n      THREE_VRM_THREE_REVISION: threeRevision,\n\n      OUTLINE: this._isOutline,\n      MTOON_USE_UV: useUvInVert || useUvInFrag, // we can't use `USE_UV` , it will be redefined in WebGLProgram.js\n      MTOON_UVS_VERTEX_ONLY: useUvInVert && !useUvInFrag,\n      V0_COMPAT_SHADE: this._v0CompatShade,\n      USE_SHADEMULTIPLYTEXTURE: this.shadeMultiplyTexture !== null,\n      USE_SHADINGSHIFTTEXTURE: this.shadingShiftTexture !== null,\n      USE_MATCAPTEXTURE: this.matcapTexture !== null,\n      USE_RIMMULTIPLYTEXTURE: this.rimMultiplyTexture !== null,\n      USE_OUTLINEWIDTHMULTIPLYTEXTURE: this._isOutline && this.outlineWidthMultiplyTexture !== null,\n      USE_UVANIMATIONMASKTEXTURE: this.uvAnimationMaskTexture !== null,\n      IGNORE_VERTEX_COLOR: this._ignoreVertexColor === true,\n      DEBUG_NORMAL: this._debugMode === 'normal',\n      DEBUG_LITSHADERATE: this._debugMode === 'litShadeRate',\n      DEBUG_UV: this._debugMode === 'uv',\n      OUTLINE_WIDTH_SCREEN:\n        this._isOutline && this._outlineWidthMode === MToonMaterialOutlineWidthMode.ScreenCoordinates,\n    };\n  }\n\n  private _updateTextureMatrix(src: THREE.IUniform<THREE.Texture | null>, dst: THREE.IUniform<THREE.Matrix3>): void {\n    if (src.value) {\n      if (src.value.matrixAutoUpdate) {\n        src.value.updateMatrix();\n      }\n\n      dst.value.copy(src.value.matrix);\n    }\n  }\n}\n", "// #define PHONG\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n  varying vec3 vNormal;\n#endif\n\n#include <common>\n\n// #include <uv_pars_vertex>\n#ifdef MTOON_USE_UV\n  varying vec2 vUv;\n\n  // COMPAT: pre-r151 uses a common uvTransform\n  #if THREE_VRM_THREE_REVISION < 151\n    uniform mat3 uvTransform;\n  #endif\n#endif\n\n// #include <uv2_pars_vertex>\n// COMAPT: pre-r151 uses uv2 for lightMap and aoMap\n#if THREE_VRM_THREE_REVISION < 151\n  #if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n    attribute vec2 uv2;\n    varying vec2 vUv2;\n    uniform mat3 uv2Transform;\n  #endif\n#endif\n\n// #include <displacementmap_pars_vertex>\n// #include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\n#ifdef USE_OUTLINEWIDTHMULTIPLYTEXTURE\n  uniform sampler2D outlineWidthMultiplyTexture;\n  uniform mat3 outlineWidthMultiplyTextureUvTransform;\n#endif\n\nuniform float outlineWidthFactor;\n\nvoid main() {\n\n  // #include <uv_vertex>\n  #ifdef MTOON_USE_UV\n    // COMPAT: pre-r151 uses a common uvTransform\n    #if THREE_VRM_THREE_REVISION >= 151\n      vUv = uv;\n    #else\n      vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n    #endif\n  #endif\n\n  // #include <uv2_vertex>\n  // COMAPT: pre-r151 uses uv2 for lightMap and aoMap\n  #if THREE_VRM_THREE_REVISION < 151\n    #if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n      vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n    #endif\n  #endif\n\n  #include <color_vertex>\n\n  #include <beginnormal_vertex>\n  #include <morphnormal_vertex>\n  #include <skinbase_vertex>\n  #include <skinnormal_vertex>\n\n  // we need this to compute the outline properly\n  objectNormal = normalize( objectNormal );\n\n  #include <defaultnormal_vertex>\n\n  #ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n    vNormal = normalize( transformedNormal );\n  #endif\n\n  #include <begin_vertex>\n\n  #include <morphtarget_vertex>\n  #include <skinning_vertex>\n  // #include <displacementmap_vertex>\n  #include <project_vertex>\n  #include <logdepthbuf_vertex>\n  #include <clipping_planes_vertex>\n\n  vViewPosition = - mvPosition.xyz;\n\n  #ifdef OUTLINE\n    float worldNormalLength = length( transformedNormal );\n    vec3 outlineOffset = outlineWidthFactor * worldNormalLength * objectNormal;\n\n    #ifdef USE_OUTLINEWIDTHMULTIPLYTEXTURE\n      vec2 outlineWidthMultiplyTextureUv = ( outlineWidthMultiplyTextureUvTransform * vec3( vUv, 1 ) ).xy;\n      float outlineTex = texture2D( outlineWidthMultiplyTexture, outlineWidthMultiplyTextureUv ).g;\n      outlineOffset *= outlineTex;\n    #endif\n\n    #ifdef OUTLINE_WIDTH_SCREEN\n      outlineOffset *= vViewPosition.z / projectionMatrix[ 1 ].y;\n    #endif\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( outlineOffset + transformed, 1.0 );\n\n    gl_Position.z += 1E-6 * gl_Position.w; // anti-artifact magic\n  #endif\n\n  #include <worldpos_vertex>\n  // #include <envmap_vertex>\n  #include <shadowmap_vertex>\n  #include <fog_vertex>\n\n}", "// #define PHONG\n\nuniform vec3 litFactor;\n\nuniform float opacity;\n\nuniform vec3 shadeColorFactor;\n#ifdef USE_SHADEMULTIPLYTEXTURE\n  uniform sampler2D shadeMultiplyTexture;\n  uniform mat3 shadeMultiplyTextureUvTransform;\n#endif\n\nuniform float shadingShiftFactor;\nuniform float shadingToonyFactor;\n\n#ifdef USE_SHADINGSHIFTTEXTURE\n  uniform sampler2D shadingShiftTexture;\n  uniform mat3 shadingShiftTextureUvTransform;\n  uniform float shadingShiftTextureScale;\n#endif\n\nuniform float giEqualizationFactor;\n\nuniform vec3 parametricRimColorFactor;\n#ifdef USE_RIMMULTIPLYTEXTURE\n  uniform sampler2D rimMultiplyTexture;\n  uniform mat3 rimMultiplyTextureUvTransform;\n#endif\nuniform float rimLightingMixFactor;\nuniform float parametricRimFresnelPowerFactor;\nuniform float parametricRimLiftFactor;\n\n#ifdef USE_MATCAPTEXTURE\n  uniform vec3 matcapFactor;\n  uniform sampler2D matcapTexture;\n  uniform mat3 matcapTextureUvTransform;\n#endif\n\nuniform vec3 emissive;\nuniform float emissiveIntensity;\n\nuniform vec3 outlineColorFactor;\nuniform float outlineLightingMixFactor;\n\n#ifdef USE_UVANIMATIONMASKTEXTURE\n  uniform sampler2D uvAnimationMaskTexture;\n  uniform mat3 uvAnimationMaskTextureUvTransform;\n#endif\n\nuniform float uvAnimationScrollXOffset;\nuniform float uvAnimationScrollYOffset;\nuniform float uvAnimationRotationPhase;\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n\n// #include <uv_pars_fragment>\n#if ( defined( MTOON_USE_UV ) && !defined( MTOON_UVS_VERTEX_ONLY ) )\n  varying vec2 vUv;\n#endif\n\n// #include <uv2_pars_fragment>\n// COMAPT: pre-r151 uses uv2 for lightMap and aoMap\n#if THREE_VRM_THREE_REVISION < 151\n  #if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n    varying vec2 vUv2;\n  #endif\n#endif\n\n#include <map_pars_fragment>\n\n#ifdef USE_MAP\n  uniform mat3 mapUvTransform;\n#endif\n\n// #include <alphamap_pars_fragment>\n\n#include <alphatest_pars_fragment>\n\n#include <aomap_pars_fragment>\n// #include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n\n#ifdef USE_EMISSIVEMAP\n  uniform mat3 emissiveMapUvTransform;\n#endif\n\n// #include <envmap_common_pars_fragment>\n// #include <envmap_pars_fragment>\n// #include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n\n// #include <bsdfs>\n// COMPAT: pre-r151 doesn't have BRDF_Lambert in <common>\n#if THREE_VRM_THREE_REVISION < 151\n  vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n    return RECIPROCAL_PI * diffuseColor;\n  }\n#endif\n\n#include <lights_pars_begin>\n\n#include <normal_pars_fragment>\n\n// #include <lights_phong_pars_fragment>\nvarying vec3 vViewPosition;\n\nstruct MToonMaterial {\n  vec3 diffuseColor;\n  vec3 shadeColor;\n  float shadingShift;\n};\n\nfloat linearstep( float a, float b, float t ) {\n  return clamp( ( t - a ) / ( b - a ), 0.0, 1.0 );\n}\n\n/**\n * Convert NdotL into toon shading factor using shadingShift and shadingToony\n */\nfloat getShading(\n  const in float dotNL,\n  const in float shadow,\n  const in float shadingShift\n) {\n  float shading = dotNL;\n  shading = shading + shadingShift;\n  shading = linearstep( -1.0 + shadingToonyFactor, 1.0 - shadingToonyFactor, shading );\n  shading *= shadow;\n  return shading;\n}\n\n/**\n * Mix diffuseColor and shadeColor using shading factor and light color\n */\nvec3 getDiffuse(\n  const in MToonMaterial material,\n  const in float shading,\n  in vec3 lightColor\n) {\n  #ifdef DEBUG_LITSHADERATE\n    return vec3( BRDF_Lambert( shading * lightColor ) );\n  #endif\n\n  vec3 col = lightColor * BRDF_Lambert( mix( material.shadeColor, material.diffuseColor, shading ) );\n\n  // The \"comment out if you want to PBR absolutely\" line\n  #ifdef V0_COMPAT_SHADE\n    col = min( col, material.diffuseColor );\n  #endif\n\n  return col;\n}\n\n// COMPAT: pre-r156 uses a struct GeometricContext\n#if THREE_VRM_THREE_REVISION >= 157\n  void RE_Direct_MToon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in MToonMaterial material, const in float shadow, inout ReflectedLight reflectedLight ) {\n    float dotNL = clamp( dot( geometryNormal, directLight.direction ), -1.0, 1.0 );\n    vec3 irradiance = directLight.color;\n\n    // directSpecular will be used for rim lighting, not an actual specular\n    reflectedLight.directSpecular += irradiance;\n\n    irradiance *= dotNL;\n\n    float shading = getShading( dotNL, shadow, material.shadingShift );\n\n    // toon shaded diffuse\n    reflectedLight.directDiffuse += getDiffuse( material, shading, directLight.color );\n  }\n\n  void RE_IndirectDiffuse_MToon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in MToonMaterial material, inout ReflectedLight reflectedLight ) {\n    // indirect diffuse will use diffuseColor, no shadeColor involved\n    reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\n    // directSpecular will be used for rim lighting, not an actual specular\n    reflectedLight.directSpecular += irradiance;\n  }\n#else\n  void RE_Direct_MToon( const in IncidentLight directLight, const in GeometricContext geometry, const in MToonMaterial material, const in float shadow, inout ReflectedLight reflectedLight ) {\n    float dotNL = clamp( dot( geometry.normal, directLight.direction ), -1.0, 1.0 );\n    vec3 irradiance = directLight.color;\n\n    // directSpecular will be used for rim lighting, not an actual specular\n    reflectedLight.directSpecular += irradiance;\n\n    irradiance *= dotNL;\n\n    float shading = getShading( dotNL, shadow, material.shadingShift );\n\n    // toon shaded diffuse\n    reflectedLight.directDiffuse += getDiffuse( material, shading, directLight.color );\n  }\n\n  void RE_IndirectDiffuse_MToon( const in vec3 irradiance, const in GeometricContext geometry, const in MToonMaterial material, inout ReflectedLight reflectedLight ) {\n    // indirect diffuse will use diffuseColor, no shadeColor involved\n    reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\n    // directSpecular will be used for rim lighting, not an actual specular\n    reflectedLight.directSpecular += irradiance;\n  }\n#endif\n\n#define RE_Direct RE_Direct_MToon\n#define RE_IndirectDiffuse RE_IndirectDiffuse_MToon\n#define Material_LightProbeLOD( material ) (0)\n\n#include <shadowmap_pars_fragment>\n// #include <bumpmap_pars_fragment>\n\n// #include <normalmap_pars_fragment>\n#ifdef USE_NORMALMAP\n\n  uniform sampler2D normalMap;\n  uniform mat3 normalMapUvTransform;\n  uniform vec2 normalScale;\n\n#endif\n\n// COMPAT: pre-r151\n// USE_NORMALMAP_OBJECTSPACE used to be OBJECTSPACE_NORMALMAP in pre-r151\n#if defined( USE_NORMALMAP_OBJECTSPACE ) || defined( OBJECTSPACE_NORMALMAP )\n\n  uniform mat3 normalMatrix;\n\n#endif\n\n// COMPAT: pre-r151\n// USE_NORMALMAP_TANGENTSPACE used to be TANGENTSPACE_NORMALMAP in pre-r151\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( TANGENTSPACE_NORMALMAP ) )\n\n  // Per-Pixel Tangent Space Normal Mapping\n  // http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n\n  // three-vrm specific change: it requires `uv` as an input in order to support uv scrolls\n\n  // Temporary compat against shader change @ Three.js r126, r151\n  #if THREE_VRM_THREE_REVISION >= 151\n\n    mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\n      vec3 q0 = dFdx( eye_pos.xyz );\n      vec3 q1 = dFdy( eye_pos.xyz );\n      vec2 st0 = dFdx( uv.st );\n      vec2 st1 = dFdy( uv.st );\n\n      vec3 N = surf_norm;\n\n      vec3 q1perp = cross( q1, N );\n      vec3 q0perp = cross( N, q0 );\n\n      vec3 T = q1perp * st0.x + q0perp * st1.x;\n      vec3 B = q1perp * st0.y + q0perp * st1.y;\n\n      float det = max( dot( T, T ), dot( B, B ) );\n      float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\n      return mat3( T * scale, B * scale, N );\n\n    }\n\n  #else\n\n    vec3 perturbNormal2Arb( vec2 uv, vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\n      vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n      vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n      vec2 st0 = dFdx( uv.st );\n      vec2 st1 = dFdy( uv.st );\n\n      vec3 N = normalize( surf_norm );\n\n      vec3 q1perp = cross( q1, N );\n      vec3 q0perp = cross( N, q0 );\n\n      vec3 T = q1perp * st0.x + q0perp * st1.x;\n      vec3 B = q1perp * st0.y + q0perp * st1.y;\n\n      // three-vrm specific change: Workaround for the issue that happens when delta of uv = 0.0\n      // TODO: Is this still required? Or shall I make a PR about it?\n      if ( length( T ) == 0.0 || length( B ) == 0.0 ) {\n        return surf_norm;\n      }\n\n      float det = max( dot( T, T ), dot( B, B ) );\n      float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\n      return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\n    }\n\n  #endif\n\n#endif\n\n// #include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\n// == post correction ==========================================================\nvoid postCorrection() {\n  #include <tonemapping_fragment>\n  #include <colorspace_fragment>\n  #include <fog_fragment>\n  #include <premultiplied_alpha_fragment>\n  #include <dithering_fragment>\n}\n\n// == main procedure ===========================================================\nvoid main() {\n  #include <clipping_planes_fragment>\n\n  vec2 uv = vec2(0.5, 0.5);\n\n  #if ( defined( MTOON_USE_UV ) && !defined( MTOON_UVS_VERTEX_ONLY ) )\n    uv = vUv;\n\n    float uvAnimMask = 1.0;\n    #ifdef USE_UVANIMATIONMASKTEXTURE\n      vec2 uvAnimationMaskTextureUv = ( uvAnimationMaskTextureUvTransform * vec3( uv, 1 ) ).xy;\n      uvAnimMask = texture2D( uvAnimationMaskTexture, uvAnimationMaskTextureUv ).b;\n    #endif\n\n    float uvRotCos = cos( uvAnimationRotationPhase * uvAnimMask );\n    float uvRotSin = sin( uvAnimationRotationPhase * uvAnimMask );\n    uv = mat2( uvRotCos, -uvRotSin, uvRotSin, uvRotCos ) * ( uv - 0.5 ) + 0.5;\n    uv = uv + vec2( uvAnimationScrollXOffset, uvAnimationScrollYOffset ) * uvAnimMask;\n  #endif\n\n  #ifdef DEBUG_UV\n    gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n    #if ( defined( MTOON_USE_UV ) && !defined( MTOON_UVS_VERTEX_ONLY ) )\n      gl_FragColor = vec4( uv, 0.0, 1.0 );\n    #endif\n    return;\n  #endif\n\n  vec4 diffuseColor = vec4( litFactor, opacity );\n  ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n  vec3 totalEmissiveRadiance = emissive * emissiveIntensity;\n\n  #include <logdepthbuf_fragment>\n\n  // #include <map_fragment>\n  #ifdef USE_MAP\n    vec2 mapUv = ( mapUvTransform * vec3( uv, 1 ) ).xy;\n    vec4 sampledDiffuseColor = texture2D( map, mapUv );\n    #ifdef DECODE_VIDEO_TEXTURE\n      sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n    #endif\n    diffuseColor *= sampledDiffuseColor;\n  #endif\n\n  // #include <color_fragment>\n  #if ( defined( USE_COLOR ) && !defined( IGNORE_VERTEX_COLOR ) )\n    diffuseColor.rgb *= vColor;\n  #endif\n\n  // #include <alphamap_fragment>\n\n  #include <alphatest_fragment>\n\n  // #include <specularmap_fragment>\n\n  // #include <normal_fragment_begin>\n  float faceDirection = gl_FrontFacing ? 1.0 : -1.0;\n\n  #ifdef FLAT_SHADED\n\n    vec3 fdx = dFdx( vViewPosition );\n    vec3 fdy = dFdy( vViewPosition );\n    vec3 normal = normalize( cross( fdx, fdy ) );\n\n  #else\n\n    vec3 normal = normalize( vNormal );\n\n    #ifdef DOUBLE_SIDED\n\n      normal *= faceDirection;\n\n    #endif\n\n  #endif\n\n  #ifdef USE_NORMALMAP\n\n    vec2 normalMapUv = ( normalMapUvTransform * vec3( uv, 1 ) ).xy;\n\n  #endif\n\n  #ifdef USE_NORMALMAP_TANGENTSPACE\n\n    #ifdef USE_TANGENT\n\n      mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\n    #else\n\n      mat3 tbn = getTangentFrame( - vViewPosition, normal, normalMapUv );\n\n    #endif\n\n    #if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\n      tbn[0] *= faceDirection;\n      tbn[1] *= faceDirection;\n\n    #endif\n\n  #endif\n\n  #ifdef USE_CLEARCOAT_NORMALMAP\n\n    #ifdef USE_TANGENT\n\n      mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\n    #else\n\n      mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\n    #endif\n\n    #if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\n      tbn2[0] *= faceDirection;\n      tbn2[1] *= faceDirection;\n\n    #endif\n\n  #endif\n\n  // non perturbed normal for clearcoat among others\n\n  vec3 nonPerturbedNormal = normal;\n\n  #ifdef OUTLINE\n    normal *= -1.0;\n  #endif\n\n  // #include <normal_fragment_maps>\n\n  // COMPAT: pre-r151\n  // USE_NORMALMAP_OBJECTSPACE used to be OBJECTSPACE_NORMALMAP in pre-r151\n  #if defined( USE_NORMALMAP_OBJECTSPACE ) || defined( OBJECTSPACE_NORMALMAP )\n\n    normal = texture2D( normalMap, normalMapUv ).xyz * 2.0 - 1.0; // overrides both flatShading and attribute normals\n\n    #ifdef FLIP_SIDED\n\n      normal = - normal;\n\n    #endif\n\n    #ifdef DOUBLE_SIDED\n\n      normal = normal * faceDirection;\n\n    #endif\n\n    normal = normalize( normalMatrix * normal );\n\n  // COMPAT: pre-r151\n  // USE_NORMALMAP_TANGENTSPACE used to be TANGENTSPACE_NORMALMAP in pre-r151\n  #elif defined( USE_NORMALMAP_TANGENTSPACE ) || defined( TANGENTSPACE_NORMALMAP )\n\n    vec3 mapN = texture2D( normalMap, normalMapUv ).xyz * 2.0 - 1.0;\n    mapN.xy *= normalScale;\n\n    // COMPAT: pre-r151\n    #if THREE_VRM_THREE_REVISION >= 151 || defined( USE_TANGENT )\n\n      normal = normalize( tbn * mapN );\n\n    #else\n\n      normal = perturbNormal2Arb( uv, -vViewPosition, normal, mapN, faceDirection );\n\n    #endif\n\n  #endif\n\n  // #include <emissivemap_fragment>\n  #ifdef USE_EMISSIVEMAP\n    vec2 emissiveMapUv = ( emissiveMapUvTransform * vec3( uv, 1 ) ).xy;\n    totalEmissiveRadiance *= texture2D( emissiveMap, emissiveMapUv ).rgb;\n  #endif\n\n  #ifdef DEBUG_NORMAL\n    gl_FragColor = vec4( 0.5 + 0.5 * normal, 1.0 );\n    return;\n  #endif\n\n  // -- MToon: lighting --------------------------------------------------------\n  // accumulation\n  // #include <lights_phong_fragment>\n  MToonMaterial material;\n\n  material.diffuseColor = diffuseColor.rgb;\n\n  material.shadeColor = shadeColorFactor;\n  #ifdef USE_SHADEMULTIPLYTEXTURE\n    vec2 shadeMultiplyTextureUv = ( shadeMultiplyTextureUvTransform * vec3( uv, 1 ) ).xy;\n    material.shadeColor *= texture2D( shadeMultiplyTexture, shadeMultiplyTextureUv ).rgb;\n  #endif\n\n  #if ( defined( USE_COLOR ) && !defined( IGNORE_VERTEX_COLOR ) )\n    material.shadeColor.rgb *= vColor;\n  #endif\n\n  material.shadingShift = shadingShiftFactor;\n  #ifdef USE_SHADINGSHIFTTEXTURE\n    vec2 shadingShiftTextureUv = ( shadingShiftTextureUvTransform * vec3( uv, 1 ) ).xy;\n    material.shadingShift += texture2D( shadingShiftTexture, shadingShiftTextureUv ).r * shadingShiftTextureScale;\n  #endif\n\n  // #include <lights_fragment_begin>\n\n  // MToon Specific changes:\n  // Since we want to take shadows into account of shading instead of irradiance,\n  // we had to modify the codes that multiplies the results of shadowmap into color of direct lights.\n\n  // COMPAT: pre-r156 uses a struct GeometricContext\n  #if THREE_VRM_THREE_REVISION >= 157\n    vec3 geometryPosition = - vViewPosition;\n    vec3 geometryNormal = normal;\n    vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n\n    vec3 geometryClearcoatNormal;\n\n    #ifdef USE_CLEARCOAT\n\n      geometryClearcoatNormal = clearcoatNormal;\n\n    #endif\n  #else\n    GeometricContext geometry;\n\n    geometry.position = - vViewPosition;\n    geometry.normal = normal;\n    geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n\n    #ifdef USE_CLEARCOAT\n\n      geometry.clearcoatNormal = clearcoatNormal;\n\n    #endif\n  #endif\n\n  IncidentLight directLight;\n\n  // since these variables will be used in unrolled loop, we have to define in prior\n  float shadow;\n\n  #if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\n    PointLight pointLight;\n    #if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n    PointLightShadow pointLightShadow;\n    #endif\n\n    #pragma unroll_loop_start\n    for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n      pointLight = pointLights[ i ];\n\n      // COMPAT: pre-r156 uses a struct GeometricContext\n      #if THREE_VRM_THREE_REVISION >= 157\n        getPointLightInfo( pointLight, geometryPosition, directLight );\n      #else\n        getPointLightInfo( pointLight, geometry, directLight );\n      #endif\n\n      shadow = 1.0;\n      #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n      pointLightShadow = pointLightShadows[ i ];\n      // COMPAT: pre-r166\n      // r166 introduced shadowIntensity\n      #if THREE_VRM_THREE_REVISION >= 166\n        shadow = all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n      #else\n        shadow = all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n      #endif\n      #endif\n\n      // COMPAT: pre-r156 uses a struct GeometricContext\n      #if THREE_VRM_THREE_REVISION >= 157\n        RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, shadow, reflectedLight );\n      #else\n        RE_Direct( directLight, geometry, material, shadow, reflectedLight );\n      #endif\n\n    }\n    #pragma unroll_loop_end\n\n  #endif\n\n  #if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\n    SpotLight spotLight;\n    // COMPAT: pre-r144 uses NUM_SPOT_LIGHT_SHADOWS, r144+ uses NUM_SPOT_LIGHT_COORDS\n    #if THREE_VRM_THREE_REVISION >= 144\n      #if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_COORDS > 0\n      SpotLightShadow spotLightShadow;\n      #endif\n    #elif defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n    SpotLightShadow spotLightShadow;\n    #endif\n\n    #pragma unroll_loop_start\n    for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n      spotLight = spotLights[ i ];\n\n      // COMPAT: pre-r156 uses a struct GeometricContext\n      #if THREE_VRM_THREE_REVISION >= 157\n        getSpotLightInfo( spotLight, geometryPosition, directLight );\n      #else\n        getSpotLightInfo( spotLight, geometry, directLight );\n      #endif\n\n      shadow = 1.0;\n      // COMPAT: pre-r144 uses NUM_SPOT_LIGHT_SHADOWS and vSpotShadowCoord, r144+ uses NUM_SPOT_LIGHT_COORDS and vSpotLightCoord\n      // COMPAT: pre-r166 does not have shadowIntensity, r166+ has shadowIntensity\n      #if THREE_VRM_THREE_REVISION >= 166\n        #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_COORDS )\n        spotLightShadow = spotLightShadows[ i ];\n        shadow = all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n        #endif\n      #elif THREE_VRM_THREE_REVISION >= 144\n        #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_COORDS )\n        spotLightShadow = spotLightShadows[ i ];\n        shadow = all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n        #endif\n      #elif defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n      spotLightShadow = spotLightShadows[ i ];\n      shadow = all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n      #endif\n\n      // COMPAT: pre-r156 uses a struct GeometricContext\n      #if THREE_VRM_THREE_REVISION >= 157\n        RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, shadow, reflectedLight );\n      #else\n        RE_Direct( directLight, geometry, material, shadow, reflectedLight );\n      #endif\n\n    }\n    #pragma unroll_loop_end\n\n  #endif\n\n  #if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\n    DirectionalLight directionalLight;\n    #if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n    DirectionalLightShadow directionalLightShadow;\n    #endif\n\n    #pragma unroll_loop_start\n    for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n      directionalLight = directionalLights[ i ];\n\n      // COMPAT: pre-r156 uses a struct GeometricContext\n      #if THREE_VRM_THREE_REVISION >= 157\n        getDirectionalLightInfo( directionalLight, directLight );\n      #else\n        getDirectionalLightInfo( directionalLight, geometry, directLight );\n      #endif\n\n      shadow = 1.0;\n      #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n      directionalLightShadow = directionalLightShadows[ i ];\n      // COMPAT: pre-r166\n      // r166 introduced shadowIntensity\n      #if THREE_VRM_THREE_REVISION >= 166\n        shadow = all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n      #else\n        shadow = all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n      #endif\n      #endif\n\n      // COMPAT: pre-r156 uses a struct GeometricContext\n      #if THREE_VRM_THREE_REVISION >= 157\n        RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, shadow, reflectedLight );\n      #else\n        RE_Direct( directLight, geometry, material, shadow, reflectedLight );\n      #endif\n\n    }\n    #pragma unroll_loop_end\n\n  #endif\n\n  // #if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\n  //   RectAreaLight rectAreaLight;\n\n  //   #pragma unroll_loop_start\n  //   for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\n  //     rectAreaLight = rectAreaLights[ i ];\n  //     RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\n  //   }\n  //   #pragma unroll_loop_end\n\n  // #endif\n\n  #if defined( RE_IndirectDiffuse )\n\n    vec3 iblIrradiance = vec3( 0.0 );\n\n    vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\n    // COMPAT: pre-r156 uses a struct GeometricContext\n    // COMPAT: pre-r156 doesn't have a define USE_LIGHT_PROBES\n    #if THREE_VRM_THREE_REVISION >= 157\n      #if defined( USE_LIGHT_PROBES )\n        irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n      #endif\n    #else\n      irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n    #endif\n\n    #if ( NUM_HEMI_LIGHTS > 0 )\n\n      #pragma unroll_loop_start\n      for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\n        // COMPAT: pre-r156 uses a struct GeometricContext\n        #if THREE_VRM_THREE_REVISION >= 157\n          irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n        #else\n          irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n        #endif\n\n      }\n      #pragma unroll_loop_end\n\n    #endif\n\n  #endif\n\n  // #if defined( RE_IndirectSpecular )\n\n  //   vec3 radiance = vec3( 0.0 );\n  //   vec3 clearcoatRadiance = vec3( 0.0 );\n\n  // #endif\n\n  #include <lights_fragment_maps>\n  #include <lights_fragment_end>\n\n  // modulation\n  #include <aomap_fragment>\n\n  vec3 col = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\n  #ifdef DEBUG_LITSHADERATE\n    gl_FragColor = vec4( col, diffuseColor.a );\n    postCorrection();\n    return;\n  #endif\n\n  // -- MToon: rim lighting -----------------------------------------\n  vec3 viewDir = normalize( vViewPosition );\n\n  #ifndef PHYSICALLY_CORRECT_LIGHTS\n    reflectedLight.directSpecular /= PI;\n  #endif\n  vec3 rimMix = mix( vec3( 1.0 ), reflectedLight.directSpecular, 1.0 );\n\n  vec3 rim = parametricRimColorFactor * pow( saturate( 1.0 - dot( viewDir, normal ) + parametricRimLiftFactor ), parametricRimFresnelPowerFactor );\n\n  #ifdef USE_MATCAPTEXTURE\n    {\n      vec3 x = normalize( vec3( viewDir.z, 0.0, -viewDir.x ) );\n      vec3 y = cross( viewDir, x ); // guaranteed to be normalized\n      vec2 sphereUv = 0.5 + 0.5 * vec2( dot( x, normal ), -dot( y, normal ) );\n      sphereUv = ( matcapTextureUvTransform * vec3( sphereUv, 1 ) ).xy;\n      vec3 matcap = texture2D( matcapTexture, sphereUv ).rgb;\n      rim += matcapFactor * matcap;\n    }\n  #endif\n\n  #ifdef USE_RIMMULTIPLYTEXTURE\n    vec2 rimMultiplyTextureUv = ( rimMultiplyTextureUvTransform * vec3( uv, 1 ) ).xy;\n    rim *= texture2D( rimMultiplyTexture, rimMultiplyTextureUv ).rgb;\n  #endif\n\n  col += rimMix * rim;\n\n  // -- MToon: Emission --------------------------------------------------------\n  col += totalEmissiveRadiance;\n\n  // #include <envmap_fragment>\n\n  // -- Almost done! -----------------------------------------------------------\n  #if defined( OUTLINE )\n    col = outlineColorFactor.rgb * mix( vec3( 1.0 ), col, outlineLightingMixFactor );\n  #endif\n\n  #ifdef OPAQUE\n    diffuseColor.a = 1.0;\n  #endif\n\n  gl_FragColor = vec4( col, diffuseColor.a );\n  postCorrection();\n}\n", "/* eslint-disable @typescript-eslint/naming-convention */\n\n/**\n * Specifiers of debug mode of {@link MToonMaterial}.\n *\n * See: {@link MToonMaterial.debugMode}\n */\nexport const MToonMaterialDebugMode = {\n  /**\n   * Render normally.\n   */\n  None: 'none',\n\n  /**\n   * Visualize normals of the surface.\n   */\n  Normal: 'normal',\n\n  /**\n   * Visualize lit/shade of the surface.\n   */\n  LitShadeRate: 'litShadeRate',\n\n  /**\n   * Visualize UV of the surface.\n   */\n  UV: 'uv',\n} as const;\n\nexport type MToonMaterialDebugMode = (typeof MToonMaterialDebugMode)[keyof typeof MToonMaterialDebugMode];\n", "/* eslint-disable @typescript-eslint/naming-convention */\n\nexport const MToonMaterialOutlineWidthMode = {\n  None: 'none',\n  WorldCoordinates: 'worldCoordinates',\n  ScreenCoordinates: 'screenCoordinates',\n} as const;\n\nexport type MToonMaterialOutlineWidthMode =\n  (typeof MToonMaterialOutlineWidthMode)[keyof typeof MToonMaterialOutlineWidthMode];\n", "import * as THREE from 'three';\n\nconst encodingColorSpaceMap: Record<any, '' | 'srgb'> = {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  3000: '',\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  3001: 'srgb',\n};\n\n/**\n * A compat function to get texture color space.\n *\n * COMPAT: pre-r152\n * Starting from Three.js r152, `texture.encoding` is renamed to `texture.colorSpace`.\n * This function will handle the comapt.\n *\n * @param texture The texture you want to get the color space from\n */\nexport function getTextureColorSpace(texture: THREE.Texture): '' | 'srgb' {\n  if (parseInt(THREE.REVISION, 10) >= 152) {\n    return texture.colorSpace as '' | 'srgb';\n  } else {\n    return encodingColorSpaceMap[(texture as any).encoding];\n  }\n}\n", "import { GLTFLoaderPlugin, GLTFParser } from 'three/examples/jsm/loaders/GLTFLoader.js';\nimport * as HDREmissiveMultiplierSchema from '@pixiv/types-vrmc-materials-hdr-emissive-multiplier-1.0';\nimport { GLTF as GLTFSchema } from '@gltf-transform/core';\n\nexport class VRMMaterialsHDREmissiveMultiplierLoaderPlugin implements GLTFLoaderPlugin {\n  public static EXTENSION_NAME = 'VRMC_materials_hdr_emissiveMultiplier' as const;\n\n  public readonly parser: GLTFParser;\n\n  public get name(): string {\n    return VRMMaterialsHDREmissiveMultiplierLoaderPlugin.EXTENSION_NAME;\n  }\n\n  public constructor(parser: GLTFParser) {\n    this.parser = parser;\n  }\n\n  public async extendMaterialParams(materialIndex: number, materialParams: { [key: string]: any }): Promise<void> {\n    const extension = this._getHDREmissiveMultiplierExtension(materialIndex);\n    if (extension == null) {\n      return;\n    }\n\n    // This extension is archived. Emit warning\n    // See: https://github.com/vrm-c/vrm-specification/pull/375\n    console.warn(\n      'VRMMaterialsHDREmissiveMultiplierLoaderPlugin: `VRMC_materials_hdr_emissiveMultiplier` is archived. Use `KHR_materials_emissive_strength` instead.',\n    );\n\n    const emissiveMultiplier = extension.emissiveMultiplier;\n    materialParams.emissiveIntensity = emissiveMultiplier;\n  }\n\n  private _getHDREmissiveMultiplierExtension(\n    materialIndex: number,\n  ): HDREmissiveMultiplierSchema.VRMCMaterialsHDREmissiveMultiplier | undefined {\n    const parser = this.parser;\n    const json = parser.json as GLTFSchema.IGLTF;\n\n    const materialDef = json.materials?.[materialIndex];\n\n    if (materialDef == null) {\n      console.warn(\n        `VRMMaterialsHDREmissiveMultiplierLoaderPlugin: Attempt to use materials[${materialIndex}] of glTF but the material doesn't exist`,\n      );\n      return undefined;\n    }\n\n    const extension = materialDef.extensions?.[VRMMaterialsHDREmissiveMultiplierLoaderPlugin.EXTENSION_NAME] as\n      | HDREmissiveMultiplierSchema.VRMCMaterialsHDREmissiveMultiplier\n      | undefined;\n    if (extension == null) {\n      return undefined;\n    }\n\n    return extension;\n  }\n}\n", "import * as THREE from 'three';\nimport { VRM as V0VRM, Material as V0Material } from '@pixiv/types-vrm-0.0';\nimport * as V1MToonSchema from '@pixiv/types-vrmc-materials-mtoon-1.0';\nimport type { GLTFLoaderPlugin, GLTFParser } from 'three/examples/jsm/loaders/GLTFLoader.js';\nimport { gammaEOTF } from './utils/gammaEOTF';\nimport { GLTF as GLTFSchema } from '@gltf-transform/core';\n\nexport class VRMMaterialsV0CompatPlugin implements GLTFLoaderPlugin {\n  public readonly parser: GLTFParser;\n\n  /**\n   * A map from v0 render queue to v1 render queue offset, for Transparent materials.\n   */\n  private readonly _renderQueueMapTransparent: Map<number, number>;\n\n  /**\n   * A map from v0 render queue to v1 render queue offset, for TransparentZWrite materials.\n   */\n  private readonly _renderQueueMapTransparentZWrite: Map<number, number>;\n\n  public get name(): string {\n    return 'VRMMaterialsV0CompatPlugin';\n  }\n\n  public constructor(parser: GLTFParser) {\n    this.parser = parser;\n\n    this._renderQueueMapTransparent = new Map();\n    this._renderQueueMapTransparentZWrite = new Map();\n\n    // WORKAROUND: Add KHR_texture_transform to extensionsUsed\n    // It is too late to add this in beforeRoot\n    const json = this.parser.json as GLTFSchema.IGLTF;\n\n    json.extensionsUsed = json.extensionsUsed ?? [];\n    if (json.extensionsUsed.indexOf('KHR_texture_transform') === -1) {\n      json.extensionsUsed.push('KHR_texture_transform');\n    }\n  }\n\n  public async beforeRoot(): Promise<void> {\n    const json = this.parser.json as GLTFSchema.IGLTF;\n\n    // early abort if it doesn't use V0VRM\n    const v0VRMExtension = json.extensions?.['VRM'] as V0VRM | undefined;\n    const v0MaterialProperties = v0VRMExtension?.materialProperties;\n    if (!v0MaterialProperties) {\n      return;\n    }\n\n    // populate render queue map\n    this._populateRenderQueueMap(v0MaterialProperties);\n\n    // convert V0 material properties into V1 compatible format\n    v0MaterialProperties.forEach((materialProperties, materialIndex) => {\n      const materialDef = json.materials?.[materialIndex];\n\n      if (materialDef == null) {\n        console.warn(\n          `VRMMaterialsV0CompatPlugin: Attempt to use materials[${materialIndex}] of glTF but the material doesn't exist`,\n        );\n        return;\n      }\n\n      if (materialProperties.shader === 'VRM/MToon') {\n        const material = this._parseV0MToonProperties(materialProperties, materialDef);\n        json.materials![materialIndex] = material;\n      } else if (materialProperties.shader?.startsWith('VRM/Unlit')) {\n        const material = this._parseV0UnlitProperties(materialProperties, materialDef);\n        json.materials![materialIndex] = material;\n      } else if (materialProperties.shader === 'VRM_USE_GLTFSHADER') {\n        // `json.materials[materialIndex]` should be already valid\n      } else {\n        console.warn(`VRMMaterialsV0CompatPlugin: Unknown shader: ${materialProperties.shader}`);\n      }\n    });\n  }\n\n  private _parseV0MToonProperties(\n    materialProperties: V0Material,\n    schemaMaterial: GLTFSchema.IMaterial,\n  ): GLTFSchema.IMaterial {\n    const isTransparent = materialProperties.keywordMap?.['_ALPHABLEND_ON'] ?? false;\n    const enabledZWrite = materialProperties.floatProperties?.['_ZWrite'] === 1;\n    const transparentWithZWrite = enabledZWrite && isTransparent;\n\n    const renderQueueOffsetNumber = this._v0ParseRenderQueue(materialProperties);\n\n    const isCutoff = materialProperties.keywordMap?.['_ALPHATEST_ON'] ?? false;\n    const alphaMode = isTransparent ? 'BLEND' : isCutoff ? 'MASK' : 'OPAQUE';\n    const alphaCutoff = isCutoff ? (materialProperties.floatProperties?.['_Cutoff'] ?? 0.5) : undefined;\n\n    const cullMode = materialProperties.floatProperties?.['_CullMode'] ?? 2; // enum, { Off, Front, Back }\n    const doubleSided = cullMode === 0;\n\n    const textureTransformExt = this._portTextureTransform(materialProperties);\n\n    const baseColorFactor = (materialProperties.vectorProperties?.['_Color'] ?? [1.0, 1.0, 1.0, 1.0]).map(\n      (v: number, i: number) => (i === 3 ? v : gammaEOTF(v)), // alpha channel is stored in linear\n    );\n    const baseColorTextureIndex = materialProperties.textureProperties?.['_MainTex'];\n    const baseColorTexture =\n      baseColorTextureIndex != null\n        ? {\n            index: baseColorTextureIndex,\n            extensions: {\n              ...textureTransformExt,\n            },\n          }\n        : undefined;\n\n    const normalTextureScale = materialProperties.floatProperties?.['_BumpScale'] ?? 1.0;\n    const normalTextureIndex = materialProperties.textureProperties?.['_BumpMap'];\n    const normalTexture =\n      normalTextureIndex != null\n        ? {\n            index: normalTextureIndex,\n            scale: normalTextureScale,\n            extensions: {\n              ...textureTransformExt,\n            },\n          }\n        : undefined;\n\n    const emissiveFactor = (materialProperties.vectorProperties?.['_EmissionColor'] ?? [0.0, 0.0, 0.0, 1.0]).map(\n      gammaEOTF,\n    );\n    const emissiveTextureIndex = materialProperties.textureProperties?.['_EmissionMap'];\n    const emissiveTexture =\n      emissiveTextureIndex != null\n        ? {\n            index: emissiveTextureIndex,\n            extensions: {\n              ...textureTransformExt,\n            },\n          }\n        : undefined;\n\n    const shadeColorFactor = (materialProperties.vectorProperties?.['_ShadeColor'] ?? [0.97, 0.81, 0.86, 1.0]).map(\n      gammaEOTF,\n    );\n    const shadeMultiplyTextureIndex = materialProperties.textureProperties?.['_ShadeTexture'];\n    const shadeMultiplyTexture =\n      shadeMultiplyTextureIndex != null\n        ? {\n            index: shadeMultiplyTextureIndex,\n            extensions: {\n              ...textureTransformExt,\n            },\n          }\n        : undefined;\n\n    // // convert v0 shade shift / shade toony\n    let shadingShiftFactor = materialProperties.floatProperties?.['_ShadeShift'] ?? 0.0;\n    let shadingToonyFactor = materialProperties.floatProperties?.['_ShadeToony'] ?? 0.9;\n    shadingToonyFactor = THREE.MathUtils.lerp(shadingToonyFactor, 1.0, 0.5 + 0.5 * shadingShiftFactor);\n    shadingShiftFactor = -shadingShiftFactor - (1.0 - shadingToonyFactor);\n\n    const giIntensityFactor = materialProperties.floatProperties?.['_IndirectLightIntensity'] ?? 0.1;\n    const giEqualizationFactor = giIntensityFactor ? 1.0 - giIntensityFactor : undefined;\n\n    const matcapTextureIndex = materialProperties.textureProperties?.['_SphereAdd'];\n    const matcapFactor = matcapTextureIndex != null ? [1.0, 1.0, 1.0] : undefined;\n    const matcapTexture =\n      matcapTextureIndex != null\n        ? {\n            index: matcapTextureIndex,\n          }\n        : undefined;\n\n    const rimLightingMixFactor = materialProperties.floatProperties?.['_RimLightingMix'] ?? 0.0;\n    const rimMultiplyTextureIndex = materialProperties.textureProperties?.['_RimTexture'];\n    const rimMultiplyTexture =\n      rimMultiplyTextureIndex != null\n        ? {\n            index: rimMultiplyTextureIndex,\n            extensions: {\n              ...textureTransformExt,\n            },\n          }\n        : undefined;\n\n    const parametricRimColorFactor = (materialProperties.vectorProperties?.['_RimColor'] ?? [0.0, 0.0, 0.0, 1.0]).map(\n      gammaEOTF,\n    );\n    const parametricRimFresnelPowerFactor = materialProperties.floatProperties?.['_RimFresnelPower'] ?? 1.0;\n    const parametricRimLiftFactor = materialProperties.floatProperties?.['_RimLift'] ?? 0.0;\n\n    const outlineWidthMode = ['none', 'worldCoordinates', 'screenCoordinates'][\n      materialProperties.floatProperties?.['_OutlineWidthMode'] ?? 0\n    ] as V1MToonSchema.MaterialsMToonOutlineWidthMode;\n\n    // // v0 outlineWidthFactor is in centimeter\n    let outlineWidthFactor = materialProperties.floatProperties?.['_OutlineWidth'] ?? 0.0;\n    outlineWidthFactor = 0.01 * outlineWidthFactor;\n\n    const outlineWidthMultiplyTextureIndex = materialProperties.textureProperties?.['_OutlineWidthTexture'];\n    const outlineWidthMultiplyTexture =\n      outlineWidthMultiplyTextureIndex != null\n        ? {\n            index: outlineWidthMultiplyTextureIndex,\n            extensions: {\n              ...textureTransformExt,\n            },\n          }\n        : undefined;\n\n    const outlineColorFactor = (materialProperties.vectorProperties?.['_OutlineColor'] ?? [0.0, 0.0, 0.0]).map(\n      gammaEOTF,\n    );\n    const outlineColorMode = materialProperties.floatProperties?.['_OutlineColorMode'] ?? 0; // enum, { Fixed, Mixed }\n    const outlineLightingMixFactor =\n      outlineColorMode === 1 ? (materialProperties.floatProperties?.['_OutlineLightingMix'] ?? 1.0) : 0.0;\n\n    const uvAnimationMaskTextureIndex = materialProperties.textureProperties?.['_UvAnimMaskTexture'];\n    const uvAnimationMaskTexture =\n      uvAnimationMaskTextureIndex != null\n        ? {\n            index: uvAnimationMaskTextureIndex,\n            extensions: {\n              ...textureTransformExt,\n            },\n          }\n        : undefined;\n\n    const uvAnimationScrollXSpeedFactor = materialProperties.floatProperties?.['_UvAnimScrollX'] ?? 0.0;\n\n    // uvAnimationScrollYSpeedFactor will be opposite between V0 and V1\n    let uvAnimationScrollYSpeedFactor = materialProperties.floatProperties?.['_UvAnimScrollY'] ?? 0.0;\n    if (uvAnimationScrollYSpeedFactor != null) {\n      uvAnimationScrollYSpeedFactor = -uvAnimationScrollYSpeedFactor;\n    }\n\n    const uvAnimationRotationSpeedFactor = materialProperties.floatProperties?.['_UvAnimRotation'] ?? 0.0;\n\n    const mtoonExtension: V1MToonSchema.VRMCMaterialsMToon = {\n      specVersion: '1.0',\n      transparentWithZWrite,\n      renderQueueOffsetNumber,\n      shadeColorFactor,\n      shadeMultiplyTexture,\n      shadingShiftFactor,\n      shadingToonyFactor,\n      giEqualizationFactor,\n      matcapFactor,\n      matcapTexture,\n      rimLightingMixFactor,\n      rimMultiplyTexture,\n      parametricRimColorFactor,\n      parametricRimFresnelPowerFactor,\n      parametricRimLiftFactor,\n      outlineWidthMode,\n      outlineWidthFactor,\n      outlineWidthMultiplyTexture,\n      outlineColorFactor,\n      outlineLightingMixFactor,\n      uvAnimationMaskTexture,\n      uvAnimationScrollXSpeedFactor,\n      uvAnimationScrollYSpeedFactor,\n      uvAnimationRotationSpeedFactor,\n    };\n\n    return {\n      ...schemaMaterial,\n\n      pbrMetallicRoughness: {\n        baseColorFactor,\n        baseColorTexture,\n      },\n      normalTexture,\n      emissiveTexture,\n      emissiveFactor,\n      alphaMode,\n      alphaCutoff,\n      doubleSided,\n      extensions: {\n        // eslint-disable-next-line @typescript-eslint/naming-convention\n        VRMC_materials_mtoon: mtoonExtension,\n      },\n    };\n  }\n\n  private _parseV0UnlitProperties(\n    materialProperties: V0Material,\n    schemaMaterial: GLTFSchema.IMaterial,\n  ): GLTFSchema.IMaterial {\n    const isTransparentZWrite = materialProperties.shader === 'VRM/UnlitTransparentZWrite';\n    const isTransparent = materialProperties.shader === 'VRM/UnlitTransparent' || isTransparentZWrite;\n\n    const renderQueueOffsetNumber = this._v0ParseRenderQueue(materialProperties);\n\n    const isCutoff = materialProperties.shader === 'VRM/UnlitCutout';\n    const alphaMode = isTransparent ? 'BLEND' : isCutoff ? 'MASK' : 'OPAQUE';\n    const alphaCutoff = isCutoff ? (materialProperties.floatProperties?.['_Cutoff'] ?? 0.5) : undefined;\n\n    const textureTransformExt = this._portTextureTransform(materialProperties);\n\n    const baseColorFactor = (materialProperties.vectorProperties?.['_Color'] ?? [1.0, 1.0, 1.0, 1.0]).map(gammaEOTF);\n    const baseColorTextureIndex = materialProperties.textureProperties?.['_MainTex'];\n    const baseColorTexture =\n      baseColorTextureIndex != null\n        ? {\n            index: baseColorTextureIndex,\n            extensions: {\n              ...textureTransformExt,\n            },\n          }\n        : undefined;\n\n    // use mtoon instead of unlit, since there might be VRM0.0 specific features that are not supported by gltf\n    const mtoonExtension: V1MToonSchema.VRMCMaterialsMToon = {\n      specVersion: '1.0',\n      transparentWithZWrite: isTransparentZWrite,\n      renderQueueOffsetNumber,\n      shadeColorFactor: baseColorFactor,\n      shadeMultiplyTexture: baseColorTexture,\n    };\n\n    return {\n      ...schemaMaterial,\n\n      pbrMetallicRoughness: {\n        baseColorFactor,\n        baseColorTexture,\n      },\n      alphaMode,\n      alphaCutoff,\n      extensions: {\n        // eslint-disable-next-line @typescript-eslint/naming-convention\n        VRMC_materials_mtoon: mtoonExtension,\n      },\n    };\n  }\n\n  /**\n   * Create a glTF `KHR_texture_transform` extension from v0 texture transform info.\n   */\n  private _portTextureTransform(materialProperties: V0Material): { [name: string]: any } {\n    const textureTransform = materialProperties.vectorProperties?.['_MainTex'];\n    if (textureTransform == null) {\n      return {};\n    }\n\n    const offset = [textureTransform?.[0] ?? 0.0, textureTransform?.[1] ?? 0.0];\n    const scale = [textureTransform?.[2] ?? 1.0, textureTransform?.[3] ?? 1.0];\n\n    offset[1] = 1.0 - scale[1] - offset[1];\n\n    return {\n      // eslint-disable-next-line @typescript-eslint/naming-convention\n      KHR_texture_transform: { offset, scale },\n    };\n  }\n\n  /**\n   * Convert v0 render order into v1 render order.\n   * This uses a map from v0 render queue to v1 compliant render queue offset which is generated in {@link _populateRenderQueueMap}.\n   */\n  private _v0ParseRenderQueue(materialProperties: V0Material): number {\n    const isTransparentZWrite = materialProperties.shader === 'VRM/UnlitTransparentZWrite';\n    const isTransparent =\n      materialProperties.keywordMap?.['_ALPHABLEND_ON'] != undefined ||\n      materialProperties.shader === 'VRM/UnlitTransparent' ||\n      isTransparentZWrite;\n    const enabledZWrite = materialProperties.floatProperties?.['_ZWrite'] === 1 || isTransparentZWrite;\n\n    let offset = 0;\n\n    if (isTransparent) {\n      const v0Queue = materialProperties.renderQueue;\n\n      if (v0Queue != null) {\n        if (enabledZWrite) {\n          offset = this._renderQueueMapTransparentZWrite.get(v0Queue)!;\n        } else {\n          offset = this._renderQueueMapTransparent.get(v0Queue)!;\n        }\n      }\n    }\n\n    return offset;\n  }\n\n  /**\n   * Create a map which maps v0 render queue to v1 compliant render queue offset.\n   * This lists up all render queues the model use and creates a map to new render queue offsets in the same order.\n   */\n  private _populateRenderQueueMap(materialPropertiesList: V0Material[]) {\n    /**\n     * A set of used render queues in Transparent materials.\n     */\n    const renderQueuesTransparent = new Set<number>();\n\n    /**\n     * A set of used render queues in TransparentZWrite materials.\n     */\n    const renderQueuesTransparentZWrite = new Set<number>();\n\n    // populate the render queue set\n    materialPropertiesList.forEach((materialProperties) => {\n      const isTransparentZWrite = materialProperties.shader === 'VRM/UnlitTransparentZWrite';\n      const isTransparent =\n        materialProperties.keywordMap?.['_ALPHABLEND_ON'] != undefined ||\n        materialProperties.shader === 'VRM/UnlitTransparent' ||\n        isTransparentZWrite;\n      const enabledZWrite = materialProperties.floatProperties?.['_ZWrite'] === 1 || isTransparentZWrite;\n\n      if (isTransparent) {\n        const v0Queue = materialProperties.renderQueue;\n\n        if (v0Queue != null) {\n          if (enabledZWrite) {\n            renderQueuesTransparentZWrite.add(v0Queue);\n          } else {\n            renderQueuesTransparent.add(v0Queue);\n          }\n        }\n      }\n    });\n\n    // show a warning if the model uses v1 incompatible number of render queues\n    if (renderQueuesTransparent.size > 10) {\n      console.warn(\n        `VRMMaterialsV0CompatPlugin: This VRM uses ${renderQueuesTransparent.size} render queues for Transparent materials while VRM 1.0 only supports up to 10 render queues. The model might not be rendered correctly.`,\n      );\n    }\n\n    if (renderQueuesTransparentZWrite.size > 10) {\n      console.warn(\n        `VRMMaterialsV0CompatPlugin: This VRM uses ${renderQueuesTransparentZWrite.size} render queues for TransparentZWrite materials while VRM 1.0 only supports up to 10 render queues. The model might not be rendered correctly.`,\n      );\n    }\n\n    // create a map from v0 render queue to v1 render queue offset\n    Array.from(renderQueuesTransparent)\n      .sort()\n      .forEach((queue, i) => {\n        const newQueueOffset = Math.min(Math.max(i - renderQueuesTransparent.size + 1, -9), 0);\n        this._renderQueueMapTransparent.set(queue, newQueueOffset);\n      });\n\n    Array.from(renderQueuesTransparentZWrite)\n      .sort()\n      .forEach((queue, i) => {\n        const newQueueOffset = Math.min(Math.max(i, 0), 9);\n        this._renderQueueMapTransparentZWrite.set(queue, newQueueOffset);\n      });\n  }\n}\n", "export function gammaEOTF(e: number): number {\n  return Math.pow(e, 2.2);\n}\n", "import * as THREE from 'three';\nimport { VRMNodeConstraint } from '../VRMNodeConstraint';\n\nconst _v3A = new THREE.Vector3();\n\nexport class VRMNodeConstraintHelper extends THREE.Group {\n  public readonly constraint: VRMNodeConstraint;\n  private _line: THREE.Line;\n  private _attrPosition: THREE.BufferAttribute;\n\n  public constructor(constraint: VRMNodeConstraint) {\n    super();\n\n    this._attrPosition = new THREE.BufferAttribute(new Float32Array([0, 0, 0, 0, 0, 0]), 3);\n    this._attrPosition.setUsage(THREE.DynamicDrawUsage);\n\n    const geometry = new THREE.BufferGeometry();\n    geometry.setAttribute('position', this._attrPosition);\n\n    const material = new THREE.LineBasicMaterial({\n      color: 0xff00ff,\n      depthTest: false,\n      depthWrite: false,\n    });\n\n    this._line = new THREE.Line(geometry, material);\n    this.add(this._line);\n\n    this.constraint = constraint;\n  }\n\n  public updateMatrixWorld(force?: boolean): void {\n    _v3A.setFromMatrixPosition(this.constraint.destination.matrixWorld);\n    this._attrPosition.setXYZ(0, _v3A.x, _v3A.y, _v3A.z);\n\n    if (this.constraint.source) {\n      _v3A.setFromMatrixPosition(this.constraint.source.matrixWorld);\n    }\n    this._attrPosition.setXYZ(1, _v3A.x, _v3A.y, _v3A.z);\n\n    this._attrPosition.needsUpdate = true;\n\n    super.updateMatrixWorld(force);\n  }\n}\n", "import * as THREE from 'three';\nimport { decomposePosition } from './utils/decomposePosition';\nimport { decomposeRotation } from './utils/decomposeRotation';\nimport { quatInvertCompat } from './utils/quatInvertCompat';\nimport { VRMNodeConstraint } from './VRMNodeConstraint';\n\nconst _v3A = new THREE.Vector3();\nconst _v3B = new THREE.Vector3();\nconst _v3C = new THREE.Vector3();\nconst _quatA = new THREE.Quaternion();\nconst _quatB = new THREE.Quaternion();\nconst _quatC = new THREE.Quaternion();\n\n/**\n * A constraint that makes it look at a source object.\n *\n * See: https://github.com/vrm-c/vrm-specification/tree/master/specification/VRMC_node_constraint-1.0_beta#roll-constraint\n */\nexport class VRMAimConstraint extends VRMNodeConstraint {\n  /**\n   * The aim axis of the constraint.\n   */\n  public get aimAxis(): 'PositiveX' | 'NegativeX' | 'PositiveY' | 'NegativeY' | 'PositiveZ' | 'NegativeZ' {\n    return this._aimAxis;\n  }\n\n  /**\n   * The aim axis of the constraint.\n   */\n  public set aimAxis(aimAxis: 'PositiveX' | 'NegativeX' | 'PositiveY' | 'NegativeY' | 'PositiveZ' | 'NegativeZ') {\n    this._aimAxis = aimAxis;\n    this._v3AimAxis.set(\n      aimAxis === 'PositiveX' ? 1.0 : aimAxis === 'NegativeX' ? -1.0 : 0.0,\n      aimAxis === 'PositiveY' ? 1.0 : aimAxis === 'NegativeY' ? -1.0 : 0.0,\n      aimAxis === 'PositiveZ' ? 1.0 : aimAxis === 'NegativeZ' ? -1.0 : 0.0,\n    );\n  }\n\n  /**\n   * The aim axis of the constraint.\n   */\n  private _aimAxis: 'PositiveX' | 'NegativeX' | 'PositiveY' | 'NegativeY' | 'PositiveZ' | 'NegativeZ';\n\n  /**\n   * The {@link _aimAxis} but in an actual Vector3 form.\n   */\n  private _v3AimAxis: THREE.Vector3;\n\n  /**\n   * The rest quaternion of the {@link destination}.\n   */\n  private _dstRestQuat: THREE.Quaternion;\n\n  public get dependencies(): Set<THREE.Object3D> {\n    const set = new Set<THREE.Object3D>([this.source]);\n\n    if (this.destination.parent) {\n      set.add(this.destination.parent);\n    }\n\n    return set;\n  }\n\n  public constructor(destination: THREE.Object3D, source: THREE.Object3D) {\n    super(destination, source);\n\n    this._aimAxis = 'PositiveX';\n    this._v3AimAxis = new THREE.Vector3(1, 0, 0);\n\n    this._dstRestQuat = new THREE.Quaternion();\n  }\n\n  public setInitState(): void {\n    this._dstRestQuat.copy(this.destination.quaternion);\n  }\n\n  public update(): void {\n    // update world matrix of destination and source manually\n    this.destination.updateWorldMatrix(true, false);\n    this.source.updateWorldMatrix(true, false);\n\n    // get world quaternion of the parent of the destination\n    const dstParentWorldQuat = _quatA.identity();\n    const invDstParentWorldQuat = _quatB.identity();\n    if (this.destination.parent) {\n      decomposeRotation(this.destination.parent.matrixWorld, dstParentWorldQuat);\n      quatInvertCompat(invDstParentWorldQuat.copy(dstParentWorldQuat));\n    }\n\n    // calculate from-to vectors in world coord\n    const a0 = _v3A.copy(this._v3AimAxis).applyQuaternion(this._dstRestQuat).applyQuaternion(dstParentWorldQuat);\n    const a1 = decomposePosition(this.source.matrixWorld, _v3B)\n      .sub(decomposePosition(this.destination.matrixWorld, _v3C))\n      .normalize();\n\n    // create a from-to quaternion, convert to destination local coord, then multiply rest quaternion\n    const targetQuat = _quatC\n      .setFromUnitVectors(a0, a1)\n      .premultiply(invDstParentWorldQuat)\n      .multiply(dstParentWorldQuat)\n      .multiply(this._dstRestQuat);\n\n    // blend with the rest quaternion using weight\n    this.destination.quaternion.copy(this._dstRestQuat).slerp(targetQuat, this.weight);\n  }\n}\n", "import * as THREE from 'three';\n\nexport function decomposePosition<T extends THREE.Vector3>(matrix: THREE.Matrix4, target: T): T {\n  return target.set(matrix.elements[12], matrix.elements[13], matrix.elements[14]);\n}\n", "import * as THREE from 'three';\n\nconst _v3A = new THREE.Vector3();\nconst _v3B = new THREE.Vector3();\n\nexport function decomposeRotation<T extends THREE.Quaternion>(matrix: THREE.Matrix4, target: T): T {\n  matrix.decompose(_v3A, target, _v3B);\n  return target;\n}\n", "import * as THREE from 'three';\n\n/**\n * A compat function for `Quaternion.invert()` / `Quaternion.inverse()`.\n * `Quaternion.invert()` is introduced in r123 and `Quaternion.inverse()` emits a warning.\n * We are going to use this compat for a while.\n * @param target A target quaternion\n */\nexport function quatInvertCompat<T extends THREE.Quaternion>(target: T): T {\n  if ((target as any).invert) {\n    target.invert();\n  } else {\n    (target as any).inverse();\n  }\n\n  return target;\n}\n", "import * as THREE from 'three';\n\n/**\n * A base class of VRM constraint classes.\n */\nexport abstract class VRMNodeConstraint {\n  /**\n   * The object being constrained by the {@link source}.\n   */\n  public destination: THREE.Object3D;\n\n  /**\n   * The object constrains the {@link destination}.\n   */\n  public source: THREE.Object3D;\n\n  /**\n   * The weight of the constraint.\n   */\n  public weight: number;\n\n  public abstract get dependencies(): Set<THREE.Object3D>;\n\n  /**\n   * @param destination The destination object\n   * @param source The source object\n   */\n  public constructor(destination: THREE.Object3D, source: THREE.Object3D) {\n    this.destination = destination;\n    this.source = source;\n\n    this.weight = 1.0;\n  }\n\n  /**\n   * Set initial state of the constraint.\n   */\n  public abstract setInitState(): void;\n\n  /**\n   * Update and apply the constraint.\n   */\n  public abstract update(): void;\n}\n", "import type * as THREE from 'three';\n\n/**\n * Traverse ancestors of given object and call given callback from root side.\n * It will include the given object itself.\n *\n * @param object The object you want to traverse\n * @param callback The call back function that will be called for each ancestors\n */\nexport function traverseAncestorsFromRoot(object: THREE.Object3D, callback: (object: THREE.Object3D) => void): void {\n  const ancestors: THREE.Object3D[] = [object];\n\n  let head: THREE.Object3D | null = object.parent;\n  while (head !== null) {\n    ancestors.unshift(head);\n    head = head.parent;\n  }\n\n  ancestors.forEach((ancestor) => {\n    callback(ancestor);\n  });\n}\n", "import type * as THREE from 'three';\nimport type { VRMNodeConstraint } from './VRMNodeConstraint';\nimport { traverseAncestorsFromRoot } from './utils/traverseAncestorsFromRoot';\n\nexport class VRMNodeConstraintManager {\n  private _constraints = new Set<VRMNodeConstraint>();\n  public get constraints(): Set<VRMNodeConstraint> {\n    return this._constraints;\n  }\n\n  private _objectConstraintsMap = new Map<THREE.Object3D, Set<VRMNodeConstraint>>();\n\n  public addConstraint(constraint: VRMNodeConstraint): void {\n    this._constraints.add(constraint);\n\n    let objectSet = this._objectConstraintsMap.get(constraint.destination);\n    if (objectSet == null) {\n      objectSet = new Set<VRMNodeConstraint>();\n      this._objectConstraintsMap.set(constraint.destination, objectSet);\n    }\n    objectSet.add(constraint);\n  }\n\n  public deleteConstraint(constraint: VRMNodeConstraint): void {\n    this._constraints.delete(constraint);\n\n    const objectSet = this._objectConstraintsMap.get(constraint.destination)!;\n    objectSet.delete(constraint);\n  }\n\n  public setInitState(): void {\n    const constraintsTried = new Set<VRMNodeConstraint>();\n    const constraintsDone = new Set<VRMNodeConstraint>();\n\n    for (const constraint of this._constraints) {\n      this._processConstraint(constraint, constraintsTried, constraintsDone, (constraint) => constraint.setInitState());\n    }\n  }\n\n  public update(): void {\n    const constraintsTried = new Set<VRMNodeConstraint>();\n    const constraintsDone = new Set<VRMNodeConstraint>();\n\n    for (const constraint of this._constraints) {\n      this._processConstraint(constraint, constraintsTried, constraintsDone, (constraint) => constraint.update());\n    }\n  }\n\n  /**\n   * Update a constraint.\n   * If there are other constraints that are dependant, it will try to update them recursively.\n   * It might throw an error if there are circular dependencies.\n   *\n   * Intended to be used in {@link update} and {@link _processConstraint} itself recursively.\n   *\n   * @param constraint A constraint you want to update\n   * @param constraintsTried Set of constraints that are already tried to be updated\n   * @param constraintsDone Set of constraints that are already up to date\n   */\n  private _processConstraint(\n    constraint: VRMNodeConstraint,\n    constraintsTried: Set<VRMNodeConstraint>,\n    constraintsDone: Set<VRMNodeConstraint>,\n    callback: (constraint: VRMNodeConstraint) => void,\n  ): void {\n    if (constraintsDone.has(constraint)) {\n      return;\n    }\n\n    if (constraintsTried.has(constraint)) {\n      throw new Error('VRMNodeConstraintManager: Circular dependency detected while updating constraints');\n    }\n    constraintsTried.add(constraint);\n\n    const depObjects = constraint.dependencies;\n    for (const depObject of depObjects) {\n      traverseAncestorsFromRoot(depObject, (depObjectAncestor) => {\n        const objectSet = this._objectConstraintsMap.get(depObjectAncestor);\n        if (objectSet) {\n          for (const depConstraint of objectSet) {\n            this._processConstraint(depConstraint, constraintsTried, constraintsDone, callback);\n          }\n        }\n      });\n    }\n\n    callback(constraint);\n\n    constraintsDone.add(constraint);\n  }\n}\n", "import * as THREE from 'three';\nimport { quatInvertCompat } from './utils/quatInvertCompat';\nimport { VRMNodeConstraint } from './VRMNodeConstraint';\n\nconst _quatA = new THREE.Quaternion();\nconst _quatB = new THREE.Quaternion();\n\n/**\n * A constraint that transfers a rotation around one axis of a source.\n *\n * See: https://github.com/vrm-c/vrm-specification/tree/master/specification/VRMC_node_constraint-1.0_beta#roll-constraint\n */\nexport class VRMRotationConstraint extends VRMNodeConstraint {\n  /**\n   * The rest quaternion of the {@link destination}.\n   */\n  private _dstRestQuat: THREE.Quaternion;\n\n  /**\n   * The inverse of the rest quaternion of the {@link source}.\n   */\n  private _invSrcRestQuat: THREE.Quaternion;\n\n  public get dependencies(): Set<THREE.Object3D> {\n    return new Set([this.source]);\n  }\n\n  public constructor(destination: THREE.Object3D, source: THREE.Object3D) {\n    super(destination, source);\n\n    this._dstRestQuat = new THREE.Quaternion();\n    this._invSrcRestQuat = new THREE.Quaternion();\n  }\n\n  public setInitState(): void {\n    this._dstRestQuat.copy(this.destination.quaternion);\n    quatInvertCompat(this._invSrcRestQuat.copy(this.source.quaternion));\n  }\n\n  public update(): void {\n    // calculate the delta rotation from the rest about the source\n    const srcDeltaQuat = _quatA.copy(this._invSrcRestQuat).multiply(this.source.quaternion);\n\n    // multiply the delta to the rest of the destination\n    const targetQuat = _quatB.copy(this._dstRestQuat).multiply(srcDeltaQuat);\n\n    // blend with the rest quaternion using weight\n    this.destination.quaternion.copy(this._dstRestQuat).slerp(targetQuat, this.weight);\n  }\n}\n", "import * as THREE from 'three';\nimport { quatInvertCompat } from './utils/quatInvertCompat';\nimport { VRMNodeConstraint } from './VRMNodeConstraint';\n\nconst _v3A = new THREE.Vector3();\nconst _quatA = new THREE.Quaternion();\nconst _quatB = new THREE.Quaternion();\n\n/**\n * A constraint that transfers a rotation around one axis of a source.\n *\n * See: https://github.com/vrm-c/vrm-specification/tree/master/specification/VRMC_node_constraint-1.0_beta#roll-constraint\n */\nexport class VRMRollConstraint extends VRMNodeConstraint {\n  /**\n   * The roll axis of the constraint.\n   */\n  public get rollAxis(): 'X' | 'Y' | 'Z' {\n    return this._rollAxis;\n  }\n\n  /**\n   * The roll axis of the constraint.\n   */\n  public set rollAxis(rollAxis: 'X' | 'Y' | 'Z') {\n    this._rollAxis = rollAxis;\n    this._v3RollAxis.set(rollAxis === 'X' ? 1.0 : 0.0, rollAxis === 'Y' ? 1.0 : 0.0, rollAxis === 'Z' ? 1.0 : 0.0);\n  }\n\n  /**\n   * The roll axis of the constraint.\n   */\n  private _rollAxis: 'X' | 'Y' | 'Z';\n\n  /**\n   * The {@link _rollAxis} but in an actual Vector3 form.\n   */\n  private _v3RollAxis: THREE.Vector3;\n\n  /**\n   * The rest quaternion of the {@link destination}.\n   */\n  private _dstRestQuat: THREE.Quaternion;\n\n  /**\n   * The inverse of the rest quaternion of the {@link destination}.\n   */\n  private _invDstRestQuat: THREE.Quaternion;\n\n  /**\n   * `srcRestQuat.invert() * dstRestQuat`.\n   */\n  private _invSrcRestQuatMulDstRestQuat: THREE.Quaternion;\n\n  public get dependencies(): Set<THREE.Object3D> {\n    return new Set([this.source]);\n  }\n\n  public constructor(destination: THREE.Object3D, source: THREE.Object3D) {\n    super(destination, source);\n\n    this._rollAxis = 'X';\n    this._v3RollAxis = new THREE.Vector3(1, 0, 0);\n\n    this._dstRestQuat = new THREE.Quaternion();\n    this._invDstRestQuat = new THREE.Quaternion();\n    this._invSrcRestQuatMulDstRestQuat = new THREE.Quaternion();\n  }\n\n  public setInitState(): void {\n    this._dstRestQuat.copy(this.destination.quaternion);\n    quatInvertCompat(this._invDstRestQuat.copy(this._dstRestQuat));\n    quatInvertCompat(this._invSrcRestQuatMulDstRestQuat.copy(this.source.quaternion)).multiply(this._dstRestQuat);\n  }\n\n  public update(): void {\n    // calculate the delta rotation from the rest about the source, then convert to the destination local coord\n    /**\n     * What the quatDelta is intended to be:\n     *\n     * ```ts\n     * const quatSrcDelta = _quatA\n     *   .copy( this._invSrcRestQuat )\n     *   .multiply( this.source.quaternion );\n     * const quatSrcDeltaInParent = _quatB\n     *   .copy( this._srcRestQuat )\n     *   .multiply( quatSrcDelta )\n     *   .multiply( this._invSrcRestQuat );\n     * const quatSrcDeltaInDst = _quatA\n     *   .copy( this._invDstRestQuat )\n     *   .multiply( quatSrcDeltaInParent )\n     *   .multiply( this._dstRestQuat );\n     * ```\n     */\n    const quatDelta = _quatA\n      .copy(this._invDstRestQuat)\n      .multiply(this.source.quaternion)\n      .multiply(this._invSrcRestQuatMulDstRestQuat);\n\n    // create a from-to quaternion\n    const n1 = _v3A.copy(this._v3RollAxis).applyQuaternion(quatDelta);\n\n    /**\n     * What the quatFromTo is intended to be:\n     *\n     * ```ts\n     * const quatFromTo = _quatB.setFromUnitVectors( this._v3RollAxis, n1 ).inverse();\n     * ```\n     */\n    const quatFromTo = _quatB.setFromUnitVectors(n1, this._v3RollAxis);\n\n    // quatFromTo * quatDelta == roll extracted from quatDelta\n    const targetQuat = quatFromTo.premultiply(this._dstRestQuat).multiply(quatDelta);\n\n    // blend with the rest quaternion using weight\n    this.destination.quaternion.copy(this._dstRestQuat).slerp(targetQuat, this.weight);\n  }\n}\n", "import type * as ConstraintSchema from '@pixiv/types-vrmc-node-constraint-1.0';\nimport type * as THREE from 'three';\nimport type { GLTF, GLTFLoaderPlugin, GLTFParser } from 'three/examples/jsm/loaders/GLTFLoader.js';\nimport { VRMNodeConstraintHelper } from './helpers';\nimport type { VRMNodeConstraintLoaderPluginOptions } from './VRMNodeConstraintLoaderPluginOptions';\nimport { VRMNodeConstraintManager } from './VRMNodeConstraintManager';\nimport { VRMRotationConstraint } from './VRMRotationConstraint';\nimport { GLTF as GLTFSchema } from '@gltf-transform/core';\nimport { VRMAimConstraint } from './VRMAimConstraint';\nimport { VRMRollConstraint } from './VRMRollConstraint';\n\n/**\n * Possible spec versions it recognizes.\n */\nconst POSSIBLE_SPEC_VERSIONS = new Set(['1.0', '1.0-beta']);\n\nexport class VRMNodeConstraintLoaderPlugin implements GLTFLoaderPlugin {\n  public static readonly EXTENSION_NAME = 'VRMC_node_constraint';\n\n  /**\n   * Specify an Object3D to add {@link VRMNodeConstraintHelper} s.\n   * If not specified, helper will not be created.\n   * If `renderOrder` is set to the root, helpers will copy the same `renderOrder` .\n   */\n  public helperRoot?: THREE.Object3D;\n\n  public readonly parser: GLTFParser;\n\n  public get name(): string {\n    return VRMNodeConstraintLoaderPlugin.EXTENSION_NAME;\n  }\n\n  public constructor(parser: GLTFParser, options?: VRMNodeConstraintLoaderPluginOptions) {\n    this.parser = parser;\n\n    this.helperRoot = options?.helperRoot;\n  }\n\n  public async afterRoot(gltf: GLTF): Promise<void> {\n    gltf.userData.vrmNodeConstraintManager = await this._import(gltf);\n  }\n\n  /**\n   * Import constraints from a GLTF and returns a {@link VRMNodeConstraintManager}.\n   * It might return `null` instead when it does not need to be created or something go wrong.\n   *\n   * @param gltf A parsed result of GLTF taken from GLTFLoader\n   */\n  protected async _import(gltf: GLTF): Promise<VRMNodeConstraintManager | null> {\n    const json = this.parser.json as GLTFSchema.IGLTF;\n\n    // early abort if it doesn't use constraints\n    const isConstraintsUsed = json.extensionsUsed?.indexOf(VRMNodeConstraintLoaderPlugin.EXTENSION_NAME) !== -1;\n    if (!isConstraintsUsed) {\n      return null;\n    }\n\n    const manager = new VRMNodeConstraintManager();\n    const threeNodes: THREE.Object3D[] = await this.parser.getDependencies('node');\n\n    // import constraints for each nodes\n    threeNodes.forEach((node, nodeIndex) => {\n      const schemaNode = json.nodes![nodeIndex];\n\n      // check if the extension uses the extension\n      const extension = schemaNode?.extensions?.[VRMNodeConstraintLoaderPlugin.EXTENSION_NAME] as\n        | ConstraintSchema.VRMCNodeConstraint\n        | undefined;\n\n      if (extension == null) {\n        return;\n      }\n\n      const specVersion = extension.specVersion;\n      if (!POSSIBLE_SPEC_VERSIONS.has(specVersion)) {\n        console.warn(\n          `VRMNodeConstraintLoaderPlugin: Unknown ${VRMNodeConstraintLoaderPlugin.EXTENSION_NAME} specVersion \"${specVersion}\"`,\n        );\n        return;\n      }\n\n      const constraintDef = extension.constraint;\n\n      // import constraints\n      if (constraintDef.roll != null) {\n        const constraint = this._importRollConstraint(node, threeNodes, constraintDef.roll);\n        manager.addConstraint(constraint);\n      } else if (constraintDef.aim != null) {\n        const constraint = this._importAimConstraint(node, threeNodes, constraintDef.aim);\n        manager.addConstraint(constraint);\n      } else if (constraintDef.rotation != null) {\n        const constraint = this._importRotationConstraint(node, threeNodes, constraintDef.rotation);\n        manager.addConstraint(constraint);\n      }\n    });\n\n    // init constraints\n    gltf.scene.updateMatrixWorld();\n    manager.setInitState();\n\n    return manager;\n  }\n\n  protected _importRollConstraint(\n    destination: THREE.Object3D,\n    nodes: THREE.Object3D[],\n    rollConstraintDef: ConstraintSchema.RollConstraint,\n  ): VRMRollConstraint {\n    const { source: sourceIndex, rollAxis, weight } = rollConstraintDef;\n    const source = nodes[sourceIndex];\n    const constraint = new VRMRollConstraint(destination, source);\n\n    if (rollAxis != null) {\n      constraint.rollAxis = rollAxis;\n    }\n    if (weight != null) {\n      constraint.weight = weight;\n    }\n\n    if (this.helperRoot) {\n      const helper = new VRMNodeConstraintHelper(constraint);\n      this.helperRoot.add(helper);\n    }\n\n    return constraint;\n  }\n\n  protected _importAimConstraint(\n    destination: THREE.Object3D,\n    nodes: THREE.Object3D[],\n    aimConstraintDef: ConstraintSchema.AimConstraint,\n  ): VRMAimConstraint {\n    const { source: sourceIndex, aimAxis, weight } = aimConstraintDef;\n    const source = nodes[sourceIndex];\n    const constraint = new VRMAimConstraint(destination, source);\n\n    if (aimAxis != null) {\n      constraint.aimAxis = aimAxis;\n    }\n    if (weight != null) {\n      constraint.weight = weight;\n    }\n\n    if (this.helperRoot) {\n      const helper = new VRMNodeConstraintHelper(constraint);\n      this.helperRoot.add(helper);\n    }\n\n    return constraint;\n  }\n\n  protected _importRotationConstraint(\n    destination: THREE.Object3D,\n    nodes: THREE.Object3D[],\n    rotationConstraintDef: ConstraintSchema.RotationConstraint,\n  ): VRMRotationConstraint {\n    const { source: sourceIndex, weight } = rotationConstraintDef;\n    const source = nodes[sourceIndex];\n    const constraint = new VRMRotationConstraint(destination, source);\n\n    if (weight != null) {\n      constraint.weight = weight;\n    }\n\n    if (this.helperRoot) {\n      const helper = new VRMNodeConstraintHelper(constraint);\n      this.helperRoot.add(helper);\n    }\n\n    return constraint;\n  }\n}\n", "import * as THREE from 'three';\nimport { VRMSpringBoneCollider } from '../VRMSpringBoneCollider';\nimport { VRMSpringBoneColliderShapeCapsule } from '../VRMSpringBoneColliderShapeCapsule';\nimport { VRMSpringBoneColliderShapePlane } from '../VRMSpringBoneColliderShapePlane';\nimport { VRMSpringBoneColliderShapeSphere } from '../VRMSpringBoneColliderShapeSphere';\nimport { ColliderShapeBufferGeometry } from './utils/ColliderShapeBufferGeometry';\nimport { ColliderShapeCapsuleBufferGeometry } from './utils/ColliderShapeCapsuleBufferGeometry';\nimport { ColliderShapePlaneBufferGeometry } from './utils/ColliderShapePlaneBufferGeometry';\nimport { ColliderShapeSphereBufferGeometry } from './utils/ColliderShapeSphereBufferGeometry';\n\nconst _v3A = new THREE.Vector3();\n\nexport class VRMSpringBoneColliderHelper extends THREE.Group {\n  public readonly collider: VRMSpringBoneCollider;\n  private readonly _geometry: ColliderShapeBufferGeometry;\n  private readonly _line: THREE.LineSegments;\n\n  public constructor(collider: VRMSpringBoneCollider) {\n    super();\n    this.matrixAutoUpdate = false;\n\n    this.collider = collider;\n\n    if (this.collider.shape instanceof VRMSpringBoneColliderShapeSphere) {\n      this._geometry = new ColliderShapeSphereBufferGeometry(this.collider.shape);\n    } else if (this.collider.shape instanceof VRMSpringBoneColliderShapeCapsule) {\n      this._geometry = new ColliderShapeCapsuleBufferGeometry(this.collider.shape);\n    } else if (this.collider.shape instanceof VRMSpringBoneColliderShapePlane) {\n      this._geometry = new ColliderShapePlaneBufferGeometry(this.collider.shape);\n    } else {\n      throw new Error('VRMSpringBoneColliderHelper: Unknown collider shape type detected');\n    }\n\n    const material = new THREE.LineBasicMaterial({\n      color: 0xff00ff,\n      depthTest: false,\n      depthWrite: false,\n    });\n\n    this._line = new THREE.LineSegments(this._geometry, material);\n    this.add(this._line);\n  }\n\n  public dispose(): void {\n    this._geometry.dispose();\n  }\n\n  public updateMatrixWorld(force: boolean): void {\n    this.collider.updateWorldMatrix(true, false);\n\n    this.matrix.copy(this.collider.matrixWorld);\n\n    const matrixWorldElements = this.matrix.elements;\n    this._geometry.worldScale = _v3A\n      .set(matrixWorldElements[0], matrixWorldElements[1], matrixWorldElements[2])\n      .length(); // calculate scale of x component\n\n    this._geometry.update();\n\n    super.updateMatrixWorld(force);\n  }\n}\n", "import * as THREE from 'three';\nimport { VRMSpringBoneColliderShape } from './VRMSpringBoneColliderShape';\n\nconst _v3A = new THREE.Vector3();\nconst _v3B = new THREE.Vector3();\n\nexport class VRMSpringBoneColliderShapeCapsule extends VRMSpringBoneColliderShape {\n  public get type(): 'capsule' {\n    return 'capsule';\n  }\n\n  /**\n   * The offset of the capsule head from the origin in local space.\n   */\n  public offset: THREE.Vector3;\n\n  /**\n   * The offset of the capsule tail from the origin in local space.\n   */\n  public tail: THREE.Vector3;\n\n  /**\n   * The radius of the capsule.\n   */\n  public radius: number;\n\n  /**\n   * If true, the collider prevents spring bones from going outside of the capsule instead.\n   */\n  public inside: boolean;\n\n  public constructor(params?: { radius?: number; offset?: THREE.Vector3; tail?: THREE.Vector3; inside?: boolean }) {\n    super();\n\n    this.offset = params?.offset ?? new THREE.Vector3(0.0, 0.0, 0.0);\n    this.tail = params?.tail ?? new THREE.Vector3(0.0, 0.0, 0.0);\n    this.radius = params?.radius ?? 0.0;\n    this.inside = params?.inside ?? false;\n  }\n\n  public calculateCollision(\n    colliderMatrix: THREE.Matrix4,\n    objectPosition: THREE.Vector3,\n    objectRadius: number,\n    target: THREE.Vector3,\n  ): number {\n    _v3A.setFromMatrixPosition(colliderMatrix); // transformed head\n    _v3B.subVectors(this.tail, this.offset).applyMatrix4(colliderMatrix); // transformed tail\n    _v3B.sub(_v3A); // from head to tail\n    const lengthSqCapsule = _v3B.lengthSq();\n\n    target.copy(objectPosition).sub(_v3A); // from head to object\n    const dot = _v3B.dot(target); // dot product of offsetToTail and offsetToObject\n\n    if (dot <= 0.0) {\n      // if object is near from the head\n      // do nothing, use the current value directly\n    } else if (lengthSqCapsule <= dot) {\n      // if object is near from the tail\n      target.sub(_v3B); // from tail to object\n    } else {\n      // if object is between two ends\n      _v3B.multiplyScalar(dot / lengthSqCapsule); // from head to the nearest point of the shaft\n      target.sub(_v3B); // from the shaft point to object\n    }\n\n    const length = target.length();\n    const distance = this.inside ? this.radius - objectRadius - length : length - objectRadius - this.radius;\n\n    if (distance < 0) {\n      target.multiplyScalar(1 / length); // convert the delta to the direction\n      if (this.inside) {\n        target.negate(); // if inside, reverse the direction\n      }\n    }\n\n    return distance;\n  }\n}\n", "import type * as THREE from 'three';\n\n/**\n * Represents a shape of a collider.\n */\nexport abstract class VRMSpringBoneColliderShape {\n  /**\n   * The type of the shape.\n   */\n  public abstract get type(): string;\n\n  /**\n   * The offset to the shape.\n   */\n  public offset?: THREE.Vector3;\n\n  /**\n   * Calculate a distance and a direction from the collider to a target object.\n   * It's hit if the distance is negative.\n   * The direction will be contained in the given target vector.\n   *\n   * @param colliderMatrix A matrix represents the transform of the collider\n   * @param objectPosition A vector represents the position of the target object\n   * @param objectRadius The radius of the object\n   * @param target The result direction will be contained in this vector\n   */\n  public abstract calculateCollision(\n    colliderMatrix: THREE.Matrix4,\n    objectPosition: THREE.Vector3,\n    objectRadius: number,\n    target: THREE.Vector3,\n  ): number;\n}\n", "import * as THREE from 'three';\nimport { VRMSpringBoneColliderShape } from './VRMSpringBoneColliderShape';\n\nconst _v3A = new THREE.Vector3();\nconst _mat3A = new THREE.Matrix3();\n\nexport class VRMSpringBoneColliderShapePlane extends VRMSpringBoneColliderShape {\n  public get type(): 'plane' {\n    return 'plane';\n  }\n\n  /**\n   * The offset of the plane from the origin in local space.\n   */\n  public offset: THREE.Vector3;\n\n  /**\n   * The normal of the plane in local space. Must be normalized.\n   */\n  public normal: THREE.Vector3;\n\n  public constructor(params?: { offset?: THREE.Vector3; normal?: THREE.Vector3 }) {\n    super();\n\n    this.offset = params?.offset ?? new THREE.Vector3(0.0, 0.0, 0.0);\n    this.normal = params?.normal ?? new THREE.Vector3(0.0, 0.0, 1.0);\n  }\n\n  public calculateCollision(\n    colliderMatrix: THREE.Matrix4,\n    objectPosition: THREE.Vector3,\n    objectRadius: number,\n    target: THREE.Vector3,\n  ): number {\n    target.setFromMatrixPosition(colliderMatrix); // transformed offset\n    target.negate().add(objectPosition); // a vector from collider center to object position\n\n    _mat3A.getNormalMatrix(colliderMatrix); // convert the collider matrix to the normal matrix\n    _v3A.copy(this.normal).applyNormalMatrix(_mat3A).normalize(); // transformed normal\n    const distance = target.dot(_v3A) - objectRadius;\n\n    target.copy(_v3A); // convert the delta to the direction\n\n    return distance;\n  }\n}\n", "import * as THREE from 'three';\nimport { VRMSpringBoneColliderShape } from './VRMSpringBoneColliderShape';\n\nconst _v3A = new THREE.Vector3();\n\nexport class VRMSpringBoneColliderShapeSphere extends VRMSpringBoneColliderShape {\n  public get type(): 'sphere' {\n    return 'sphere';\n  }\n\n  /**\n   * The offset of the sphere from the origin in local space.\n   */\n  public offset: THREE.Vector3;\n\n  /**\n   * The radius.\n   */\n  public radius: number;\n\n  /**\n   * If true, the collider prevents spring bones from going outside of the sphere instead.\n   */\n  public inside: boolean;\n\n  public constructor(params?: { radius?: number; offset?: THREE.Vector3; inside?: boolean }) {\n    super();\n\n    this.offset = params?.offset ?? new THREE.Vector3(0.0, 0.0, 0.0);\n    this.radius = params?.radius ?? 0.0;\n    this.inside = params?.inside ?? false;\n  }\n\n  public calculateCollision(\n    colliderMatrix: THREE.Matrix4,\n    objectPosition: THREE.Vector3,\n    objectRadius: number,\n    target: THREE.Vector3,\n  ): number {\n    target.subVectors(objectPosition, _v3A.setFromMatrixPosition(colliderMatrix));\n\n    const length = target.length();\n    const distance = this.inside ? this.radius - objectRadius - length : length - objectRadius - this.radius;\n\n    if (distance < 0) {\n      target.multiplyScalar(1 / length); // convert the delta to the direction\n      if (this.inside) {\n        target.negate(); // if inside, reverse the direction\n      }\n    }\n\n    return distance;\n  }\n}\n", "import * as THREE from 'three';\nimport { VRMSpringBoneColliderShapeCapsule } from '../../VRMSpringBoneColliderShapeCapsule';\nimport { ColliderShapeBufferGeometry } from './ColliderShapeBufferGeometry';\n\nconst _v3A = new THREE.Vector3();\n\nexport class ColliderShapeCapsuleBufferGeometry extends THREE.BufferGeometry implements ColliderShapeBufferGeometry {\n  public worldScale = 1.0;\n\n  private readonly _attrPos: THREE.BufferAttribute;\n  private readonly _attrIndex: THREE.BufferAttribute;\n  private readonly _shape: VRMSpringBoneColliderShapeCapsule;\n  private _currentRadius = 0;\n  private readonly _currentOffset = new THREE.Vector3();\n  private readonly _currentTail = new THREE.Vector3();\n\n  public constructor(shape: VRMSpringBoneColliderShapeCapsule) {\n    super();\n\n    this._shape = shape;\n\n    this._attrPos = new THREE.BufferAttribute(new Float32Array(396), 3);\n    this.setAttribute('position', this._attrPos);\n\n    this._attrIndex = new THREE.BufferAttribute(new Uint16Array(264), 1);\n    this.setIndex(this._attrIndex);\n\n    this._buildIndex();\n    this.update();\n  }\n\n  public update(): void {\n    let shouldUpdateGeometry = false;\n\n    const radius = this._shape.radius / this.worldScale;\n    if (this._currentRadius !== radius) {\n      this._currentRadius = radius;\n      shouldUpdateGeometry = true;\n    }\n\n    if (!this._currentOffset.equals(this._shape.offset)) {\n      this._currentOffset.copy(this._shape.offset);\n      shouldUpdateGeometry = true;\n    }\n\n    const tail = _v3A.copy(this._shape.tail).divideScalar(this.worldScale);\n    if (this._currentTail.distanceToSquared(tail) > 1e-10) {\n      this._currentTail.copy(tail);\n      shouldUpdateGeometry = true;\n    }\n\n    if (shouldUpdateGeometry) {\n      this._buildPosition();\n    }\n  }\n\n  private _buildPosition(): void {\n    _v3A.copy(this._currentTail).sub(this._currentOffset);\n    const l = _v3A.length() / this._currentRadius;\n\n    for (let i = 0; i <= 16; i++) {\n      const t = (i / 16.0) * Math.PI;\n\n      this._attrPos.setXYZ(i, -Math.sin(t), -Math.cos(t), 0.0);\n      this._attrPos.setXYZ(17 + i, l + Math.sin(t), Math.cos(t), 0.0);\n      this._attrPos.setXYZ(34 + i, -Math.sin(t), 0.0, -Math.cos(t));\n      this._attrPos.setXYZ(51 + i, l + Math.sin(t), 0.0, Math.cos(t));\n    }\n\n    for (let i = 0; i < 32; i++) {\n      const t = (i / 16.0) * Math.PI;\n      this._attrPos.setXYZ(68 + i, 0.0, Math.sin(t), Math.cos(t));\n      this._attrPos.setXYZ(100 + i, l, Math.sin(t), Math.cos(t));\n    }\n\n    const theta = Math.atan2(_v3A.y, Math.sqrt(_v3A.x * _v3A.x + _v3A.z * _v3A.z));\n    const phi = -Math.atan2(_v3A.z, _v3A.x);\n\n    this.rotateZ(theta);\n    this.rotateY(phi);\n    this.scale(this._currentRadius, this._currentRadius, this._currentRadius);\n    this.translate(this._currentOffset.x, this._currentOffset.y, this._currentOffset.z);\n\n    this._attrPos.needsUpdate = true;\n  }\n\n  private _buildIndex(): void {\n    for (let i = 0; i < 34; i++) {\n      const i1 = (i + 1) % 34;\n\n      this._attrIndex.setXY(i * 2, i, i1);\n      this._attrIndex.setXY(68 + i * 2, 34 + i, 34 + i1);\n    }\n\n    for (let i = 0; i < 32; i++) {\n      const i1 = (i + 1) % 32;\n\n      this._attrIndex.setXY(136 + i * 2, 68 + i, 68 + i1);\n      this._attrIndex.setXY(200 + i * 2, 100 + i, 100 + i1);\n    }\n\n    this._attrIndex.needsUpdate = true;\n  }\n}\n", "import * as THREE from 'three';\nimport { VRMSpringBoneColliderShapePlane } from '../../VRMSpringBoneColliderShapePlane';\nimport { ColliderShapeBufferGeometry } from './ColliderShapeBufferGeometry';\n\nexport class ColliderShapePlaneBufferGeometry extends THREE.BufferGeometry implements ColliderShapeBufferGeometry {\n  public worldScale = 1.0;\n\n  private readonly _attrPos: THREE.BufferAttribute;\n  private readonly _attrIndex: THREE.BufferAttribute;\n  private readonly _shape: VRMSpringBoneColliderShapePlane;\n  private readonly _currentOffset = new THREE.Vector3();\n  private readonly _currentNormal = new THREE.Vector3();\n\n  public constructor(shape: VRMSpringBoneColliderShapePlane) {\n    super();\n\n    this._shape = shape;\n\n    this._attrPos = new THREE.BufferAttribute(new Float32Array(6 * 3), 3);\n    this.setAttribute('position', this._attrPos);\n\n    this._attrIndex = new THREE.BufferAttribute(new Uint16Array(10), 1);\n    this.setIndex(this._attrIndex);\n\n    this._buildIndex();\n    this.update();\n  }\n\n  public update(): void {\n    let shouldUpdateGeometry = false;\n\n    if (!this._currentOffset.equals(this._shape.offset)) {\n      this._currentOffset.copy(this._shape.offset);\n      shouldUpdateGeometry = true;\n    }\n\n    if (!this._currentNormal.equals(this._shape.normal)) {\n      this._currentNormal.copy(this._shape.normal);\n      shouldUpdateGeometry = true;\n    }\n\n    if (shouldUpdateGeometry) {\n      this._buildPosition();\n    }\n  }\n\n  private _buildPosition(): void {\n    this._attrPos.setXYZ(0, -0.5, -0.5, 0);\n    this._attrPos.setXYZ(1, 0.5, -0.5, 0);\n    this._attrPos.setXYZ(2, 0.5, 0.5, 0);\n    this._attrPos.setXYZ(3, -0.5, 0.5, 0);\n    this._attrPos.setXYZ(4, 0, 0, 0);\n    this._attrPos.setXYZ(5, 0, 0, 0.25);\n\n    this.translate(this._currentOffset.x, this._currentOffset.y, this._currentOffset.z);\n    this.lookAt(this._currentNormal);\n\n    this._attrPos.needsUpdate = true;\n  }\n\n  private _buildIndex(): void {\n    this._attrIndex.setXY(0, 0, 1);\n    this._attrIndex.setXY(2, 1, 2);\n    this._attrIndex.setXY(4, 2, 3);\n    this._attrIndex.setXY(6, 3, 0);\n    this._attrIndex.setXY(8, 4, 5);\n\n    this._attrIndex.needsUpdate = true;\n  }\n}\n", "import * as THREE from 'three';\nimport { VRMSpringBoneColliderShapeSphere } from '../../VRMSpringBoneColliderShapeSphere';\nimport { ColliderShapeBufferGeometry } from './ColliderShapeBufferGeometry';\n\nexport class ColliderShapeSphereBufferGeometry extends THREE.BufferGeometry implements ColliderShapeBufferGeometry {\n  public worldScale = 1.0;\n\n  private readonly _attrPos: THREE.BufferAttribute;\n  private readonly _attrIndex: THREE.BufferAttribute;\n  private readonly _shape: VRMSpringBoneColliderShapeSphere;\n  private _currentRadius = 0;\n  private readonly _currentOffset = new THREE.Vector3();\n\n  public constructor(shape: VRMSpringBoneColliderShapeSphere) {\n    super();\n\n    this._shape = shape;\n\n    this._attrPos = new THREE.BufferAttribute(new Float32Array(32 * 3 * 3), 3);\n    this.setAttribute('position', this._attrPos);\n\n    this._attrIndex = new THREE.BufferAttribute(new Uint16Array(64 * 3), 1);\n    this.setIndex(this._attrIndex);\n\n    this._buildIndex();\n    this.update();\n  }\n\n  public update(): void {\n    let shouldUpdateGeometry = false;\n\n    const radius = this._shape.radius / this.worldScale;\n    if (this._currentRadius !== radius) {\n      this._currentRadius = radius;\n      shouldUpdateGeometry = true;\n    }\n\n    if (!this._currentOffset.equals(this._shape.offset)) {\n      this._currentOffset.copy(this._shape.offset);\n      shouldUpdateGeometry = true;\n    }\n\n    if (shouldUpdateGeometry) {\n      this._buildPosition();\n    }\n  }\n\n  private _buildPosition(): void {\n    for (let i = 0; i < 32; i++) {\n      const t = (i / 16.0) * Math.PI;\n\n      this._attrPos.setXYZ(i, Math.cos(t), Math.sin(t), 0.0);\n      this._attrPos.setXYZ(32 + i, 0.0, Math.cos(t), Math.sin(t));\n      this._attrPos.setXYZ(64 + i, Math.sin(t), 0.0, Math.cos(t));\n    }\n\n    this.scale(this._currentRadius, this._currentRadius, this._currentRadius);\n    this.translate(this._currentOffset.x, this._currentOffset.y, this._currentOffset.z);\n\n    this._attrPos.needsUpdate = true;\n  }\n\n  private _buildIndex(): void {\n    for (let i = 0; i < 32; i++) {\n      const i1 = (i + 1) % 32;\n\n      this._attrIndex.setXY(i * 2, i, i1);\n      this._attrIndex.setXY(64 + i * 2, 32 + i, 32 + i1);\n      this._attrIndex.setXY(128 + i * 2, 64 + i, 64 + i1);\n    }\n\n    this._attrIndex.needsUpdate = true;\n  }\n}\n", "import * as THREE from 'three';\nimport { VRMSpringBoneJoint } from '../VRMSpringBoneJoint';\nimport { SpringBoneBufferGeometry } from './utils/SpringBoneBufferGeometry';\n\nconst _v3A = new THREE.Vector3();\n\nexport class VRMSpringBoneJointHelper extends THREE.Group {\n  public readonly springBone: VRMSpringBoneJoint;\n  private readonly _geometry: SpringBoneBufferGeometry;\n  private readonly _line: THREE.LineSegments;\n\n  public constructor(springBone: VRMSpringBoneJoint) {\n    super();\n    this.matrixAutoUpdate = false;\n\n    this.springBone = springBone;\n\n    this._geometry = new SpringBoneBufferGeometry(this.springBone);\n\n    const material = new THREE.LineBasicMaterial({\n      color: 0xffff00,\n      depthTest: false,\n      depthWrite: false,\n    });\n\n    this._line = new THREE.LineSegments(this._geometry, material);\n    this.add(this._line);\n  }\n\n  public dispose(): void {\n    this._geometry.dispose();\n  }\n\n  public updateMatrixWorld(force: boolean): void {\n    this.springBone.bone.updateWorldMatrix(true, false);\n\n    this.matrix.copy(this.springBone.bone.matrixWorld);\n\n    const matrixWorldElements = this.matrix.elements;\n    this._geometry.worldScale = _v3A\n      .set(matrixWorldElements[0], matrixWorldElements[1], matrixWorldElements[2])\n      .length(); // calculate scale of x component\n\n    this._geometry.update();\n\n    super.updateMatrixWorld(force);\n  }\n}\n", "import * as THREE from 'three';\nimport { VRMSpringBoneJoint } from '../../VRMSpringBoneJoint';\n\nexport class SpringBoneBufferGeometry extends THREE.BufferGeometry {\n  public worldScale = 1.0;\n\n  private readonly _attrPos: THREE.BufferAttribute;\n  private readonly _attrIndex: THREE.BufferAttribute;\n  private readonly _springBone: VRMSpringBoneJoint;\n  private _currentRadius = 0;\n  private readonly _currentTail = new THREE.Vector3();\n\n  public constructor(springBone: VRMSpringBoneJoint) {\n    super();\n\n    this._springBone = springBone;\n\n    this._attrPos = new THREE.BufferAttribute(new Float32Array(294), 3);\n    this.setAttribute('position', this._attrPos);\n\n    this._attrIndex = new THREE.BufferAttribute(new Uint16Array(194), 1);\n    this.setIndex(this._attrIndex);\n\n    this._buildIndex();\n    this.update();\n  }\n\n  public update(): void {\n    let shouldUpdateGeometry = false;\n\n    const radius = this._springBone.settings.hitRadius / this.worldScale;\n    if (this._currentRadius !== radius) {\n      this._currentRadius = radius;\n      shouldUpdateGeometry = true;\n    }\n\n    if (!this._currentTail.equals(this._springBone.initialLocalChildPosition)) {\n      this._currentTail.copy(this._springBone.initialLocalChildPosition);\n      shouldUpdateGeometry = true;\n    }\n\n    if (shouldUpdateGeometry) {\n      this._buildPosition();\n    }\n  }\n\n  private _buildPosition(): void {\n    for (let i = 0; i < 32; i++) {\n      const t = (i / 16.0) * Math.PI;\n\n      this._attrPos.setXYZ(i, Math.cos(t), Math.sin(t), 0.0);\n      this._attrPos.setXYZ(32 + i, 0.0, Math.cos(t), Math.sin(t));\n      this._attrPos.setXYZ(64 + i, Math.sin(t), 0.0, Math.cos(t));\n    }\n\n    this.scale(this._currentRadius, this._currentRadius, this._currentRadius);\n    this.translate(this._currentTail.x, this._currentTail.y, this._currentTail.z);\n\n    this._attrPos.setXYZ(96, 0, 0, 0);\n    this._attrPos.setXYZ(97, this._currentTail.x, this._currentTail.y, this._currentTail.z);\n\n    this._attrPos.needsUpdate = true;\n  }\n\n  private _buildIndex(): void {\n    for (let i = 0; i < 32; i++) {\n      const i1 = (i + 1) % 32;\n\n      this._attrIndex.setXY(i * 2, i, i1);\n      this._attrIndex.setXY(64 + i * 2, 32 + i, 32 + i1);\n      this._attrIndex.setXY(128 + i * 2, 64 + i, 64 + i1);\n    }\n    this._attrIndex.setXY(192, 96, 97);\n\n    this._attrIndex.needsUpdate = true;\n  }\n}\n", "import * as THREE from 'three';\nimport type { VRMSpringBoneColliderShape } from './VRMSpringBoneColliderShape';\n\n/**\n * Represents a collider of a spring bone.\n */\nexport class VRMSpringBoneCollider extends THREE.Object3D {\n  /**\n   * The shape of the collider.\n   */\n  public readonly shape: VRMSpringBoneColliderShape;\n\n  /**\n   * World space matrix for the collider shape used in collision calculations.\n   */\n  public readonly colliderMatrix = new THREE.Matrix4();\n\n  public constructor(shape: VRMSpringBoneColliderShape) {\n    super();\n\n    this.shape = shape;\n  }\n\n  public updateWorldMatrix(updateParents: boolean, updateChildren: boolean): void {\n    super.updateWorldMatrix(updateParents, updateChildren);\n\n    updateColliderMatrix(this.colliderMatrix, this.matrixWorld, this.shape.offset);\n  }\n}\n\n/**\n * Computes the colliderMatrix based on an offset and a world matrix.\n * Equivalent to the following code when matrixWorld is an affine matrix:\n * ```js\n * out.makeTranslation(offset).premultiply(matrixWorld)\n * ```\n *\n * @param colliderMatrix The target matrix to store the result in.\n * @param matrixWorld The world matrix fo the collider object.\n * @param offset Optional offset to the collider shape.\n */\nfunction updateColliderMatrix(colliderMatrix: THREE.Matrix4, matrixWorld: THREE.Matrix4, offset?: THREE.Vector3) {\n  const me = matrixWorld.elements;\n\n  colliderMatrix.copy(matrixWorld);\n\n  if (offset) {\n    colliderMatrix.elements[12] = me[0] * offset.x + me[4] * offset.y + me[8] * offset.z + me[12];\n    colliderMatrix.elements[13] = me[1] * offset.x + me[5] * offset.y + me[9] * offset.z + me[13];\n    colliderMatrix.elements[14] = me[2] * offset.x + me[6] * offset.y + me[10] * offset.z + me[14];\n  }\n}\n", "import * as THREE from 'three';\nimport { Matrix4InverseCache } from './utils/Matrix4InverseCache';\nimport type { VRMSpringBoneColliderGroup } from './VRMSpringBoneColliderGroup';\nimport type { VRMSpringBoneJointSettings } from './VRMSpringBoneJointSettings';\nimport type { VRMSpringBoneManager } from './VRMSpringBoneManager';\n\n// based on\n// http://rocketjump.skr.jp/unity3d/109/\n// https://github.com/dwango/UniVRM/blob/master/Scripts/SpringBone/VRMSpringBone.cs\n\nconst IDENTITY_MATRIX4 = new THREE.Matrix4();\n\n// \u8A08\u7B97\u4E2D\u306E\u4E00\u6642\u4FDD\u5B58\u7528\u5909\u6570\uFF08\u4E00\u5EA6\u30A4\u30F3\u30B9\u30BF\u30F3\u30B9\u3092\u4F5C\u3063\u305F\u3089\u3042\u3068\u306F\u4F7F\u3044\u56DE\u3059\uFF09\nconst _v3A = new THREE.Vector3();\nconst _v3B = new THREE.Vector3();\n\n/**\n * A temporary variable which is used in `update`\n */\nconst _worldSpacePosition = new THREE.Vector3();\n\n/**\n * A temporary variable which is used in `update`\n */\nconst _nextTail = new THREE.Vector3();\n\nconst _matA = new THREE.Matrix4();\n\n/**\n * A class represents a single joint of a spring bone.\n * It should be managed by a {@link VRMSpringBoneManager}.\n */\nexport class VRMSpringBoneJoint {\n  /**\n   * Settings of the bone.\n   */\n  public settings: VRMSpringBoneJointSettings;\n\n  /**\n   * Collider groups attached to this bone.\n   */\n  public colliderGroups: VRMSpringBoneColliderGroup[];\n\n  /**\n   * An Object3D attached to this bone.\n   */\n  public readonly bone: THREE.Object3D;\n\n  /**\n   * An Object3D that will be used as a tail of this spring bone.\n   * It can be null when the spring bone is imported from VRM 0.0.\n   */\n  public readonly child: THREE.Object3D | null;\n\n  /**\n   * Current position of child tail, in center unit. Will be used for verlet integration.\n   */\n  private _currentTail = new THREE.Vector3();\n\n  /**\n   * Previous position of child tail, in center unit. Will be used for verlet integration.\n   */\n  private _prevTail = new THREE.Vector3();\n\n  /**\n   * Initial axis of the bone, in local unit.\n   */\n  private _boneAxis = new THREE.Vector3();\n\n  /**\n   * Length of the bone in world unit.\n   * Will be used for normalization in update loop, will be updated by {@link _calcWorldSpaceBoneLength}.\n   *\n   * It's same as local unit length unless there are scale transformations in the world space.\n   */\n  private _worldSpaceBoneLength = 0.0;\n\n  /**\n   * Set of dependencies that need to be updated before this joint.\n   */\n  public get dependencies(): Set<THREE.Object3D> {\n    const set = new Set<THREE.Object3D>();\n\n    const parent = this.bone.parent;\n    if (parent) {\n      set.add(parent);\n    }\n\n    for (let cg = 0; cg < this.colliderGroups.length; cg++) {\n      for (let c = 0; c < this.colliderGroups[cg].colliders.length; c++) {\n        set.add(this.colliderGroups[cg].colliders[c]);\n      }\n    }\n\n    return set;\n  }\n\n  /**\n   * This springbone will be calculated based on the space relative from this object.\n   * If this is `null`, springbone will be calculated in world space.\n   */\n  private _center: THREE.Object3D | null = null;\n  public get center(): THREE.Object3D | null {\n    return this._center;\n  }\n  public set center(center: THREE.Object3D | null) {\n    // uninstall inverse cache\n    if (this._center?.userData.inverseCacheProxy) {\n      (this._center.userData.inverseCacheProxy as Matrix4InverseCache).revert();\n      delete this._center.userData.inverseCacheProxy;\n    }\n\n    // change the center\n    this._center = center;\n\n    // install inverse cache\n    if (this._center) {\n      if (!this._center.userData.inverseCacheProxy) {\n        this._center.userData.inverseCacheProxy = new Matrix4InverseCache(this._center.matrixWorld);\n      }\n    }\n  }\n\n  /**\n   * Initial state of the local matrix of the bone.\n   */\n  private _initialLocalMatrix = new THREE.Matrix4();\n\n  /**\n   * Initial state of the rotation of the bone.\n   */\n  private _initialLocalRotation = new THREE.Quaternion();\n\n  /**\n   * Initial state of the position of its child.\n   */\n  private _initialLocalChildPosition = new THREE.Vector3();\n  public get initialLocalChildPosition(): THREE.Vector3 {\n    return this._initialLocalChildPosition;\n  }\n\n  /**\n   * Returns the world matrix of its parent object.\n   * Note that it returns a reference to the matrix. Don't mutate this directly!\n   */\n  private get _parentMatrixWorld(): THREE.Matrix4 {\n    return this.bone.parent ? this.bone.parent.matrixWorld : IDENTITY_MATRIX4;\n  }\n\n  /**\n   * Create a new VRMSpringBone.\n   *\n   * @param bone An Object3D that will be attached to this bone\n   * @param child An Object3D that will be used as a tail of this spring bone. It can be null when the spring bone is imported from VRM 0.0\n   * @param settings Several parameters related to behavior of the spring bone\n   * @param colliderGroups Collider groups that will be collided with this spring bone\n   */\n  constructor(\n    bone: THREE.Object3D,\n    child: THREE.Object3D | null,\n    settings: Partial<VRMSpringBoneJointSettings> = {},\n    colliderGroups: VRMSpringBoneColliderGroup[] = [],\n  ) {\n    this.bone = bone; // uniVRM\u3067\u306E parent\n    this.bone.matrixAutoUpdate = false; // update\u306B\u3088\u308A\u8A08\u7B97\u3055\u308C\u308B\u306E\u3067three.js\u5185\u3067\u306E\u81EA\u52D5\u51E6\u7406\u306F\u4E0D\u8981\n\n    this.child = child;\n\n    this.settings = {\n      hitRadius: settings.hitRadius ?? 0.0,\n      stiffness: settings.stiffness ?? 1.0,\n      gravityPower: settings.gravityPower ?? 0.0,\n      gravityDir: settings.gravityDir?.clone() ?? new THREE.Vector3(0.0, -1.0, 0.0),\n      dragForce: settings.dragForce ?? 0.4,\n    };\n\n    this.colliderGroups = colliderGroups;\n  }\n\n  /**\n   * Set the initial state of this spring bone.\n   * You might want to call {@link VRMSpringBoneManager.setInitState} instead.\n   */\n  public setInitState(): void {\n    // remember initial position of itself\n    this._initialLocalMatrix.copy(this.bone.matrix);\n    this._initialLocalRotation.copy(this.bone.quaternion);\n\n    // see initial position of its local child\n    if (this.child) {\n      this._initialLocalChildPosition.copy(this.child.position);\n    } else {\n      // vrm0 requires a 7cm fixed bone length for the final node in a chain\n      // See: https://github.com/vrm-c/vrm-specification/tree/master/specification/VRMC_springBone-1.0#about-spring-configuration\n      this._initialLocalChildPosition.copy(this.bone.position).normalize().multiplyScalar(0.07);\n    }\n\n    // copy the child position to tails\n    const matrixWorldToCenter = this._getMatrixWorldToCenter();\n    this.bone.localToWorld(this._currentTail.copy(this._initialLocalChildPosition)).applyMatrix4(matrixWorldToCenter);\n    this._prevTail.copy(this._currentTail);\n\n    // set initial states that are related to local child position\n    this._boneAxis.copy(this._initialLocalChildPosition).normalize();\n  }\n\n  /**\n   * Reset the state of this bone.\n   * You might want to call {@link VRMSpringBoneManager.reset} instead.\n   */\n  public reset(): void {\n    this.bone.quaternion.copy(this._initialLocalRotation);\n\n    // We need to update its matrixWorld manually, since we tweaked the bone by our hand\n    this.bone.updateMatrix();\n    this.bone.matrixWorld.multiplyMatrices(this._parentMatrixWorld, this.bone.matrix);\n\n    // Apply updated position to tail states\n    const matrixWorldToCenter = this._getMatrixWorldToCenter();\n    this.bone.localToWorld(this._currentTail.copy(this._initialLocalChildPosition)).applyMatrix4(matrixWorldToCenter);\n    this._prevTail.copy(this._currentTail);\n  }\n\n  /**\n   * Update the state of this bone.\n   * You might want to call {@link VRMSpringBoneManager.update} instead.\n   *\n   * @param delta deltaTime\n   */\n  public update(delta: number): void {\n    if (delta <= 0) return;\n\n    // Update the _worldSpaceBoneLength\n    this._calcWorldSpaceBoneLength();\n\n    // Get boneAxis in world space\n    const worldSpaceBoneAxis = _v3B\n      .copy(this._boneAxis)\n      .transformDirection(this._initialLocalMatrix)\n      .transformDirection(this._parentMatrixWorld);\n\n    // verlet\u7A4D\u5206\u3067\u6B21\u306E\u4F4D\u7F6E\u3092\u8A08\u7B97\n    _nextTail\n      // Determine inertia in center space\n      .copy(this._currentTail)\n      .add(_v3A.subVectors(this._currentTail, this._prevTail).multiplyScalar(1 - this.settings.dragForce)) // \u524D\u30D5\u30EC\u30FC\u30E0\u306E\u79FB\u52D5\u3092\u7D99\u7D9A\u3059\u308B(\u6E1B\u8870\u3082\u3042\u308B\u3088)\n      // Convert center space to world space\n      .applyMatrix4(this._getMatrixCenterToWorld()) // tail\u3092world space\u306B\u623B\u3059\n      // Apply stiffness and gravity in world space\n      .addScaledVector(worldSpaceBoneAxis, this.settings.stiffness * delta) // \u89AA\u306E\u56DE\u8EE2\u306B\u3088\u308B\u5B50\u30DC\u30FC\u30F3\u306E\u79FB\u52D5\u76EE\u6A19\n      .addScaledVector(this.settings.gravityDir, this.settings.gravityPower * delta); // \u5916\u529B\u306B\u3088\u308B\u79FB\u52D5\u91CF\n\n    // normalize bone length\n    _worldSpacePosition.setFromMatrixPosition(this.bone.matrixWorld);\n    _nextTail.sub(_worldSpacePosition).normalize().multiplyScalar(this._worldSpaceBoneLength).add(_worldSpacePosition);\n\n    // Collision\u3067\u79FB\u52D5\n    this._collision(_nextTail);\n\n    // update prevTail and currentTail\n    this._prevTail.copy(this._currentTail);\n    this._currentTail.copy(_nextTail).applyMatrix4(this._getMatrixWorldToCenter());\n\n    // Apply rotation, convert vector3 thing into actual quaternion\n    // Original UniVRM is doing center unit calculus at here but we're gonna do this on local unit\n    const worldSpaceInitialMatrixInv = _matA\n      .multiplyMatrices(this._parentMatrixWorld, this._initialLocalMatrix)\n      .invert();\n    this.bone.quaternion\n      .setFromUnitVectors(this._boneAxis, _v3A.copy(_nextTail).applyMatrix4(worldSpaceInitialMatrixInv).normalize())\n      .premultiply(this._initialLocalRotation);\n\n    // We need to update its matrixWorld manually, since we tweaked the bone by our hand\n    this.bone.updateMatrix();\n    this.bone.matrixWorld.multiplyMatrices(this._parentMatrixWorld, this.bone.matrix);\n  }\n\n  /**\n   * Do collision math against every colliders attached to this bone.\n   *\n   * @param tail The tail you want to process\n   */\n  private _collision(tail: THREE.Vector3): void {\n    for (let cg = 0; cg < this.colliderGroups.length; cg++) {\n      for (let c = 0; c < this.colliderGroups[cg].colliders.length; c++) {\n        const collider = this.colliderGroups[cg].colliders[c];\n        const dist = collider.shape.calculateCollision(collider.colliderMatrix, tail, this.settings.hitRadius, _v3A);\n\n        if (dist < 0.0) {\n          // hit\n          tail.addScaledVector(_v3A, -dist);\n\n          // normalize bone length\n          tail.sub(_worldSpacePosition);\n          const length = tail.length();\n          tail.multiplyScalar(this._worldSpaceBoneLength / length).add(_worldSpacePosition);\n        }\n      }\n    }\n  }\n\n  /**\n   * Calculate the {@link _worldSpaceBoneLength}.\n   * Intended to be used in {@link update}.\n   */\n  private _calcWorldSpaceBoneLength(): void {\n    _v3A.setFromMatrixPosition(this.bone.matrixWorld); // get world position of this.bone\n\n    if (this.child) {\n      _v3B.setFromMatrixPosition(this.child.matrixWorld); // get world position of this.child\n    } else {\n      _v3B.copy(this._initialLocalChildPosition);\n      _v3B.applyMatrix4(this.bone.matrixWorld);\n    }\n\n    this._worldSpaceBoneLength = _v3A.sub(_v3B).length();\n  }\n\n  /**\n   * Create a matrix that converts center space into world space.\n   */\n  private _getMatrixCenterToWorld(): THREE.Matrix4 {\n    return this._center ? this._center.matrixWorld : IDENTITY_MATRIX4;\n  }\n\n  /**\n   * Create a matrix that converts world space into center space.\n   */\n  private _getMatrixWorldToCenter(): THREE.Matrix4 {\n    return this._center ? (this._center.userData.inverseCacheProxy as Matrix4InverseCache).inverse : IDENTITY_MATRIX4;\n  }\n}\n", "import * as THREE from 'three';\nimport { mat4InvertCompat } from './mat4InvertCompat';\n\nexport class Matrix4InverseCache {\n  /**\n   * The target matrix.\n   */\n  public readonly matrix: THREE.Matrix4;\n\n  /**\n   * A cache of inverse of current matrix.\n   */\n  private readonly _inverseCache = new THREE.Matrix4();\n\n  /**\n   * A flag that makes it want to recalculate its {@link _inverseCache}.\n   * Will be set `true` when `elements` are mutated and be used in `getInverse`.\n   */\n  private _shouldUpdateInverse = true;\n\n  /**\n   * The original of `matrix.elements`\n   */\n  private readonly _originalElements: THREE.Matrix4Tuple;\n\n  /**\n   * Inverse of given matrix.\n   * Note that it will return its internal private instance.\n   * Make sure copying this before mutate this.\n   */\n  public get inverse(): THREE.Matrix4 {\n    if (this._shouldUpdateInverse) {\n      mat4InvertCompat(this._inverseCache.copy(this.matrix));\n      this._shouldUpdateInverse = false;\n    }\n\n    return this._inverseCache;\n  }\n\n  public constructor(matrix: THREE.Matrix4) {\n    this.matrix = matrix;\n\n    const handler: ProxyHandler<number[]> = {\n      set: (obj, prop: any, newVal) => {\n        this._shouldUpdateInverse = true;\n        obj[prop] = newVal;\n\n        return true;\n      },\n    };\n\n    this._originalElements = matrix.elements;\n    matrix.elements = new Proxy<THREE.Matrix4Tuple>(matrix.elements, handler);\n  }\n\n  public revert(): void {\n    this.matrix.elements = this._originalElements;\n  }\n}\n", "import * as THREE from 'three';\n\nconst _matA = new THREE.Matrix4();\n\n/**\n * A compat function for `Matrix4.invert()` / `Matrix4.getInverse()`.\n * `Matrix4.invert()` is introduced in r123 and `Matrix4.getInverse()` emits a warning.\n * We are going to use this compat for a while.\n * @param target A target matrix\n */\nexport function mat4InvertCompat<T extends THREE.Matrix4>(target: T): T {\n  if ((target as any).invert) {\n    target.invert();\n  } else {\n    (target as any).getInverse(_matA.copy(target));\n  }\n\n  return target;\n}\n", "import type * as V0VRM from '@pixiv/types-vrm-0.0';\nimport type * as V1SpringBoneSchema from '@pixiv/types-vrmc-springbone-1.0';\nimport type * as SpringBoneExtendedColliderSchema from '@pixiv/types-vrmc-springbone-extended-collider-1.0';\nimport * as THREE from 'three';\nimport type { GLTF, GLTFLoaderPlugin, GLTFParser } from 'three/examples/jsm/loaders/GLTFLoader.js';\nimport { VRMSpringBoneColliderHelper, VRMSpringBoneJointHelper } from './helpers';\nimport { VRMSpringBoneCollider } from './VRMSpringBoneCollider';\nimport type { VRMSpringBoneColliderGroup } from './VRMSpringBoneColliderGroup';\nimport { VRMSpringBoneColliderShapeCapsule } from './VRMSpringBoneColliderShapeCapsule';\nimport { VRMSpringBoneColliderShapeSphere } from './VRMSpringBoneColliderShapeSphere';\nimport { VRMSpringBoneJoint } from './VRMSpringBoneJoint';\nimport type { VRMSpringBoneLoaderPluginOptions } from './VRMSpringBoneLoaderPluginOptions';\nimport { VRMSpringBoneManager } from './VRMSpringBoneManager';\nimport type { VRMSpringBoneJointSettings } from './VRMSpringBoneJointSettings';\nimport { GLTF as GLTFSchema } from '@gltf-transform/core';\nimport { VRMSpringBoneColliderShapePlane } from './VRMSpringBoneColliderShapePlane';\n\nconst EXTENSION_NAME_EXTENDED_COLLIDER = 'VRMC_springBone_extended_collider';\n\n/**\n * Possible spec versions it recognizes.\n */\nconst POSSIBLE_SPEC_VERSIONS = new Set(['1.0', '1.0-beta']);\n\n/**\n * Possible spec versions of `VRMC_springBone_extended_collider` it recognizes.\n */\nconst POSSIBLE_SPEC_VERSIONS_EXTENDED_COLLIDERS = new Set(['1.0']);\n\nexport class VRMSpringBoneLoaderPlugin implements GLTFLoaderPlugin {\n  public static readonly EXTENSION_NAME = 'VRMC_springBone';\n\n  /**\n   * Specify an Object3D to add {@link VRMSpringBoneJointHelper} s.\n   * If not specified, helper will not be created.\n   * If `renderOrder` is set to the root, helpers will copy the same `renderOrder` .\n   */\n  public jointHelperRoot?: THREE.Object3D;\n\n  /**\n   * Specify an Object3D to add {@link VRMSpringBoneJointHelper} s.\n   * If not specified, helper will not be created.\n   * If `renderOrder` is set to the root, helpers will copy the same `renderOrder` .\n   */\n  public colliderHelperRoot?: THREE.Object3D;\n\n  /**\n   * If true, load colliders defined in `VRMC_springBone_extended_collider`.\n   * Set to `false` to disable loading extended colliders and use the fallback behavior.\n   * `true` by default.\n   */\n  public useExtendedColliders: boolean;\n\n  public readonly parser: GLTFParser;\n\n  public get name(): string {\n    return VRMSpringBoneLoaderPlugin.EXTENSION_NAME;\n  }\n\n  public constructor(parser: GLTFParser, options?: VRMSpringBoneLoaderPluginOptions) {\n    this.parser = parser;\n\n    this.jointHelperRoot = options?.jointHelperRoot;\n    this.colliderHelperRoot = options?.colliderHelperRoot;\n    this.useExtendedColliders = options?.useExtendedColliders ?? true;\n  }\n\n  public async afterRoot(gltf: GLTF): Promise<void> {\n    gltf.userData.vrmSpringBoneManager = await this._import(gltf);\n  }\n\n  /**\n   * Import spring bones from a GLTF and return a {@link VRMSpringBoneManager}.\n   * It might return `null` instead when it does not need to be created or something go wrong.\n   *\n   * @param gltf A parsed result of GLTF taken from GLTFLoader\n   */\n  private async _import(gltf: GLTF): Promise<VRMSpringBoneManager | null> {\n    const v1Result = await this._v1Import(gltf);\n    if (v1Result != null) {\n      return v1Result;\n    }\n\n    const v0Result = await this._v0Import(gltf);\n    if (v0Result != null) {\n      return v0Result;\n    }\n\n    return null;\n  }\n\n  private async _v1Import(gltf: GLTF): Promise<VRMSpringBoneManager | null> {\n    const json = gltf.parser.json as GLTFSchema.IGLTF;\n\n    // early abort if it doesn't use spring bones\n    const isSpringBoneUsed = json.extensionsUsed?.indexOf(VRMSpringBoneLoaderPlugin.EXTENSION_NAME) !== -1;\n    if (!isSpringBoneUsed) {\n      return null;\n    }\n\n    const manager = new VRMSpringBoneManager();\n\n    const threeNodes: THREE.Object3D[] = await gltf.parser.getDependencies('node');\n\n    const extension = json.extensions?.[VRMSpringBoneLoaderPlugin.EXTENSION_NAME] as\n      | V1SpringBoneSchema.VRMCSpringBone\n      | undefined;\n    if (!extension) {\n      return null;\n    }\n\n    const specVersion = extension.specVersion;\n    if (!POSSIBLE_SPEC_VERSIONS.has(specVersion)) {\n      console.warn(\n        `VRMSpringBoneLoaderPlugin: Unknown ${VRMSpringBoneLoaderPlugin.EXTENSION_NAME} specVersion \"${specVersion}\"`,\n      );\n      return null;\n    }\n\n    const colliders = extension.colliders?.map((schemaCollider, iCollider) => {\n      const node = threeNodes[schemaCollider.node!];\n\n      // Some models put `-1` to the node index of colliders\n      if (node == null) {\n        console.warn(\n          `VRMSpringBoneLoaderPlugin: The collider #${iCollider} attempted to use the node #${schemaCollider.node} but not found`,\n        );\n        return null;\n      }\n\n      const schemaShape = schemaCollider.shape!;\n\n      // TODO: separate into several functions\n\n      const schemaExCollider: SpringBoneExtendedColliderSchema.VRMCSpringBoneExtendedCollider | undefined =\n        schemaCollider.extensions?.[EXTENSION_NAME_EXTENDED_COLLIDER];\n\n      if (this.useExtendedColliders && schemaExCollider != null) {\n        const specVersionExCollider = schemaExCollider.specVersion;\n        if (!POSSIBLE_SPEC_VERSIONS_EXTENDED_COLLIDERS.has(specVersionExCollider)) {\n          console.warn(\n            `VRMSpringBoneLoaderPlugin: Unknown ${EXTENSION_NAME_EXTENDED_COLLIDER} specVersion \"${specVersionExCollider}\". Fallbacking to the ${VRMSpringBoneLoaderPlugin.EXTENSION_NAME} definition`,\n          );\n        } else {\n          const schemaExShape = schemaExCollider.shape!;\n          if (schemaExShape.sphere) {\n            return this._importSphereCollider(node, {\n              offset: new THREE.Vector3().fromArray(schemaExShape.sphere.offset ?? [0.0, 0.0, 0.0]),\n              radius: schemaExShape.sphere.radius ?? 0.0,\n              inside: schemaExShape.sphere.inside ?? false,\n            });\n          } else if (schemaExShape.capsule) {\n            return this._importCapsuleCollider(node, {\n              offset: new THREE.Vector3().fromArray(schemaExShape.capsule.offset ?? [0.0, 0.0, 0.0]),\n              radius: schemaExShape.capsule.radius ?? 0.0,\n              tail: new THREE.Vector3().fromArray(schemaExShape.capsule.tail ?? [0.0, 0.0, 0.0]),\n              inside: schemaExShape.capsule.inside ?? false,\n            });\n          } else if (schemaExShape.plane) {\n            return this._importPlaneCollider(node, {\n              offset: new THREE.Vector3().fromArray(schemaExShape.plane.offset ?? [0.0, 0.0, 0.0]),\n              normal: new THREE.Vector3().fromArray(schemaExShape.plane.normal ?? [0.0, 0.0, 1.0]),\n            });\n          }\n        }\n      }\n\n      if (schemaShape.sphere) {\n        return this._importSphereCollider(node, {\n          offset: new THREE.Vector3().fromArray(schemaShape.sphere.offset ?? [0.0, 0.0, 0.0]),\n          radius: schemaShape.sphere.radius ?? 0.0,\n          inside: false,\n        });\n      } else if (schemaShape.capsule) {\n        return this._importCapsuleCollider(node, {\n          offset: new THREE.Vector3().fromArray(schemaShape.capsule.offset ?? [0.0, 0.0, 0.0]),\n          radius: schemaShape.capsule.radius ?? 0.0,\n          tail: new THREE.Vector3().fromArray(schemaShape.capsule.tail ?? [0.0, 0.0, 0.0]),\n          inside: false,\n        });\n      }\n\n      throw new Error(`VRMSpringBoneLoaderPlugin: The collider #${iCollider} has no valid shape`);\n    });\n\n    const colliderGroups = extension.colliderGroups?.map(\n      (schemaColliderGroup, iColliderGroup): VRMSpringBoneColliderGroup => {\n        const cols = (schemaColliderGroup.colliders ?? []).flatMap((iCollider) => {\n          const col = colliders?.[iCollider];\n\n          if (col == null) {\n            console.warn(\n              `VRMSpringBoneLoaderPlugin: The colliderGroup #${iColliderGroup} attempted to use a collider #${iCollider} but not found`,\n            );\n            return [];\n          }\n\n          return col;\n        });\n\n        return {\n          colliders: cols,\n          name: schemaColliderGroup.name,\n        };\n      },\n    );\n\n    extension.springs?.forEach((schemaSpring, iSpring) => {\n      const schemaJoints = schemaSpring.joints;\n\n      // prepare colliders\n      const colliderGroupsForSpring = schemaSpring.colliderGroups?.map((iColliderGroup) => {\n        const group = colliderGroups?.[iColliderGroup];\n\n        if (group == null) {\n          throw new Error(\n            `VRMSpringBoneLoaderPlugin: The spring #${iSpring} attempted to use a colliderGroup ${iColliderGroup} but not found`,\n          );\n        }\n\n        return group;\n      });\n\n      const center = schemaSpring.center != null ? threeNodes[schemaSpring.center] : undefined;\n\n      let prevSchemaJoint: V1SpringBoneSchema.SpringBoneJoint | undefined;\n      schemaJoints.forEach((schemaJoint) => {\n        if (prevSchemaJoint) {\n          // prepare node\n          const nodeIndex = prevSchemaJoint.node;\n          const node = threeNodes[nodeIndex];\n          const childIndex = schemaJoint.node;\n          const child = threeNodes[childIndex];\n\n          // prepare setting\n          const setting: Partial<VRMSpringBoneJointSettings> = {\n            hitRadius: prevSchemaJoint.hitRadius,\n            dragForce: prevSchemaJoint.dragForce,\n            gravityPower: prevSchemaJoint.gravityPower,\n            stiffness: prevSchemaJoint.stiffness,\n            gravityDir:\n              prevSchemaJoint.gravityDir != null\n                ? new THREE.Vector3().fromArray(prevSchemaJoint.gravityDir)\n                : undefined,\n          };\n\n          // create spring bones\n          const joint = this._importJoint(node, child, setting, colliderGroupsForSpring);\n          if (center) {\n            joint.center = center;\n          }\n\n          manager.addJoint(joint);\n        }\n\n        prevSchemaJoint = schemaJoint;\n      });\n    });\n\n    // init spring bones\n    manager.setInitState();\n\n    return manager;\n  }\n\n  private async _v0Import(gltf: GLTF): Promise<VRMSpringBoneManager | null> {\n    const json = gltf.parser.json as GLTFSchema.IGLTF;\n\n    // early abort if it doesn't use vrm\n    const isVRMUsed = json.extensionsUsed?.indexOf('VRM') !== -1;\n    if (!isVRMUsed) {\n      return null;\n    }\n\n    // early abort if it doesn't have bone groups\n    const extension = json.extensions?.['VRM'] as V0VRM.VRM | undefined;\n    const schemaSecondaryAnimation = extension?.secondaryAnimation;\n    if (!schemaSecondaryAnimation) {\n      return null;\n    }\n\n    const schemaBoneGroups = schemaSecondaryAnimation?.boneGroups;\n    if (!schemaBoneGroups) {\n      return null;\n    }\n\n    const manager = new VRMSpringBoneManager();\n\n    const threeNodes: THREE.Object3D[] = await gltf.parser.getDependencies('node');\n\n    const colliderGroups = schemaSecondaryAnimation.colliderGroups?.map(\n      (schemaColliderGroup): VRMSpringBoneColliderGroup => {\n        const node = threeNodes[schemaColliderGroup.node!];\n        const colliders = (schemaColliderGroup.colliders ?? []).map((schemaCollider, iCollider) => {\n          const offset = new THREE.Vector3(0.0, 0.0, 0.0);\n          if (schemaCollider.offset) {\n            offset.set(\n              schemaCollider.offset.x ?? 0.0,\n              schemaCollider.offset.y ?? 0.0,\n              schemaCollider.offset.z ? -schemaCollider.offset.z : 0.0, // z is opposite in VRM0.0\n            );\n          }\n\n          return this._importSphereCollider(node, {\n            offset,\n            radius: schemaCollider.radius ?? 0.0,\n            inside: false,\n          });\n        });\n\n        return { colliders };\n      },\n    );\n\n    // import spring bones for each spring bone groups\n    schemaBoneGroups?.forEach((schemaBoneGroup, iBoneGroup) => {\n      const rootIndices = schemaBoneGroup.bones;\n      if (!rootIndices) {\n        return;\n      }\n\n      rootIndices.forEach((rootIndex) => {\n        const root = threeNodes[rootIndex];\n\n        // prepare setting\n        const gravityDir = new THREE.Vector3();\n        if (schemaBoneGroup.gravityDir) {\n          gravityDir.set(\n            schemaBoneGroup.gravityDir.x ?? 0.0,\n            schemaBoneGroup.gravityDir.y ?? 0.0,\n            schemaBoneGroup.gravityDir.z ?? 0.0,\n          );\n        } else {\n          gravityDir.set(0.0, -1.0, 0.0);\n        }\n\n        const center = schemaBoneGroup.center != null ? threeNodes[schemaBoneGroup.center] : undefined;\n\n        const setting: Partial<VRMSpringBoneJointSettings> = {\n          hitRadius: schemaBoneGroup.hitRadius,\n          dragForce: schemaBoneGroup.dragForce,\n          gravityPower: schemaBoneGroup.gravityPower,\n          stiffness: schemaBoneGroup.stiffiness,\n          gravityDir,\n        };\n\n        // prepare colliders\n        const colliderGroupsForSpring = schemaBoneGroup.colliderGroups?.map((iColliderGroup) => {\n          const group = colliderGroups?.[iColliderGroup];\n\n          if (group == null) {\n            throw new Error(\n              `VRMSpringBoneLoaderPlugin: The spring #${iBoneGroup} attempted to use a colliderGroup ${iColliderGroup} but not found`,\n            );\n          }\n\n          return group;\n        });\n\n        // create spring bones\n        root.traverse((node) => {\n          const child: THREE.Object3D | null = node.children[0] ?? null;\n\n          const joint = this._importJoint(node, child, setting, colliderGroupsForSpring);\n          if (center) {\n            joint.center = center;\n          }\n\n          manager.addJoint(joint);\n        });\n      });\n    });\n\n    // init spring bones\n    gltf.scene.updateMatrixWorld();\n    manager.setInitState();\n\n    return manager;\n  }\n\n  private _importJoint(\n    node: THREE.Object3D,\n    child: THREE.Object3D,\n    setting?: Partial<VRMSpringBoneJointSettings>,\n    colliderGroupsForSpring?: VRMSpringBoneColliderGroup[],\n  ): VRMSpringBoneJoint {\n    const springBone = new VRMSpringBoneJoint(node, child, setting, colliderGroupsForSpring);\n\n    if (this.jointHelperRoot) {\n      const helper = new VRMSpringBoneJointHelper(springBone);\n      this.jointHelperRoot.add(helper);\n      helper.renderOrder = this.jointHelperRoot.renderOrder;\n    }\n\n    return springBone;\n  }\n\n  private _importSphereCollider(\n    destination: THREE.Object3D,\n    params: {\n      offset: THREE.Vector3;\n      radius: number;\n      inside: boolean;\n    },\n  ): VRMSpringBoneCollider {\n    const shape = new VRMSpringBoneColliderShapeSphere(params);\n\n    const collider = new VRMSpringBoneCollider(shape);\n\n    destination.add(collider);\n\n    if (this.colliderHelperRoot) {\n      const helper = new VRMSpringBoneColliderHelper(collider);\n      this.colliderHelperRoot.add(helper);\n      helper.renderOrder = this.colliderHelperRoot.renderOrder;\n    }\n\n    return collider;\n  }\n\n  private _importCapsuleCollider(\n    destination: THREE.Object3D,\n    params: {\n      offset: THREE.Vector3;\n      radius: number;\n      tail: THREE.Vector3;\n      inside: boolean;\n    },\n  ): VRMSpringBoneCollider {\n    const shape = new VRMSpringBoneColliderShapeCapsule(params);\n\n    const collider = new VRMSpringBoneCollider(shape);\n\n    destination.add(collider);\n\n    if (this.colliderHelperRoot) {\n      const helper = new VRMSpringBoneColliderHelper(collider);\n      this.colliderHelperRoot.add(helper);\n      helper.renderOrder = this.colliderHelperRoot.renderOrder;\n    }\n\n    return collider;\n  }\n\n  private _importPlaneCollider(\n    destination: THREE.Object3D,\n    params: {\n      offset: THREE.Vector3;\n      normal: THREE.Vector3;\n    },\n  ): VRMSpringBoneCollider {\n    const shape = new VRMSpringBoneColliderShapePlane(params);\n\n    const collider = new VRMSpringBoneCollider(shape);\n\n    destination.add(collider);\n\n    if (this.colliderHelperRoot) {\n      const helper = new VRMSpringBoneColliderHelper(collider);\n      this.colliderHelperRoot.add(helper);\n      helper.renderOrder = this.colliderHelperRoot.renderOrder;\n    }\n\n    return collider;\n  }\n}\n", "import type * as THREE from 'three';\n\nexport function traverseAncestorsFromRoot(object: THREE.Object3D, callback: (object: THREE.Object3D) => void): void {\n  const ancestors: THREE.Object3D[] = [];\n\n  let head: THREE.Object3D | null = object;\n  while (head !== null) {\n    ancestors.unshift(head);\n    head = head.parent;\n  }\n\n  ancestors.forEach((ancestor) => {\n    callback(ancestor);\n  });\n}\n", "import type * as THREE from 'three';\n\n/**\n * Traverse children of given object and execute given callback.\n * The given object itself wont be given to the callback.\n * If the return value of the callback is `true`, it will halt the traversal of its children.\n * @param object A root object\n * @param callback A callback function called for each children\n */\nexport function traverseChildrenUntilConditionMet(\n  object: THREE.Object3D,\n  callback: (object: THREE.Object3D) => boolean,\n): void {\n  object.children.forEach((child) => {\n    const result = callback(child);\n    if (!result) {\n      traverseChildrenUntilConditionMet(child, callback);\n    }\n  });\n}\n", "import type * as THREE from 'three';\n\n/**\n * Finds the lowest common ancestors of the given objects, if it exists.\n * @param objects The objects to find the lowest common ancestor for.\n */\nexport function lowestCommonAncestor(objects: Set<THREE.Object3D>): THREE.Object3D | null {\n  const sharedAncestors = new Map<THREE.Object3D, number>();\n  for (const object of objects) {\n    let current: THREE.Object3D | null = object;\n    do {\n      const newValue = (sharedAncestors.get(current) ?? 0) + 1;\n      if (newValue === objects.size) {\n        return current;\n      }\n      sharedAncestors.set(current, newValue);\n      current = current.parent;\n    } while (current !== null);\n  }\n  return null;\n}\n", "import type * as THREE from 'three';\nimport type { VRMSpringBoneJoint } from './VRMSpringBoneJoint.js';\nimport { traverseAncestorsFromRoot } from './utils/traverseAncestorsFromRoot.js';\nimport type { VRMSpringBoneCollider } from './VRMSpringBoneCollider.js';\nimport type { VRMSpringBoneColliderGroup } from './VRMSpringBoneColliderGroup.js';\nimport { traverseChildrenUntilConditionMet } from './utils/traverseChildrenUntilConditionMet.js';\nimport { lowestCommonAncestor } from './utils/lowestCommonAncestor.js';\n\nexport class VRMSpringBoneManager {\n  private _joints = new Set<VRMSpringBoneJoint>();\n  private _sortedJoints: Array<VRMSpringBoneJoint> = [];\n  private _hasWarnedCircularDependency = false;\n\n  /**\n   * An ordered list of ancestors of all the SpringBone joints. Before the\n   * SpringBone joints can be updated, the world matrices of these ancestors\n   * must be calculated. The first element is the lowest common ancestor, for\n   * which not only its world matrix but its ancestors' world matrices are\n   * updated as well.\n   */\n  private _ancestors: THREE.Object3D[] = [];\n\n  public get joints(): Set<VRMSpringBoneJoint> {\n    return this._joints;\n  }\n\n  /**\n   * @deprecated Use {@link joints} instead.\n   */\n  public get springBones(): Set<VRMSpringBoneJoint> {\n    console.warn('VRMSpringBoneManager: springBones is deprecated. use joints instead.');\n\n    return this._joints;\n  }\n\n  public get colliderGroups(): VRMSpringBoneColliderGroup[] {\n    const set = new Set<VRMSpringBoneColliderGroup>();\n    this._joints.forEach((springBone) => {\n      springBone.colliderGroups.forEach((colliderGroup) => {\n        set.add(colliderGroup);\n      });\n    });\n    return Array.from(set);\n  }\n\n  public get colliders(): VRMSpringBoneCollider[] {\n    const set = new Set<VRMSpringBoneCollider>();\n    this.colliderGroups.forEach((colliderGroup) => {\n      colliderGroup.colliders.forEach((collider) => {\n        set.add(collider);\n      });\n    });\n    return Array.from(set);\n  }\n\n  private _objectSpringBonesMap = new Map<THREE.Object3D, Set<VRMSpringBoneJoint>>();\n  private _isSortedJointsDirty = false;\n\n  constructor() {\n    this._relevantChildrenUpdated = this._relevantChildrenUpdated.bind(this);\n  }\n\n  public addJoint(joint: VRMSpringBoneJoint): void {\n    this._joints.add(joint);\n\n    let objectSet = this._objectSpringBonesMap.get(joint.bone);\n    if (objectSet == null) {\n      objectSet = new Set<VRMSpringBoneJoint>();\n      this._objectSpringBonesMap.set(joint.bone, objectSet);\n    }\n    objectSet.add(joint);\n\n    this._isSortedJointsDirty = true;\n  }\n\n  /**\n   * @deprecated Use {@link addJoint} instead.\n   */\n  public addSpringBone(joint: VRMSpringBoneJoint): void {\n    console.warn('VRMSpringBoneManager: addSpringBone() is deprecated. use addJoint() instead.');\n\n    this.addJoint(joint);\n  }\n\n  public deleteJoint(joint: VRMSpringBoneJoint): void {\n    this._joints.delete(joint);\n\n    const objectSet = this._objectSpringBonesMap.get(joint.bone)!;\n    objectSet.delete(joint);\n\n    this._isSortedJointsDirty = true;\n  }\n\n  /**\n   * @deprecated Use {@link deleteJoint} instead.\n   */\n  public deleteSpringBone(joint: VRMSpringBoneJoint): void {\n    console.warn('VRMSpringBoneManager: deleteSpringBone() is deprecated. use deleteJoint() instead.');\n\n    this.deleteJoint(joint);\n  }\n\n  public setInitState(): void {\n    this._sortJoints();\n\n    for (let i = 0; i < this._sortedJoints.length; i++) {\n      const springBone = this._sortedJoints[i];\n      springBone.bone.updateMatrix();\n      springBone.bone.updateWorldMatrix(false, false);\n      springBone.setInitState();\n    }\n  }\n\n  public reset(): void {\n    this._sortJoints();\n\n    for (let i = 0; i < this._sortedJoints.length; i++) {\n      const springBone = this._sortedJoints[i];\n      springBone.bone.updateMatrix();\n      springBone.bone.updateWorldMatrix(false, false);\n      springBone.reset();\n    }\n  }\n\n  public update(delta: number): void {\n    this._sortJoints();\n\n    for (let i = 0; i < this._ancestors.length; i++) {\n      this._ancestors[i].updateWorldMatrix(i === 0, false);\n    }\n\n    for (let i = 0; i < this._sortedJoints.length; i++) {\n      // update the springbone\n      const springBone = this._sortedJoints[i];\n      springBone.bone.updateMatrix();\n      springBone.bone.updateWorldMatrix(false, false);\n      springBone.update(delta);\n\n      // update children world matrices\n      // it is required when the spring bone chain is sparse\n      traverseChildrenUntilConditionMet(springBone.bone, this._relevantChildrenUpdated);\n    }\n  }\n\n  /**\n   * Sorts the joints ensuring they are updated in the correct order taking dependencies into account.\n   *\n   * This method updates {@link _sortedJoints} and {@link _ancestors}.\n   * Make sure to call this before using them.\n   */\n  private _sortJoints() {\n    if (!this._isSortedJointsDirty) {\n      return;\n    }\n\n    const springBoneOrder: Array<VRMSpringBoneJoint> = [];\n    const springBonesTried = new Set<VRMSpringBoneJoint>();\n    const springBonesDone = new Set<VRMSpringBoneJoint>();\n    const ancestors = new Set<THREE.Object3D>();\n\n    for (const springBone of this._joints) {\n      this._insertJointSort(springBone, springBonesTried, springBonesDone, springBoneOrder, ancestors);\n    }\n    this._sortedJoints = springBoneOrder;\n\n    const lca = lowestCommonAncestor(ancestors);\n    this._ancestors = [];\n    if (lca) {\n      this._ancestors.push(lca);\n      traverseChildrenUntilConditionMet(lca, (object: THREE.Object3D) => {\n        // if the object has attached springbone, halt the traversal\n        if ((this._objectSpringBonesMap.get(object)?.size ?? 0) > 0) {\n          return true;\n        }\n        this._ancestors.push(object);\n        return false;\n      });\n    }\n\n    this._isSortedJointsDirty = false;\n  }\n\n  private _insertJointSort(\n    springBone: VRMSpringBoneJoint,\n    springBonesTried: Set<VRMSpringBoneJoint>,\n    springBonesDone: Set<VRMSpringBoneJoint>,\n    springBoneOrder: Array<VRMSpringBoneJoint>,\n    ancestors: Set<THREE.Object3D>,\n  ) {\n    if (springBonesDone.has(springBone)) {\n      return;\n    }\n\n    if (springBonesTried.has(springBone)) {\n      if (!this._hasWarnedCircularDependency) {\n        console.warn('VRMSpringBoneManager: Circular dependency detected');\n        this._hasWarnedCircularDependency = true;\n      }\n      return;\n    }\n\n    springBonesTried.add(springBone);\n\n    const depObjects = springBone.dependencies;\n    for (const depObject of depObjects) {\n      let encounteredSpringBone = false;\n      let ancestor: THREE.Object3D | null = null;\n      traverseAncestorsFromRoot(depObject, (depObjectAncestor) => {\n        const objectSet = this._objectSpringBonesMap.get(depObjectAncestor);\n        if (objectSet) {\n          for (const depSpringBone of objectSet) {\n            encounteredSpringBone = true;\n            this._insertJointSort(depSpringBone, springBonesTried, springBonesDone, springBoneOrder, ancestors);\n          }\n        } else if (!encounteredSpringBone) {\n          // This object is an ancestor of a spring bone, but is NOT a sparse node in between spring bones.\n          ancestor = depObjectAncestor;\n        }\n      });\n      if (ancestor) {\n        ancestors.add(ancestor);\n      }\n    }\n\n    springBoneOrder.push(springBone);\n\n    springBonesDone.add(springBone);\n  }\n\n  private _relevantChildrenUpdated(object: THREE.Object3D) {\n    // if the object has attached springbone, halt the traversal\n    if ((this._objectSpringBonesMap.get(object)?.size ?? 0) > 0) {\n      return true;\n    }\n\n    // otherwise update its world matrix\n    object.updateWorldMatrix(false, false);\n    return false;\n  }\n}\n", "import * as THREE from 'three';\nimport { GLTF, GLTFLoaderPlugin, GLTFParser } from 'three/examples/jsm/loaders/GLTFLoader.js';\nimport {\n  VRMExpressionLoaderPlugin,\n  VRMFirstPersonLoaderPlugin,\n  VRMHumanoid,\n  VRMHumanoidLoaderPlugin,\n  VRMLookAtLoaderPlugin,\n  VRMMeta,\n  VRMMetaLoaderPlugin,\n} from '@pixiv/three-vrm-core';\nimport { MToonMaterialLoaderPlugin } from '@pixiv/three-vrm-materials-mtoon';\nimport { VRMMaterialsHDREmissiveMultiplierLoaderPlugin } from '@pixiv/three-vrm-materials-hdr-emissive-multiplier';\nimport { VRMMaterialsV0CompatPlugin } from '@pixiv/three-vrm-materials-v0compat';\nimport { VRMNodeConstraintLoaderPlugin } from '@pixiv/three-vrm-node-constraint';\nimport { VRMSpringBoneLoaderPlugin } from '@pixiv/three-vrm-springbone';\nimport { VRMLoaderPluginOptions } from './VRMLoaderPluginOptions';\nimport { VRM } from './VRM';\n\nexport class VRMLoaderPlugin implements GLTFLoaderPlugin {\n  public readonly parser: GLTFParser;\n\n  public readonly expressionPlugin: VRMExpressionLoaderPlugin;\n  public readonly firstPersonPlugin: VRMFirstPersonLoaderPlugin;\n  public readonly humanoidPlugin: VRMHumanoidLoaderPlugin;\n  public readonly lookAtPlugin: VRMLookAtLoaderPlugin;\n  public readonly metaPlugin: VRMMetaLoaderPlugin;\n  public readonly mtoonMaterialPlugin: MToonMaterialLoaderPlugin;\n  public readonly materialsHDREmissiveMultiplierPlugin: VRMMaterialsHDREmissiveMultiplierLoaderPlugin;\n  public readonly materialsV0CompatPlugin: VRMMaterialsV0CompatPlugin;\n  public readonly springBonePlugin: VRMSpringBoneLoaderPlugin;\n  public readonly nodeConstraintPlugin: VRMNodeConstraintLoaderPlugin;\n\n  public get name(): string {\n    return 'VRMLoaderPlugin';\n  }\n\n  public constructor(parser: GLTFParser, options?: VRMLoaderPluginOptions) {\n    this.parser = parser;\n\n    const helperRoot = options?.helperRoot;\n    const autoUpdateHumanBones = options?.autoUpdateHumanBones;\n\n    this.expressionPlugin = options?.expressionPlugin ?? new VRMExpressionLoaderPlugin(parser);\n    this.firstPersonPlugin = options?.firstPersonPlugin ?? new VRMFirstPersonLoaderPlugin(parser);\n    this.humanoidPlugin =\n      options?.humanoidPlugin ??\n      new VRMHumanoidLoaderPlugin(parser, {\n        helperRoot,\n        autoUpdateHumanBones,\n      });\n    this.lookAtPlugin = options?.lookAtPlugin ?? new VRMLookAtLoaderPlugin(parser, { helperRoot });\n    this.metaPlugin = options?.metaPlugin ?? new VRMMetaLoaderPlugin(parser);\n    this.mtoonMaterialPlugin = options?.mtoonMaterialPlugin ?? new MToonMaterialLoaderPlugin(parser);\n    this.materialsHDREmissiveMultiplierPlugin =\n      options?.materialsHDREmissiveMultiplierPlugin ?? new VRMMaterialsHDREmissiveMultiplierLoaderPlugin(parser);\n    this.materialsV0CompatPlugin = options?.materialsV0CompatPlugin ?? new VRMMaterialsV0CompatPlugin(parser);\n\n    this.springBonePlugin =\n      options?.springBonePlugin ??\n      new VRMSpringBoneLoaderPlugin(parser, {\n        colliderHelperRoot: helperRoot,\n        jointHelperRoot: helperRoot,\n      });\n\n    this.nodeConstraintPlugin =\n      options?.nodeConstraintPlugin ?? new VRMNodeConstraintLoaderPlugin(parser, { helperRoot });\n  }\n\n  public async beforeRoot(): Promise<void> {\n    await this.materialsV0CompatPlugin.beforeRoot();\n    await this.mtoonMaterialPlugin.beforeRoot();\n  }\n\n  public async loadMesh(meshIndex: number): Promise<THREE.Group | THREE.Mesh | THREE.SkinnedMesh> {\n    return await this.mtoonMaterialPlugin.loadMesh(meshIndex);\n  }\n\n  public getMaterialType(materialIndex: number): typeof THREE.Material | null {\n    const mtoonType = this.mtoonMaterialPlugin.getMaterialType(materialIndex);\n    if (mtoonType != null) {\n      return mtoonType;\n    }\n\n    return null;\n  }\n\n  public async extendMaterialParams(materialIndex: number, materialParams: { [key: string]: any }): Promise<any> {\n    await this.materialsHDREmissiveMultiplierPlugin.extendMaterialParams(materialIndex, materialParams);\n    await this.mtoonMaterialPlugin.extendMaterialParams(materialIndex, materialParams);\n  }\n\n  public async afterRoot(gltf: GLTF): Promise<void> {\n    await this.metaPlugin.afterRoot(gltf);\n    await this.humanoidPlugin.afterRoot(gltf);\n    await this.expressionPlugin.afterRoot(gltf);\n    await this.lookAtPlugin.afterRoot(gltf);\n    await this.firstPersonPlugin.afterRoot(gltf);\n    await this.springBonePlugin.afterRoot(gltf);\n    await this.nodeConstraintPlugin.afterRoot(gltf);\n    await this.mtoonMaterialPlugin.afterRoot(gltf);\n\n    const meta = gltf.userData.vrmMeta as VRMMeta | null;\n    const humanoid = gltf.userData.vrmHumanoid as VRMHumanoid | null;\n\n    // meta and humanoid are required to be a VRM.\n    // Don't create VRM if they are null\n    if (meta && humanoid) {\n      const vrm = new VRM({\n        scene: gltf.scene,\n        expressionManager: gltf.userData.vrmExpressionManager,\n        firstPerson: gltf.userData.vrmFirstPerson,\n        humanoid,\n        lookAt: gltf.userData.vrmLookAt,\n        meta,\n        materials: gltf.userData.vrmMToonMaterials,\n        springBoneManager: gltf.userData.vrmSpringBoneManager,\n        nodeConstraintManager: gltf.userData.vrmNodeConstraintManager,\n      });\n\n      gltf.userData.vrm = vrm;\n    }\n  }\n}\n", "import * as THREE from 'three';\nimport { VRMCore, VRMExpressionMorphTargetBind } from '@pixiv/three-vrm-core';\n\n/**\n * Traverse an entire tree and collect meshes.\n */\nfunction collectMeshes(scene: THREE.Group): Set<THREE.Mesh> {\n  const meshes = new Set<THREE.Mesh>();\n\n  scene.traverse((obj) => {\n    if (!(obj as any).isMesh) {\n      return;\n    }\n\n    const mesh = obj as THREE.Mesh;\n    meshes.add(mesh);\n  });\n\n  return meshes;\n}\n\nfunction combineMorph(\n  positionAttributes: (THREE.BufferAttribute | THREE.InterleavedBufferAttribute)[],\n  binds: Set<VRMExpressionMorphTargetBind>,\n  morphTargetsRelative: boolean,\n): THREE.BufferAttribute | THREE.InterleavedBufferAttribute {\n  // if there is only one morph target and the weight is 1.0, we can use the original as-is\n  if (binds.size === 1) {\n    const bind = binds.values().next().value!;\n    if (bind.weight === 1.0) {\n      return positionAttributes[bind.index];\n    }\n  }\n\n  const newArray = new Float32Array(positionAttributes[0].count * 3);\n  let weightSum = 0.0;\n\n  if (morphTargetsRelative) {\n    weightSum = 1.0;\n  } else {\n    for (const bind of binds) {\n      weightSum += bind.weight;\n    }\n  }\n\n  for (const bind of binds) {\n    const src = positionAttributes[bind.index];\n    const weight = bind.weight / weightSum;\n\n    for (let i = 0; i < src.count; i++) {\n      newArray[i * 3 + 0] += src.getX(i) * weight;\n      newArray[i * 3 + 1] += src.getY(i) * weight;\n      newArray[i * 3 + 2] += src.getZ(i) * weight;\n    }\n  }\n\n  const newAttribute = new THREE.BufferAttribute(newArray, 3);\n  return newAttribute;\n}\n\n/**\n * A map from expression names to a set of morph target binds.\n */\ntype NameBindSetMap = Map<string, Set<VRMExpressionMorphTargetBind>>;\n\n/**\n * Combine morph targets by VRM expressions.\n *\n * This function prevents crashes caused by the limitation of the number of morph targets, especially on mobile devices.\n *\n * @param vrm The VRM instance\n */\nexport function combineMorphs(vrm: VRMCore): void {\n  const meshes = collectMeshes(vrm.scene);\n\n  // Iterate over all expressions and check which morph targets are used\n  const meshNameBindSetMapMap = new Map<THREE.Mesh, NameBindSetMap>();\n\n  const expressionMap = vrm.expressionManager?.expressionMap;\n  if (expressionMap != null) {\n    for (const [expressionName, expression] of Object.entries(expressionMap)) {\n      const bindsToDeleteSet = new Set<VRMExpressionMorphTargetBind>();\n      for (const bind of expression.binds) {\n        if (bind instanceof VRMExpressionMorphTargetBind) {\n          if (bind.weight !== 0.0) {\n            for (const mesh of bind.primitives) {\n              let nameBindSetMap = meshNameBindSetMapMap.get(mesh);\n              if (nameBindSetMap == null) {\n                nameBindSetMap = new Map();\n                meshNameBindSetMapMap.set(mesh, nameBindSetMap);\n              }\n\n              let bindSet = nameBindSetMap.get(expressionName);\n              if (bindSet == null) {\n                bindSet = new Set();\n                nameBindSetMap.set(expressionName, bindSet);\n              }\n\n              bindSet.add(bind);\n            }\n          }\n          bindsToDeleteSet.add(bind);\n        }\n      }\n\n      for (const bind of bindsToDeleteSet) {\n        expression.deleteBind(bind);\n      }\n    }\n  }\n\n  // Combine morphs\n  for (const mesh of meshes) {\n    const nameBindSetMap = meshNameBindSetMapMap.get(mesh);\n    if (nameBindSetMap == null) {\n      continue;\n    }\n\n    // prevent cloning morph attributes\n    const originalMorphAttributes = mesh.geometry.morphAttributes;\n    mesh.geometry.morphAttributes = {};\n\n    const geometry = mesh.geometry.clone();\n    mesh.geometry = geometry;\n    const morphTargetsRelative = geometry.morphTargetsRelative;\n\n    const hasPMorph = originalMorphAttributes.position != null;\n    const hasNMorph = originalMorphAttributes.normal != null;\n\n    const morphAttributes: typeof originalMorphAttributes = {};\n    const morphTargetDictionary: typeof mesh.morphTargetDictionary = {};\n    const morphTargetInfluences: typeof mesh.morphTargetInfluences = [];\n\n    if (hasPMorph || hasNMorph) {\n      if (hasPMorph) {\n        morphAttributes.position = [];\n      }\n      if (hasNMorph) {\n        morphAttributes.normal = [];\n      }\n\n      let i = 0;\n      for (const [name, bindSet] of nameBindSetMap) {\n        if (hasPMorph) {\n          morphAttributes.position![i] = combineMorph(originalMorphAttributes.position!, bindSet, morphTargetsRelative);\n        }\n        if (hasNMorph) {\n          morphAttributes.normal![i] = combineMorph(originalMorphAttributes.normal!, bindSet, morphTargetsRelative);\n        }\n\n        expressionMap?.[name].addBind(\n          new VRMExpressionMorphTargetBind({\n            index: i,\n            weight: 1.0,\n            primitives: [mesh],\n          }),\n        );\n\n        morphTargetDictionary[name] = i;\n        morphTargetInfluences.push(0.0);\n\n        i++;\n      }\n    }\n\n    geometry.morphAttributes = morphAttributes;\n    mesh.morphTargetDictionary = morphTargetDictionary;\n    mesh.morphTargetInfluences = morphTargetInfluences;\n  }\n}\n", "import * as THREE from 'three';\nimport { attributeGetComponentCompat } from '../utils/attributeGetComponentCompat';\nimport { attributeSetComponentCompat } from '../utils/attributeSetComponentCompat';\n\n/**\n * Traverses the given object and combines the skeletons of skinned meshes.\n *\n * Each frame the bone matrices are computed for every skeleton. Combining skeletons\n * reduces the number of calculations needed, improving performance.\n *\n * @param root Root object that will be traversed\n */\nexport function combineSkeletons(root: THREE.Object3D): void {\n  const skinnedMeshes = collectSkinnedMeshes(root);\n\n  /** A set of geometries in the given {@link root}. */\n  const geometries = new Set<THREE.BufferGeometry>();\n  for (const mesh of skinnedMeshes) {\n    // meshes sometimes share the same geometry\n    // we don't want to touch the same attribute twice, so we clone the geometries\n    if (geometries.has(mesh.geometry)) {\n      mesh.geometry = shallowCloneBufferGeometry(mesh.geometry);\n    }\n\n    geometries.add(mesh.geometry);\n  }\n\n  // List all used skin indices for each skin index attribute\n  /** A map: skin index attribute -> skin weight attribute -> used index set */\n  const attributeUsedIndexSetMap = new Map<\n    THREE.BufferAttribute | THREE.InterleavedBufferAttribute,\n    Map<THREE.BufferAttribute | THREE.InterleavedBufferAttribute, Set<number>>\n  >();\n\n  for (const geometry of geometries) {\n    const skinIndexAttr = geometry.getAttribute('skinIndex');\n    const skinIndexMap = attributeUsedIndexSetMap.get(skinIndexAttr) ?? new Map();\n    attributeUsedIndexSetMap.set(skinIndexAttr, skinIndexMap);\n\n    const skinWeightAttr = geometry.getAttribute('skinWeight');\n    const usedIndicesSet = listUsedIndices(skinIndexAttr, skinWeightAttr);\n    skinIndexMap.set(skinWeightAttr, usedIndicesSet);\n  }\n\n  // List all bones and boneInverses for each meshes\n  const meshBoneInverseMapMap = new Map<THREE.SkinnedMesh, Map<THREE.Bone, THREE.Matrix4>>();\n  for (const mesh of skinnedMeshes) {\n    const boneInverseMap = listUsedBones(mesh, attributeUsedIndexSetMap);\n    meshBoneInverseMapMap.set(mesh, boneInverseMap);\n  }\n\n  // Group meshes by bone sets\n  const groups: { boneInverseMap: Map<THREE.Bone, THREE.Matrix4>; meshes: Set<THREE.SkinnedMesh> }[] = [];\n  for (const [mesh, boneInverseMap] of meshBoneInverseMapMap) {\n    let foundMergeableGroup = false;\n    for (const candidate of groups) {\n      // check if the candidate group is mergeable\n      const isMergeable = boneInverseMapIsMergeable(boneInverseMap, candidate.boneInverseMap);\n\n      // if we found a mergeable group, add the mesh to the group\n      if (isMergeable) {\n        foundMergeableGroup = true;\n        candidate.meshes.add(mesh);\n\n        // add lacking bones to the group\n        for (const [bone, boneInverse] of boneInverseMap) {\n          candidate.boneInverseMap.set(bone, boneInverse);\n        }\n\n        break;\n      }\n    }\n\n    // if we couldn't find a mergeable group, create a new group\n    if (!foundMergeableGroup) {\n      groups.push({ boneInverseMap, meshes: new Set([mesh]) });\n    }\n  }\n\n  // prepare new skeletons for each group, and bind them to the meshes\n\n  // the condition to use the same skin index attribute:\n  // - the same skin index attribute\n  // - and the skeleton is same\n  // - and the bone set is same\n  const cache = new Map<string, THREE.BufferAttribute | THREE.InterleavedBufferAttribute>();\n  const skinIndexDispatcher = new ObjectIndexDispatcher<THREE.BufferAttribute | THREE.InterleavedBufferAttribute>();\n  const skeletonDispatcher = new ObjectIndexDispatcher<THREE.Skeleton>();\n  const boneDispatcher = new ObjectIndexDispatcher<THREE.Bone>();\n\n  for (const group of groups) {\n    const { boneInverseMap, meshes } = group;\n\n    // create a new skeleton\n    const newBones = Array.from(boneInverseMap.keys());\n    const newBoneInverses = Array.from(boneInverseMap.values());\n    const newSkeleton = new THREE.Skeleton(newBones, newBoneInverses);\n    const skeletonKey = skeletonDispatcher.getOrCreate(newSkeleton);\n\n    // remap skin index attribute\n    for (const mesh of meshes) {\n      const skinIndexAttr = mesh.geometry.getAttribute('skinIndex');\n      const skinIndexKey = skinIndexDispatcher.getOrCreate(skinIndexAttr);\n\n      const bones = mesh.skeleton.bones;\n      const bonesKey = bones.map((bone) => boneDispatcher.getOrCreate(bone)).join(',');\n\n      // create a key from conditions and check if we already have a remapped skin index attribute\n      const key = `${skinIndexKey};${skeletonKey};${bonesKey}`;\n      let newSkinIndexAttr = cache.get(key);\n\n      // if we don't have a remapped skin index attribute, create one\n      if (newSkinIndexAttr == null) {\n        newSkinIndexAttr = skinIndexAttr.clone();\n        remapSkinIndexAttribute(newSkinIndexAttr, bones, newBones);\n        cache.set(key, newSkinIndexAttr);\n      }\n\n      mesh.geometry.setAttribute('skinIndex', newSkinIndexAttr);\n    }\n\n    // bind the new skeleton to the meshes\n    for (const mesh of meshes) {\n      mesh.bind(newSkeleton, new THREE.Matrix4());\n    }\n  }\n}\n\n/**\n * Traverse an entire tree and collect skinned meshes.\n */\nfunction collectSkinnedMeshes(scene: THREE.Object3D): Set<THREE.SkinnedMesh> {\n  const skinnedMeshes = new Set<THREE.SkinnedMesh>();\n\n  scene.traverse((obj) => {\n    if (!(obj as any).isSkinnedMesh) {\n      return;\n    }\n\n    const skinnedMesh = obj as THREE.SkinnedMesh;\n    skinnedMeshes.add(skinnedMesh);\n  });\n\n  return skinnedMeshes;\n}\n\n/**\n * List all skin indices used by the given geometry.\n * If the skin weight is 0, the index won't be considered as used.\n * @param skinIndexAttr The skin index attribute to list used indices\n * @param skinWeightAttr The skin weight attribute corresponding to the skin index attribute\n */\nfunction listUsedIndices(\n  skinIndexAttr: THREE.BufferAttribute | THREE.InterleavedBufferAttribute,\n  skinWeightAttr: THREE.BufferAttribute | THREE.InterleavedBufferAttribute,\n): Set<number> {\n  const usedIndices = new Set<number>();\n\n  for (let i = 0; i < skinIndexAttr.count; i++) {\n    for (let j = 0; j < skinIndexAttr.itemSize; j++) {\n      const index = attributeGetComponentCompat(skinIndexAttr, i, j);\n      const weight = attributeGetComponentCompat(skinWeightAttr, i, j);\n\n      if (weight !== 0) {\n        usedIndices.add(index);\n      }\n    }\n  }\n\n  return usedIndices;\n}\n\n/**\n * List all bones used by the given skinned mesh.\n * @param mesh The skinned mesh to list used bones\n * @param attributeUsedIndexSetMap A map from skin index attribute to the set of used skin indices\n * @returns A map from used bone to the corresponding bone inverse matrix\n */\nfunction listUsedBones(\n  mesh: THREE.SkinnedMesh,\n  attributeUsedIndexSetMap: Map<\n    THREE.BufferAttribute | THREE.InterleavedBufferAttribute,\n    Map<THREE.BufferAttribute | THREE.InterleavedBufferAttribute, Set<number>>\n  >,\n): Map<THREE.Bone, THREE.Matrix4> {\n  const boneInverseMap = new Map<THREE.Bone, THREE.Matrix4>();\n\n  const skeleton = mesh.skeleton;\n\n  const geometry = mesh.geometry;\n  const skinIndexAttr = geometry.getAttribute('skinIndex');\n  const skinWeightAttr = geometry.getAttribute('skinWeight');\n  const skinIndexMap = attributeUsedIndexSetMap.get(skinIndexAttr);\n  const usedIndicesSet = skinIndexMap?.get(skinWeightAttr);\n\n  if (!usedIndicesSet) {\n    throw new Error(\n      'Unreachable. attributeUsedIndexSetMap does not know the skin index attribute or the skin weight attribute.',\n    );\n  }\n\n  for (const index of usedIndicesSet) {\n    boneInverseMap.set(skeleton.bones[index], skeleton.boneInverses[index]);\n  }\n\n  return boneInverseMap;\n}\n\n/**\n * Check if the given bone inverse map is mergeable to the candidate bone inverse map.\n * @param toCheck The bone inverse map to check\n * @param candidate The candidate bone inverse map\n * @returns True if the bone inverse map is mergeable to the candidate bone inverse map\n */\nfunction boneInverseMapIsMergeable(\n  toCheck: Map<THREE.Bone, THREE.Matrix4>,\n  candidate: Map<THREE.Bone, THREE.Matrix4>,\n): boolean {\n  for (const [bone, boneInverse] of toCheck.entries()) {\n    // if the bone is in the candidate group and the boneInverse is different, it's not mergeable\n    const candidateBoneInverse = candidate.get(bone);\n    if (candidateBoneInverse != null) {\n      if (!matrixEquals(boneInverse, candidateBoneInverse)) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\n/**\n * Remap the skin index attribute from old bones to new bones.\n * This function modifies the given attribute in place.\n * @param attribute The skin index attribute to remap\n * @param oldBones The bone array that the attribute is currently using\n * @param newBones The bone array that the attribute will be using\n */\nfunction remapSkinIndexAttribute(\n  attribute: THREE.BufferAttribute | THREE.InterleavedBufferAttribute,\n  oldBones: THREE.Bone[],\n  newBones: THREE.Bone[],\n): void {\n  // a map from bone to old index\n  const boneOldIndexMap = new Map<THREE.Bone, number>();\n  for (const bone of oldBones) {\n    boneOldIndexMap.set(bone, boneOldIndexMap.size);\n  }\n\n  // a map from old skin index to new skin index\n  const oldToNew = new Map<number, number>();\n  for (const [i, bone] of newBones.entries()) {\n    const oldIndex = boneOldIndexMap.get(bone)!;\n    oldToNew.set(oldIndex, i);\n  }\n\n  // replace the skin index attribute with new indices\n  for (let i = 0; i < attribute.count; i++) {\n    for (let j = 0; j < attribute.itemSize; j++) {\n      const oldIndex = attributeGetComponentCompat(attribute, i, j);\n      const newIndex = oldToNew.get(oldIndex)!;\n      attributeSetComponentCompat(attribute, i, j, newIndex);\n    }\n  }\n\n  attribute.needsUpdate = true;\n}\n\n// https://github.com/mrdoob/three.js/blob/r170/test/unit/src/math/Matrix4.tests.js#L12\nfunction matrixEquals(a: THREE.Matrix4, b: THREE.Matrix4, tolerance?: number) {\n  tolerance = tolerance || 0.0001;\n  if (a.elements.length != b.elements.length) {\n    return false;\n  }\n\n  for (let i = 0, il = a.elements.length; i < il; i++) {\n    const delta = Math.abs(a.elements[i] - b.elements[i]);\n    if (delta > tolerance) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nclass ObjectIndexDispatcher<T> {\n  private _objectIndexMap = new Map<T, number>();\n  private _index = 0;\n\n  public get(obj: T): number | undefined {\n    return this._objectIndexMap.get(obj);\n  }\n\n  public getOrCreate(obj: T): number {\n    let index = this._objectIndexMap.get(obj);\n    if (index == null) {\n      index = this._index;\n      this._objectIndexMap.set(obj, index);\n      this._index++;\n    }\n\n    return index;\n  }\n}\n\n/**\n * Shallow clone a buffer geometry.\n * `BufferGeometry#clone` does a deep clone that also copies the attributes.\n * We want to shallow clone the geometry to avoid copying the attributes.\n *\n * See: https://github.com/mrdoob/three.js/blob/r175/src/core/BufferGeometry.js#L1330\n */\nfunction shallowCloneBufferGeometry(geometry: THREE.BufferGeometry): THREE.BufferGeometry {\n  const clone = new THREE.BufferGeometry();\n\n  clone.name = geometry.name;\n\n  clone.setIndex(geometry.index);\n\n  for (const [name, attribute] of Object.entries(geometry.attributes)) {\n    clone.setAttribute(name, attribute);\n  }\n\n  for (const [key, morphAttributes] of Object.entries(geometry.morphAttributes)) {\n    const attributeName = key as keyof typeof geometry.morphAttributes;\n    clone.morphAttributes[attributeName] = morphAttributes.concat();\n  }\n  clone.morphTargetsRelative = geometry.morphTargetsRelative;\n\n  clone.groups = [];\n  for (const group of geometry.groups) {\n    clone.addGroup(group.start, group.count, group.materialIndex);\n  }\n\n  clone.boundingSphere = geometry.boundingSphere?.clone() ?? null;\n  clone.boundingBox = geometry.boundingBox?.clone() ?? null;\n\n  clone.drawRange.start = geometry.drawRange.start;\n  clone.drawRange.count = geometry.drawRange.count;\n\n  clone.userData = geometry.userData;\n\n  return clone;\n}\n", "import * as THREE from 'three';\n\n// COMPAT: pre-r155\n/**\n * A compat function for `BufferAttribute.getComponent()`.\n * `BufferAttribute.getComponent()` is introduced in r155.\n *\n * See: https://github.com/mrdoob/three.js/pull/24515\n */\nexport function attributeGetComponentCompat(\n  attribute: THREE.BufferAttribute | THREE.InterleavedBufferAttribute,\n  index: number,\n  component: number,\n): number {\n  if ((attribute as any).getComponent) {\n    return (attribute as any).getComponent(index, component);\n  } else {\n    // Ref: https://github.com/mrdoob/three.js/pull/24515/files#diff-fd9bd9820242ad98f71b72535834e02a4500e4788ad62e618a172534b69af013\n    let value = attribute.array[index * attribute.itemSize + component];\n    if (attribute.normalized) {\n      value = THREE.MathUtils.denormalize(value, attribute.array as any);\n    }\n    return value;\n  }\n}\n", "import * as THREE from 'three';\n\n// COMPAT: pre-r155\n/**\n * A compat function for `BufferAttribute.setComponent()`.\n * `BufferAttribute.setComponent()` is introduced in r155.\n *\n * See: https://github.com/mrdoob/three.js/pull/24515\n */\nexport function attributeSetComponentCompat(\n  attribute: THREE.BufferAttribute | THREE.InterleavedBufferAttribute,\n  index: number,\n  component: number,\n  value: number,\n): void {\n  if ((attribute as any).setComponent) {\n    (attribute as any).setComponent(index, component, value);\n  } else {\n    // Ref: https://github.com/mrdoob/three.js/pull/24515/files#diff-fd9bd9820242ad98f71b72535834e02a4500e4788ad62e618a172534b69af013\n    if (attribute.normalized) {\n      value = THREE.MathUtils.normalize(value, attribute.array as any);\n    }\n    attribute.array[index * attribute.itemSize + component] = value;\n  }\n}\n", "// See: https://threejs.org/docs/#manual/en/introduction/How-to-dispose-of-objects\n\nimport * as THREE from 'three';\n\nfunction disposeMaterial(material: THREE.Material): void {\n  Object.values(material).forEach((value) => {\n    if (value?.isTexture) {\n      const texture = value as THREE.Texture;\n      texture.dispose();\n    }\n  });\n\n  if ((material as any).isShaderMaterial) {\n    const uniforms: { [uniform: string]: THREE.IUniform<any> } = (material as any).uniforms;\n    if (uniforms) {\n      Object.values(uniforms).forEach((uniform) => {\n        const value = uniform.value;\n        if (value?.isTexture) {\n          const texture = value as THREE.Texture;\n          texture.dispose();\n        }\n      });\n    }\n  }\n\n  material.dispose();\n}\n\nfunction dispose(object3D: THREE.Object3D): void {\n  const geometry: THREE.BufferGeometry | undefined = (object3D as any).geometry;\n  if (geometry) {\n    geometry.dispose();\n  }\n\n  const skeleton: THREE.Skeleton | undefined = (object3D as any).skeleton;\n  if (skeleton) {\n    skeleton.dispose();\n  }\n\n  const material: THREE.Material | THREE.Material[] | undefined = (object3D as any).material;\n  if (material) {\n    if (Array.isArray(material)) {\n      material.forEach((material: THREE.Material) => disposeMaterial(material));\n    } else if (material) {\n      disposeMaterial(material);\n    }\n  }\n}\n\nexport function deepDispose(object3D: THREE.Object3D): void {\n  object3D.traverse(dispose);\n}\n", "import * as THREE from 'three';\nimport { attributeGetComponentCompat } from '../utils/attributeGetComponentCompat';\nimport { attributeSetComponentCompat } from '../utils/attributeSetComponentCompat';\n\n/**\n * Traverse the given object and remove unnecessarily bound joints from every `THREE.SkinnedMesh`.\n *\n * Some environments like mobile devices have a lower limit of bones\n * and might be unable to perform mesh skinning with many bones.\n * This function might resolve such an issue.\n *\n * Also, this function might significantly improve the performance of mesh skinning.\n *\n * @param root Root object that will be traversed\n *\n * @deprecated `removeUnnecessaryJoints` is deprecated. Use `combineSkeletons` instead. `combineSkeletons` contributes more to the performance improvement. This function will be removed in the next major version.\n */\nexport function removeUnnecessaryJoints(\n  root: THREE.Object3D,\n  options?: {\n    /**\n     * If `true`, this function will compensate skeletons with dummy bones to keep the bone count same between skeletons.\n     *\n     * This option might be effective for the shader compilation performance that matters to the initial rendering time in WebGPURenderer,\n     * especially when the model loaded has many materials and the dependent bone count is different between them.\n     *\n     * Consider this parameter as experimental. We might modify or delete this API without notice in the future.\n     *\n     * `false` by default.\n     */\n    experimentalSameBoneCounts?: boolean;\n  },\n): void {\n  console.warn(\n    'VRMUtils.removeUnnecessaryJoints: removeUnnecessaryJoints is deprecated. Use combineSkeletons instead. combineSkeletons contributes more to the performance improvement. This function will be removed in the next major version.',\n  );\n\n  const experimentalSameBoneCounts = options?.experimentalSameBoneCounts ?? false;\n\n  // Traverse an entire tree, and collect all skinned meshes\n  const skinnedMeshes: THREE.SkinnedMesh[] = [];\n\n  root.traverse((obj) => {\n    if (obj.type !== 'SkinnedMesh') {\n      return;\n    }\n\n    skinnedMeshes.push(obj as THREE.SkinnedMesh);\n  });\n\n  // A map from meshes to new-to-old bone index map\n  // some meshes might share a same skinIndex attribute, and this map also prevents to convert the attribute twice\n  const attributeToBoneIndexMapMap: Map<\n    THREE.BufferAttribute | THREE.InterleavedBufferAttribute,\n    Map<number, number>\n  > = new Map();\n\n  // A maximum number of bones\n  let maxBones = 0;\n\n  // Iterate over all skinned meshes and remap bones for each skin index attribute\n  for (const mesh of skinnedMeshes) {\n    const geometry = mesh.geometry;\n    const attribute = geometry.getAttribute('skinIndex');\n\n    if (attributeToBoneIndexMapMap.has(attribute)) {\n      continue;\n    }\n\n    const oldToNew = new Map<number, number>(); // map of old bone index vs. new bone index\n    const newToOld = new Map<number, number>(); // map of new bone index vs. old bone index\n\n    // create a new bone map\n    for (let i = 0; i < attribute.count; i++) {\n      for (let j = 0; j < attribute.itemSize; j++) {\n        const oldIndex = attributeGetComponentCompat(attribute, i, j);\n        let newIndex = oldToNew.get(oldIndex);\n\n        // new skinIndex buffer\n        if (newIndex == null) {\n          newIndex = oldToNew.size;\n          oldToNew.set(oldIndex, newIndex);\n          newToOld.set(newIndex, oldIndex);\n        }\n\n        attributeSetComponentCompat(attribute, i, j, newIndex);\n      }\n    }\n\n    // replace with new indices\n    attribute.needsUpdate = true;\n\n    // update boneList\n    attributeToBoneIndexMapMap.set(attribute, newToOld);\n\n    // update max bones count\n    maxBones = Math.max(maxBones, oldToNew.size);\n  }\n\n  // Let's actually set the skeletons\n  for (const mesh of skinnedMeshes) {\n    const geometry = mesh.geometry;\n    const attribute = geometry.getAttribute('skinIndex');\n    const newToOld = attributeToBoneIndexMapMap.get(attribute)!;\n\n    const bones: THREE.Bone[] = [];\n    const boneInverses: THREE.Matrix4[] = [];\n\n    // if `experimentalSameBoneCounts` is `true`, compensate skeletons with dummy bones to keep the bone count same between skeletons\n    const nBones = experimentalSameBoneCounts ? maxBones : newToOld.size;\n\n    for (let newIndex = 0; newIndex < nBones; newIndex++) {\n      const oldIndex = newToOld.get(newIndex) ?? 0;\n\n      bones.push(mesh.skeleton.bones[oldIndex]);\n      boneInverses.push(mesh.skeleton.boneInverses[oldIndex]);\n    }\n\n    const skeleton = new THREE.Skeleton(bones, boneInverses);\n    mesh.bind(skeleton, new THREE.Matrix4());\n    //                  ^^^^^^^^^^^^^^^^^^^ transform of meshes should be ignored\n    // See: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\n  }\n}\n", "import * as THREE from 'three';\nimport { BufferAttribute } from 'three';\n\n/**\n * Traverse given object and remove unnecessary vertices from every BufferGeometries.\n * This only processes buffer geometries with index buffer.\n *\n * Three.js creates morph textures for each geometries and it sometimes consumes unnecessary amount of VRAM for certain models.\n * This function will optimize geometries to reduce the size of morph texture.\n * See: https://github.com/mrdoob/three.js/issues/23095\n *\n * @param root Root object that will be traversed\n */\nexport function removeUnnecessaryVertices(root: THREE.Object3D): void {\n  const geometryMap = new Map<THREE.BufferGeometry, THREE.BufferGeometry>();\n\n  // Traverse an entire tree\n  root.traverse((obj) => {\n    if (!(obj as any).isMesh) {\n      return;\n    }\n\n    const mesh = obj as THREE.Mesh;\n    const geometry = mesh.geometry;\n\n    // if the geometry does not have an index buffer it does not need to be processed\n    const originalIndex = geometry.index;\n    if (originalIndex == null) {\n      return;\n    }\n\n    // skip already processed geometry\n    const newGeometryAlreadyExisted = geometryMap.get(geometry);\n    if (newGeometryAlreadyExisted != null) {\n      mesh.geometry = newGeometryAlreadyExisted;\n      return;\n    }\n\n    // determine which vertices are used in the geometry\n    const vertexCount = Object.values(geometry.attributes)[0].count;\n    const vertexInUse = new Array(vertexCount);\n    let verticesUsed = 0;\n\n    const originalIndexArray = originalIndex.array;\n    for (let i = 0; i < originalIndexArray.length; i++) {\n      const index = originalIndexArray[i];\n      if (!vertexInUse[index]) {\n        vertexInUse[index] = true;\n        verticesUsed++;\n      }\n    }\n\n    // if the geometry uses all vertices it does not need to be processed\n    if (verticesUsed === vertexCount) {\n      return;\n    }\n\n    /** from original index to new index */\n    const originalIndexNewIndexMap: number[] = [];\n\n    /** from new index to original index */\n    const newIndexOriginalIndexMap: number[] = [];\n\n    // assign new indices\n    let indexHead = 0;\n    for (let i = 0; i < vertexInUse.length; i++) {\n      if (vertexInUse[i]) {\n        const newIndex = indexHead++;\n        originalIndexNewIndexMap[i] = newIndex;\n        newIndexOriginalIndexMap[newIndex] = i;\n      }\n    }\n\n    const newGeometry = new THREE.BufferGeometry();\n\n    // copy various properties\n    // Ref: https://github.com/mrdoob/three.js/blob/1a241ef10048770d56e06d6cd6a64c76cc720f95/src/core/BufferGeometry.js#L1011\n    newGeometry.name = geometry.name;\n\n    newGeometry.morphTargetsRelative = geometry.morphTargetsRelative;\n\n    geometry.groups.forEach((group) => {\n      newGeometry.addGroup(group.start, group.count, group.materialIndex);\n    });\n\n    newGeometry.boundingBox = geometry.boundingBox?.clone() ?? null;\n    newGeometry.boundingSphere = geometry.boundingSphere?.clone() ?? null;\n\n    newGeometry.setDrawRange(geometry.drawRange.start, geometry.drawRange.count);\n\n    newGeometry.userData = geometry.userData;\n\n    // set to geometryMap\n    geometryMap.set(geometry, newGeometry);\n\n    // reorganize indices\n    {\n      const originalIndexArray = originalIndex.array;\n      const newIndexArray = new (originalIndexArray.constructor as any)(originalIndexArray.length);\n\n      for (let i = 0; i < originalIndexArray.length; i++) {\n        const originalIndex = originalIndexArray[i];\n\n        const newIndex = originalIndexNewIndexMap[originalIndex];\n        newIndexArray[i] = newIndex;\n      }\n\n      newGeometry.setIndex(new BufferAttribute(newIndexArray, 1, false));\n    }\n\n    // reorganize attributes\n    Object.keys(geometry.attributes).forEach((attributeName) => {\n      const originalAttribute = geometry.attributes[attributeName] as THREE.BufferAttribute;\n\n      if ((originalAttribute as any).isInterleavedBufferAttribute) {\n        throw new Error('removeUnnecessaryVertices: InterleavedBufferAttribute is not supported');\n      }\n\n      const originalAttributeArray = originalAttribute.array;\n      const { itemSize, normalized } = originalAttribute;\n\n      const newAttributeArray = new (originalAttributeArray.constructor as any)(\n        newIndexOriginalIndexMap.length * itemSize,\n      );\n\n      newIndexOriginalIndexMap.forEach((originalIndex, i) => {\n        for (let j = 0; j < itemSize; j++) {\n          newAttributeArray[i * itemSize + j] = originalAttributeArray[originalIndex * itemSize + j];\n        }\n      });\n\n      newGeometry.setAttribute(attributeName, new BufferAttribute(newAttributeArray, itemSize, normalized));\n    });\n\n    // reorganize morph attributes\n    /** True if all morphs are zero. */\n    let isNullMorph = true;\n\n    for (const [key, morphAttributes] of Object.entries(geometry.morphAttributes)) {\n      const attributeName = key as keyof typeof geometry.morphAttributes;\n\n      newGeometry.morphAttributes[attributeName] = [];\n\n      for (let iMorph = 0; iMorph < morphAttributes.length; iMorph++) {\n        const originalAttribute = morphAttributes[iMorph] as THREE.BufferAttribute;\n\n        if ((originalAttribute as any).isInterleavedBufferAttribute) {\n          throw new Error('removeUnnecessaryVertices: InterleavedBufferAttribute is not supported');\n        }\n\n        const originalAttributeArray = originalAttribute.array;\n        const { itemSize, normalized } = originalAttribute;\n\n        const newAttributeArray = new (originalAttributeArray.constructor as any)(\n          newIndexOriginalIndexMap.length * itemSize,\n        );\n\n        newIndexOriginalIndexMap.forEach((originalIndex, i) => {\n          for (let j = 0; j < itemSize; j++) {\n            newAttributeArray[i * itemSize + j] = originalAttributeArray[originalIndex * itemSize + j];\n          }\n        });\n\n        isNullMorph = isNullMorph && newAttributeArray.every((v: number) => v === 0);\n\n        newGeometry.morphAttributes[attributeName][iMorph] = new BufferAttribute(\n          newAttributeArray,\n          itemSize,\n          normalized,\n        );\n      }\n    }\n\n    // If all morphs are zero, just discard the morph attributes we've just made\n    if (isNullMorph) {\n      newGeometry.morphAttributes = {};\n    }\n\n    mesh.geometry = newGeometry;\n  });\n\n  Array.from(geometryMap.keys()).forEach((originalGeometry) => {\n    originalGeometry.dispose();\n  });\n}\n", "import { VRM } from '../VRM';\n\n/**\n * If the given VRM is VRM0.0, rotate the `vrm.scene` by 180 degrees around the Y axis.\n *\n * @param vrm The target VRM\n */\nexport function rotateVRM0(vrm: VRM): void {\n  if (vrm.meta?.metaVersion === '0') {\n    vrm.scene.rotation.y = Math.PI;\n  }\n}\n", "import { combineMorphs } from './combineMorphs';\nimport { combineSkeletons } from './combineSkeletons';\nimport { deepDispose } from './deepDispose';\nimport { removeUnnecessaryJoints } from './removeUnnecessaryJoints';\nimport { removeUnnecessaryVertices } from './removeUnnecessaryVertices';\nimport { rotateVRM0 } from './rotateVRM0';\n\nexport class VRMUtils {\n  private constructor() {\n    // this class is not meant to be instantiated\n  }\n\n  public static combineMorphs = combineMorphs;\n  public static combineSkeletons = combineSkeletons;\n  public static deepDispose = deepDispose;\n  public static removeUnnecessaryJoints = removeUnnecessaryJoints;\n  public static removeUnnecessaryVertices = removeUnnecessaryVertices;\n  public static rotateVRM0 = rotateVRM0;\n}\n"],
  "mappings": "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",
  "names": ["__async", "_VRMExpressionMaterialColorBind", "_VRMExpressionTextureTransformBind", "_a", "_VRMExpressionLoaderPlugin", "_b", "_VRMFirstPerson", "POSSIBLE_SPEC_VERSIONS", "_v3A", "_quatA", "_v3B", "_quatB", "_VRMLookAt", "VEC3_POSITIVE_Z", "_eulerA", "mtoon_default", "_MToonMaterialLoaderPlugin", "_VRMMaterialsHDREmissiveMultiplierLoaderPlugin", "__spreadValues", "quatInvertCompat", "_v3C", "_quatC", "constraint", "_VRMNodeConstraintLoaderPlugin", "_matA", "traverseAncestorsFromRoot", "_VRMSpringBoneLoaderPlugin", "_c", "_d", "_e", "material", "originalIndexArray", "originalIndex", "BufferAttribute"]
}
